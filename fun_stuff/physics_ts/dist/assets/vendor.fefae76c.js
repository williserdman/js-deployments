var oc=Object.defineProperty;var Bo=Object.getOwnPropertySymbols;var ac=Object.prototype.hasOwnProperty,lc=Object.prototype.propertyIsEnumerable;var Fo=(a,t,e)=>t in a?oc(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e,Do=(a,t)=>{for(var e in t||(t={}))ac.call(t,e)&&Fo(a,e,t[e]);if(Bo)for(var e of Bo(t))lc.call(t,e)&&Fo(a,e,t[e]);return a};/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const hs="135",cc=0,No=1,hc=2,zo=1,uc=2,zi=3,Vi=0,ge=1,$n=2,Vo=1,bn=0,Oi=1,Oo=2,Uo=3,Wo=4,dc=5,Kn=100,pc=101,fc=102,Go=103,Ho=104,mc=200,vc=201,gc=202,yc=203,ko=204,qo=205,xc=206,_c=207,wc=208,Mc=209,bc=210,Sc=0,Ec=1,Tc=2,us=3,Ac=4,Cc=5,Rc=6,Lc=7,pr=0,Pc=1,Ic=2,Gn=0,Bc=1,Fc=2,Dc=3,Nc=4,zc=5,Xo=300,Ui=301,Wi=302,ds=303,ps=304,fr=306,fs=307,ms=1e3,He=1001,vs=1002,_e=1003,Yo=1004,Zo=1005,Ze=1006,Vc=1007,mr=1008,Sn=1009,Oc=1010,Uc=1011,Gi=1012,Wc=1013,vr=1014,En=1015,ti=1016,Gc=1017,Hc=1018,kc=1019,ei=1020,qc=1021,Hn=1022,Ie=1023,Xc=1024,Yc=1025,Zc=Ie,kn=1026,ni=1027,jc=1028,Jc=1029,Qc=1030,$c=1031,Kc=1032,th=1033,jo=33776,Jo=33777,Qo=33778,$o=33779,Ko=35840,ta=35841,ea=35842,na=35843,eh=36196,ia=37492,ra=37496,nh=37808,ih=37809,rh=37810,sh=37811,oh=37812,ah=37813,lh=37814,ch=37815,hh=37816,uh=37817,dh=37818,ph=37819,fh=37820,mh=37821,vh=36492,gh=37840,yh=37841,xh=37842,_h=37843,wh=37844,Mh=37845,bh=37846,Sh=37847,Eh=37848,Th=37849,Ah=37850,Ch=37851,Rh=37852,Lh=37853,Ph=2200,Ih=2201,Bh=2202,gr=2300,yr=2301,gs=2302,ii=2400,ri=2401,xr=2402,ys=2500,sa=2501,Fh=0,ze=3e3,_r=3001,xs=3007,_s=3002,oa=3004,aa=3005,la=3006,Dh=3200,Nh=3201,si=0,zh=1,ws=7680,Vh=519,Hi=35044,wr=35048,ca="300 es";class qn{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const i=n.slice(0);for(let r=0,s=i.length;r<s;r++)i[r].call(this,t);t.target=null}}}const Se=[];for(let a=0;a<256;a++)Se[a]=(a<16?"0":"")+a.toString(16);const Ms=Math.PI/180,bs=180/Math.PI;function on(){const a=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Se[a&255]+Se[a>>8&255]+Se[a>>16&255]+Se[a>>24&255]+"-"+Se[t&255]+Se[t>>8&255]+"-"+Se[t>>16&15|64]+Se[t>>24&255]+"-"+Se[e&63|128]+Se[e>>8&255]+"-"+Se[e>>16&255]+Se[e>>24&255]+Se[n&255]+Se[n>>8&255]+Se[n>>16&255]+Se[n>>24&255]).toUpperCase()}function ke(a,t,e){return Math.max(t,Math.min(e,a))}function Oh(a,t){return(a%t+t)%t}function Ss(a,t,e){return(1-e)*a+e*t}function ha(a){return(a&a-1)==0&&a!==0}function Uh(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}class Tt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,s=this.y-t.y;return this.x=r*n-s*i+t.x,this.y=r*i+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Tt.prototype.isVector2=!0;class Ee{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,l,h){const u=this.elements;return u[0]=t,u[1]=i,u[2]=o,u[3]=e,u[4]=r,u[5]=l,u[6]=n,u[7]=s,u[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[3],l=n[6],h=n[1],u=n[4],c=n[7],d=n[2],p=n[5],f=n[8],g=i[0],y=i[3],m=i[6],v=i[1],_=i[4],x=i[7],w=i[2],C=i[5],M=i[8];return r[0]=s*g+o*v+l*w,r[3]=s*y+o*_+l*C,r[6]=s*m+o*x+l*M,r[1]=h*g+u*v+c*w,r[4]=h*y+u*_+c*C,r[7]=h*m+u*x+c*M,r[2]=d*g+p*v+f*w,r[5]=d*y+p*_+f*C,r[8]=d*m+p*x+f*M,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],l=t[6],h=t[7],u=t[8];return e*s*u-e*o*h-n*r*u+n*o*l+i*r*h-i*s*l}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],l=t[6],h=t[7],u=t[8],c=u*s-o*h,d=o*l-u*r,p=h*r-s*l,f=e*c+n*d+i*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/f;return t[0]=c*g,t[1]=(i*h-u*n)*g,t[2]=(o*n-i*s)*g,t[3]=d*g,t[4]=(u*e-i*l)*g,t[5]=(i*r-o*e)*g,t[6]=p*g,t[7]=(n*l-h*e)*g,t[8]=(s*e-n*r)*g,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,s,o){const l=Math.cos(r),h=Math.sin(r);return this.set(n*l,n*h,-n*(l*s+h*o)+s+t,-i*h,i*l,-i*(-h*s+l*o)+o+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,r=i[0],s=i[3],o=i[6],l=i[1],h=i[4],u=i[7];return i[0]=e*r+n*l,i[3]=e*s+n*h,i[6]=e*o+n*u,i[1]=-n*r+e*l,i[4]=-n*s+e*h,i[7]=-n*o+e*u,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}Ee.prototype.isMatrix3=!0;function ua(a){if(a.length===0)return-1/0;let t=a[0];for(let e=1,n=a.length;e<n;++e)a[e]>t&&(t=a[e]);return t}function Mr(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}function da(a,t=0){let e=3735928559^t,n=1103547991^t;for(let i=0,r;i<a.length;i++)r=a.charCodeAt(i),e=Math.imul(e^r,2654435761),n=Math.imul(n^r,1597334677);return e=Math.imul(e^e>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(e^e>>>13,3266489909),4294967296*(2097151&n)+(e>>>0)}let oi;class ai{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{oi===void 0&&(oi=Mr("canvas")),oi.width=t.width,oi.height=t.height;const n=oi.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=oi}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let Wh=0;class Te extends qn{constructor(t=Te.DEFAULT_IMAGE,e=Te.DEFAULT_MAPPING,n=He,i=He,r=Ze,s=mr,o=Ie,l=Sn,h=1,u=ze){super();Object.defineProperty(this,"id",{value:Wh++}),this.uuid=on(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=h,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Tt(0,0),this.repeat=new Tt(1,1),this.center=new Tt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ee,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=on()),!e&&t.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let s=0,o=i.length;s<o;s++)i[s].isDataTexture?r.push(Es(i[s].image)):r.push(Es(i[s]))}else r=Es(i);t.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Xo)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ms:t.x=t.x-Math.floor(t.x);break;case He:t.x=t.x<0?0:1;break;case vs:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ms:t.y=t.y-Math.floor(t.y);break;case He:t.y=t.y<0?0:1;break;case vs:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}Te.DEFAULT_IMAGE=void 0;Te.DEFAULT_MAPPING=Xo;Te.prototype.isTexture=!0;function Es(a){return typeof HTMLImageElement!="undefined"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&a instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&a instanceof ImageBitmap?ai.getDataURL(a):a.data?{data:Array.prototype.slice.call(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class ee{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const s=.01,o=.1,l=t.elements,h=l[0],u=l[4],c=l[8],d=l[1],p=l[5],f=l[9],g=l[2],y=l[6],m=l[10];if(Math.abs(u-d)<s&&Math.abs(c-g)<s&&Math.abs(f-y)<s){if(Math.abs(u+d)<o&&Math.abs(c+g)<o&&Math.abs(f+y)<o&&Math.abs(h+p+m-3)<o)return this.set(1,0,0,0),this;e=Math.PI;const _=(h+1)/2,x=(p+1)/2,w=(m+1)/2,C=(u+d)/4,M=(c+g)/4,D=(f+y)/4;return _>x&&_>w?_<s?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(_),i=C/n,r=M/n):x>w?x<s?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(x),n=C/i,r=D/i):w<s?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(w),n=M/r,i=D/r),this.set(n,i,r,e),this}let v=Math.sqrt((y-f)*(y-f)+(c-g)*(c-g)+(d-u)*(d-u));return Math.abs(v)<.001&&(v=1),this.x=(y-f)/v,this.y=(c-g)/v,this.z=(d-u)/v,this.w=Math.acos((h+p+m-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}ee.prototype.isVector4=!0;class je extends qn{constructor(t,e,n={}){super();this.width=t,this.height=e,this.depth=1,this.scissor=new ee(0,0,t,e),this.scissorTest=!1,this.viewport=new ee(0,0,t,e),this.texture=new Te(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Ze,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image=Do({},this.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}je.prototype.isWebGLRenderTarget=!0;class Gh extends je{constructor(t,e,n){super(t,e);const i=this.texture;this.texture=[];for(let r=0;r<n;r++)this.texture[r]=i.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}Gh.prototype.isWebGLMultipleRenderTargets=!0;class Ts extends je{constructor(t,e,n={}){super(t,e,n);this.samples=4,this.ignoreDepthForMultisampleCopy=n.ignoreDepth!==void 0?n.ignoreDepth:!0,this.useRenderToTexture=n.useRenderToTexture!==void 0?n.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(t){return super.copy.call(this,t),this.samples=t.samples,this.useRenderToTexture=t.useRenderToTexture,this.useRenderbuffer=t.useRenderbuffer,this}}Ts.prototype.isWebGLMultisampleRenderTarget=!0;class Ve{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,r,s,o){let l=n[i+0],h=n[i+1],u=n[i+2],c=n[i+3];const d=r[s+0],p=r[s+1],f=r[s+2],g=r[s+3];if(o===0){t[e+0]=l,t[e+1]=h,t[e+2]=u,t[e+3]=c;return}if(o===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=g;return}if(c!==g||l!==d||h!==p||u!==f){let y=1-o;const m=l*d+h*p+u*f+c*g,v=m>=0?1:-1,_=1-m*m;if(_>Number.EPSILON){const w=Math.sqrt(_),C=Math.atan2(w,m*v);y=Math.sin(y*C)/w,o=Math.sin(o*C)/w}const x=o*v;if(l=l*y+d*x,h=h*y+p*x,u=u*y+f*x,c=c*y+g*x,y===1-o){const w=1/Math.sqrt(l*l+h*h+u*u+c*c);l*=w,h*=w,u*=w,c*=w}}t[e]=l,t[e+1]=h,t[e+2]=u,t[e+3]=c}static multiplyQuaternionsFlat(t,e,n,i,r,s){const o=n[i],l=n[i+1],h=n[i+2],u=n[i+3],c=r[s],d=r[s+1],p=r[s+2],f=r[s+3];return t[e]=o*f+u*c+l*p-h*d,t[e+1]=l*f+u*d+h*c-o*p,t[e+2]=h*f+u*p+o*d-l*c,t[e+3]=u*f-o*c-l*d-h*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,r=t._z,s=t._order,o=Math.cos,l=Math.sin,h=o(n/2),u=o(i/2),c=o(r/2),d=l(n/2),p=l(i/2),f=l(r/2);switch(s){case"XYZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"YXZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"ZXY":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"ZYX":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"YZX":this._x=d*u*c+h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c-d*p*f;break;case"XZY":this._x=d*u*c-h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],o=e[5],l=e[9],h=e[2],u=e[6],c=e[10],d=n+o+c;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(r-h)*p,this._z=(s-i)*p}else if(n>o&&n>c){const p=2*Math.sqrt(1+n-o-c);this._w=(u-l)/p,this._x=.25*p,this._y=(i+s)/p,this._z=(r+h)/p}else if(o>c){const p=2*Math.sqrt(1+o-n-c);this._w=(r-h)/p,this._x=(i+s)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+c-n-o);this._w=(s-i)/p,this._x=(r+h)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ke(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,o=e._x,l=e._y,h=e._z,u=e._w;return this._x=n*u+s*o+i*h-r*l,this._y=i*u+s*l+r*o-n*h,this._z=r*u+s*h+n*l-i*o,this._w=s*u-n*o-i*l-r*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,r=this._z,s=this._w;let o=s*t._w+n*t._x+i*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=s,this._x=n,this._y=i,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const p=1-e;return this._w=p*s+e*this._w,this._x=p*n+e*this._x,this._y=p*i+e*this._y,this._z=p*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const h=Math.sqrt(l),u=Math.atan2(h,o),c=Math.sin((1-e)*u)/h,d=Math.sin(e*u)/h;return this._w=s*c+this._w*d,this._x=n*c+this._x*d,this._y=i*c+this._y*d,this._z=r*c+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),n*Math.sin(r),n*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Ve.prototype.isQuaternion=!0;class G{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(pa.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(pa.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,s=t.y,o=t.z,l=t.w,h=l*e+s*i-o*n,u=l*n+o*e-r*i,c=l*i+r*n-s*e,d=-r*e-s*n-o*i;return this.x=h*l+d*-r+u*-o-c*-s,this.y=u*l+d*-s+c*-r-h*-o,this.z=c*l+d*-o+h*-s-u*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,o=e.y,l=e.z;return this.x=i*l-r*o,this.y=r*s-n*l,this.z=n*o-i*s,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return As.copy(this).projectOnVector(t),this.sub(As)}reflect(t){return this.sub(As.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(ke(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}G.prototype.isVector3=!0;const As=new G,pa=new Ve;class Ke{constructor(t=new G(1/0,1/0,1/0),e=new G(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let l=0,h=t.length;l<h;l+=3){const u=t[l],c=t[l+1],d=t[l+2];u<e&&(e=u),c<n&&(n=c),d<i&&(i=d),u>r&&(r=u),c>s&&(s=c),d>o&&(o=d)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,r=-1/0,s=-1/0,o=-1/0;for(let l=0,h=t.count;l<h;l++){const u=t.getX(l),c=t.getY(l),d=t.getZ(l);u<e&&(e=u),c<n&&(n=c),d<i&&(i=d),u>r&&(r=u),c>s&&(s=c),d>o&&(o=d)}return this.min.set(e,n,i),this.max.set(r,s,o),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ki.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),Cs.copy(e.boundingBox),Cs.applyMatrix4(t.matrixWorld),this.union(Cs));const n=t.children;for(let i=0,r=n.length;i<r;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,ki),ki.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(qi),br.subVectors(this.max,qi),li.subVectors(t.a,qi),ci.subVectors(t.b,qi),hi.subVectors(t.c,qi),Tn.subVectors(ci,li),An.subVectors(hi,ci),Xn.subVectors(li,hi);let e=[0,-Tn.z,Tn.y,0,-An.z,An.y,0,-Xn.z,Xn.y,Tn.z,0,-Tn.x,An.z,0,-An.x,Xn.z,0,-Xn.x,-Tn.y,Tn.x,0,-An.y,An.x,0,-Xn.y,Xn.x,0];return!Rs(e,li,ci,hi,br)||(e=[1,0,0,0,1,0,0,0,1],!Rs(e,li,ci,hi,br))?!1:(Sr.crossVectors(Tn,An),e=[Sr.x,Sr.y,Sr.z],Rs(e,li,ci,hi,br))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ki.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(ki).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(mn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),mn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),mn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),mn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),mn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),mn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),mn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),mn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(mn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Ke.prototype.isBox3=!0;const mn=[new G,new G,new G,new G,new G,new G,new G,new G],ki=new G,Cs=new Ke,li=new G,ci=new G,hi=new G,Tn=new G,An=new G,Xn=new G,qi=new G,br=new G,Sr=new G,Yn=new G;function Rs(a,t,e,n,i){for(let r=0,s=a.length-3;r<=s;r+=3){Yn.fromArray(a,r);const o=i.x*Math.abs(Yn.x)+i.y*Math.abs(Yn.y)+i.z*Math.abs(Yn.z),l=t.dot(Yn),h=e.dot(Yn),u=n.dot(Yn);if(Math.max(-Math.max(l,h,u),Math.min(l,h,u))>o)return!1}return!0}const Hh=new Ke,fa=new G,Ls=new G,Ps=new G;class ui{constructor(t=new G,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Hh.setFromPoints(t).getCenter(n);let i=0;for(let r=0,s=t.length;r<s;r++)i=Math.max(i,n.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Ps.subVectors(t,this.center);const e=Ps.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=(n-this.radius)*.5;this.center.add(Ps.multiplyScalar(i/n)),this.radius+=i}return this}union(t){return Ls.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(fa.copy(t.center).add(Ls)),this.expandByPoint(fa.copy(t.center).sub(Ls)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const vn=new G,Is=new G,Er=new G,Cn=new G,Bs=new G,Tr=new G,Fs=new G;class di{constructor(t=new G,e=new G(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,vn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=vn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(vn.copy(this.direction).multiplyScalar(e).add(this.origin),vn.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Is.copy(t).add(e).multiplyScalar(.5),Er.copy(e).sub(t).normalize(),Cn.copy(this.origin).sub(Is);const r=t.distanceTo(e)*.5,s=-this.direction.dot(Er),o=Cn.dot(this.direction),l=-Cn.dot(Er),h=Cn.lengthSq(),u=Math.abs(1-s*s);let c,d,p,f;if(u>0)if(c=s*l-o,d=s*o-l,f=r*u,c>=0)if(d>=-f)if(d<=f){const g=1/u;c*=g,d*=g,p=c*(c+s*d+2*o)+d*(s*c+d+2*l)+h}else d=r,c=Math.max(0,-(s*d+o)),p=-c*c+d*(d+2*l)+h;else d=-r,c=Math.max(0,-(s*d+o)),p=-c*c+d*(d+2*l)+h;else d<=-f?(c=Math.max(0,-(-s*r+o)),d=c>0?-r:Math.min(Math.max(-r,-l),r),p=-c*c+d*(d+2*l)+h):d<=f?(c=0,d=Math.min(Math.max(-r,-l),r),p=d*(d+2*l)+h):(c=Math.max(0,-(s*r+o)),d=c>0?r:Math.min(Math.max(-r,-l),r),p=-c*c+d*(d+2*l)+h);else d=s>0?-r:r,c=Math.max(0,-(s*d+o)),p=-c*c+d*(d+2*l)+h;return n&&n.copy(this.direction).multiplyScalar(c).add(this.origin),i&&i.copy(Er).multiplyScalar(d).add(Is),p}intersectSphere(t,e){vn.subVectors(t.center,this.origin);const n=vn.dot(this.direction),i=vn.dot(vn)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),o=n-s,l=n+s;return o<0&&l<0?null:o<0?this.at(l,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,s,o,l;const h=1/this.direction.x,u=1/this.direction.y,c=1/this.direction.z,d=this.origin;return h>=0?(n=(t.min.x-d.x)*h,i=(t.max.x-d.x)*h):(n=(t.max.x-d.x)*h,i=(t.min.x-d.x)*h),u>=0?(r=(t.min.y-d.y)*u,s=(t.max.y-d.y)*u):(r=(t.max.y-d.y)*u,s=(t.min.y-d.y)*u),n>s||r>i||((r>n||n!==n)&&(n=r),(s<i||i!==i)&&(i=s),c>=0?(o=(t.min.z-d.z)*c,l=(t.max.z-d.z)*c):(o=(t.max.z-d.z)*c,l=(t.min.z-d.z)*c),n>l||o>i)||((o>n||n!==n)&&(n=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,e)}intersectsBox(t){return this.intersectBox(t,vn)!==null}intersectTriangle(t,e,n,i,r){Bs.subVectors(e,t),Tr.subVectors(n,t),Fs.crossVectors(Bs,Tr);let s=this.direction.dot(Fs),o;if(s>0){if(i)return null;o=1}else if(s<0)o=-1,s=-s;else return null;Cn.subVectors(this.origin,t);const l=o*this.direction.dot(Tr.crossVectors(Cn,Tr));if(l<0)return null;const h=o*this.direction.dot(Bs.cross(Cn));if(h<0||l+h>s)return null;const u=-o*Cn.dot(Fs);return u<0?null:this.at(u/s,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Wt{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,r,s,o,l,h,u,c,d,p,f,g,y){const m=this.elements;return m[0]=t,m[4]=e,m[8]=n,m[12]=i,m[1]=r,m[5]=s,m[9]=o,m[13]=l,m[2]=h,m[6]=u,m[10]=c,m[14]=d,m[3]=p,m[7]=f,m[11]=g,m[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Wt().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/pi.setFromMatrixColumn(t,0).length(),r=1/pi.setFromMatrixColumn(t,1).length(),s=1/pi.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,r=t.z,s=Math.cos(n),o=Math.sin(n),l=Math.cos(i),h=Math.sin(i),u=Math.cos(r),c=Math.sin(r);if(t.order==="XYZ"){const d=s*u,p=s*c,f=o*u,g=o*c;e[0]=l*u,e[4]=-l*c,e[8]=h,e[1]=p+f*h,e[5]=d-g*h,e[9]=-o*l,e[2]=g-d*h,e[6]=f+p*h,e[10]=s*l}else if(t.order==="YXZ"){const d=l*u,p=l*c,f=h*u,g=h*c;e[0]=d+g*o,e[4]=f*o-p,e[8]=s*h,e[1]=s*c,e[5]=s*u,e[9]=-o,e[2]=p*o-f,e[6]=g+d*o,e[10]=s*l}else if(t.order==="ZXY"){const d=l*u,p=l*c,f=h*u,g=h*c;e[0]=d-g*o,e[4]=-s*c,e[8]=f+p*o,e[1]=p+f*o,e[5]=s*u,e[9]=g-d*o,e[2]=-s*h,e[6]=o,e[10]=s*l}else if(t.order==="ZYX"){const d=s*u,p=s*c,f=o*u,g=o*c;e[0]=l*u,e[4]=f*h-p,e[8]=d*h+g,e[1]=l*c,e[5]=g*h+d,e[9]=p*h-f,e[2]=-h,e[6]=o*l,e[10]=s*l}else if(t.order==="YZX"){const d=s*l,p=s*h,f=o*l,g=o*h;e[0]=l*u,e[4]=g-d*c,e[8]=f*c+p,e[1]=c,e[5]=s*u,e[9]=-o*u,e[2]=-h*u,e[6]=p*c+f,e[10]=d-g*c}else if(t.order==="XZY"){const d=s*l,p=s*h,f=o*l,g=o*h;e[0]=l*u,e[4]=-c,e[8]=h*u,e[1]=d*c+g,e[5]=s*u,e[9]=p*c-f,e[2]=f*c-p,e[6]=o*u,e[10]=g*c+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(kh,t,qh)}lookAt(t,e,n){const i=this.elements;return qe.subVectors(t,e),qe.lengthSq()===0&&(qe.z=1),qe.normalize(),Rn.crossVectors(n,qe),Rn.lengthSq()===0&&(Math.abs(n.z)===1?qe.x+=1e-4:qe.z+=1e-4,qe.normalize(),Rn.crossVectors(n,qe)),Rn.normalize(),Ar.crossVectors(qe,Rn),i[0]=Rn.x,i[4]=Ar.x,i[8]=qe.x,i[1]=Rn.y,i[5]=Ar.y,i[9]=qe.y,i[2]=Rn.z,i[6]=Ar.z,i[10]=qe.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],o=n[4],l=n[8],h=n[12],u=n[1],c=n[5],d=n[9],p=n[13],f=n[2],g=n[6],y=n[10],m=n[14],v=n[3],_=n[7],x=n[11],w=n[15],C=i[0],M=i[4],D=i[8],j=i[12],N=i[1],b=i[5],U=i[9],V=i[13],H=i[2],Y=i[6],Q=i[10],P=i[14],z=i[3],it=i[7],W=i[11],T=i[15];return r[0]=s*C+o*N+l*H+h*z,r[4]=s*M+o*b+l*Y+h*it,r[8]=s*D+o*U+l*Q+h*W,r[12]=s*j+o*V+l*P+h*T,r[1]=u*C+c*N+d*H+p*z,r[5]=u*M+c*b+d*Y+p*it,r[9]=u*D+c*U+d*Q+p*W,r[13]=u*j+c*V+d*P+p*T,r[2]=f*C+g*N+y*H+m*z,r[6]=f*M+g*b+y*Y+m*it,r[10]=f*D+g*U+y*Q+m*W,r[14]=f*j+g*V+y*P+m*T,r[3]=v*C+_*N+x*H+w*z,r[7]=v*M+_*b+x*Y+w*it,r[11]=v*D+_*U+x*Q+w*W,r[15]=v*j+_*V+x*P+w*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],o=t[5],l=t[9],h=t[13],u=t[2],c=t[6],d=t[10],p=t[14],f=t[3],g=t[7],y=t[11],m=t[15];return f*(+r*l*c-i*h*c-r*o*d+n*h*d+i*o*p-n*l*p)+g*(+e*l*p-e*h*d+r*s*d-i*s*p+i*h*u-r*l*u)+y*(+e*h*c-e*o*p-r*s*c+n*s*p+r*o*u-n*h*u)+m*(-i*o*u-e*l*c+e*o*d+i*s*c-n*s*d+n*l*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],s=t[4],o=t[5],l=t[6],h=t[7],u=t[8],c=t[9],d=t[10],p=t[11],f=t[12],g=t[13],y=t[14],m=t[15],v=c*y*h-g*d*h+g*l*p-o*y*p-c*l*m+o*d*m,_=f*d*h-u*y*h-f*l*p+s*y*p+u*l*m-s*d*m,x=u*g*h-f*c*h+f*o*p-s*g*p-u*o*m+s*c*m,w=f*c*l-u*g*l-f*o*d+s*g*d+u*o*y-s*c*y,C=e*v+n*_+i*x+r*w;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const M=1/C;return t[0]=v*M,t[1]=(g*d*r-c*y*r-g*i*p+n*y*p+c*i*m-n*d*m)*M,t[2]=(o*y*r-g*l*r+g*i*h-n*y*h-o*i*m+n*l*m)*M,t[3]=(c*l*r-o*d*r-c*i*h+n*d*h+o*i*p-n*l*p)*M,t[4]=_*M,t[5]=(u*y*r-f*d*r+f*i*p-e*y*p-u*i*m+e*d*m)*M,t[6]=(f*l*r-s*y*r-f*i*h+e*y*h+s*i*m-e*l*m)*M,t[7]=(s*d*r-u*l*r+u*i*h-e*d*h-s*i*p+e*l*p)*M,t[8]=x*M,t[9]=(f*c*r-u*g*r-f*n*p+e*g*p+u*n*m-e*c*m)*M,t[10]=(s*g*r-f*o*r+f*n*h-e*g*h-s*n*m+e*o*m)*M,t[11]=(u*o*r-s*c*r-u*n*h+e*c*h+s*n*p-e*o*p)*M,t[12]=w*M,t[13]=(u*g*i-f*c*i+f*n*d-e*g*d-u*n*y+e*c*y)*M,t[14]=(f*o*i-s*g*i-f*n*l+e*g*l+s*n*y-e*o*y)*M,t[15]=(s*c*i-u*o*i+u*n*l-e*c*l-s*n*d+e*o*d)*M,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,o=t.y,l=t.z,h=r*s,u=r*o;return this.set(h*s+n,h*o-i*l,h*l+i*o,0,h*o+i*l,u*o+n,u*l-i*s,0,h*l-i*o,u*l+i*s,r*l*l+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,s){return this.set(1,n,r,0,t,1,s,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,s=e._y,o=e._z,l=e._w,h=r+r,u=s+s,c=o+o,d=r*h,p=r*u,f=r*c,g=s*u,y=s*c,m=o*c,v=l*h,_=l*u,x=l*c,w=n.x,C=n.y,M=n.z;return i[0]=(1-(g+m))*w,i[1]=(p+x)*w,i[2]=(f-_)*w,i[3]=0,i[4]=(p-x)*C,i[5]=(1-(d+m))*C,i[6]=(y+v)*C,i[7]=0,i[8]=(f+_)*M,i[9]=(y-v)*M,i[10]=(1-(d+g))*M,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=pi.set(i[0],i[1],i[2]).length();const s=pi.set(i[4],i[5],i[6]).length(),o=pi.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],tn.copy(this);const h=1/r,u=1/s,c=1/o;return tn.elements[0]*=h,tn.elements[1]*=h,tn.elements[2]*=h,tn.elements[4]*=u,tn.elements[5]*=u,tn.elements[6]*=u,tn.elements[8]*=c,tn.elements[9]*=c,tn.elements[10]*=c,e.setFromRotationMatrix(tn),n.x=r,n.y=s,n.z=o,this}makePerspective(t,e,n,i,r,s){s===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,l=2*r/(e-t),h=2*r/(n-i),u=(e+t)/(e-t),c=(n+i)/(n-i),d=-(s+r)/(s-r),p=-2*s*r/(s-r);return o[0]=l,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=h,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,i,r,s){const o=this.elements,l=1/(e-t),h=1/(n-i),u=1/(s-r),c=(e+t)*l,d=(n+i)*h,p=(s+r)*u;return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-c,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*u,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Wt.prototype.isMatrix4=!0;const pi=new G,tn=new Wt,kh=new G(0,0,0),qh=new G(1,1,1),Rn=new G,Ar=new G,qe=new G,ma=new Wt,va=new Ve;class fi{constructor(t=0,e=0,n=0,i=fi.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],s=i[4],o=i[8],l=i[1],h=i[5],u=i[9],c=i[2],d=i[6],p=i[10];switch(e){case"XYZ":this._y=Math.asin(ke(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(d,h),this._z=0);break;case"YXZ":this._x=Math.asin(-ke(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-c,r),this._z=0);break;case"ZXY":this._x=Math.asin(ke(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-c,p),this._z=Math.atan2(-s,h)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-ke(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-s,h));break;case"YZX":this._z=Math.asin(ke(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-c,r)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-ke(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(d,h),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return ma.makeRotationFromQuaternion(t),this.setFromRotationMatrix(ma,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return va.setFromEuler(this),this.setFromQuaternion(va,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new G(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}fi.prototype.isEuler=!0;fi.DefaultOrder="XYZ";fi.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Xh{constructor(){this.mask=1|0}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}isEnabled(t){return(this.mask&(1<<t|0))!=0}}let Yh=0;const ga=new G,mi=new Ve,gn=new Wt,Cr=new G,Xi=new G,Zh=new G,jh=new Ve,ya=new G(1,0,0),xa=new G(0,1,0),_a=new G(0,0,1),Jh={type:"added"},wa={type:"removed"};class Qt extends qn{constructor(){super();Object.defineProperty(this,"id",{value:Yh++}),this.uuid=on(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Qt.DefaultUp.clone();const t=new G,e=new fi,n=new Ve,i=new G(1,1,1);function r(){n.setFromEuler(e,!1)}function s(){e.setFromQuaternion(n,void 0,!1)}e._onChange(r),n._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Wt},normalMatrix:{value:new Ee}}),this.matrix=new Wt,this.matrixWorld=new Wt,this.matrixAutoUpdate=Qt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Xh,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return mi.setFromAxisAngle(t,e),this.quaternion.multiply(mi),this}rotateOnWorldAxis(t,e){return mi.setFromAxisAngle(t,e),this.quaternion.premultiply(mi),this}rotateX(t){return this.rotateOnAxis(ya,t)}rotateY(t){return this.rotateOnAxis(xa,t)}rotateZ(t){return this.rotateOnAxis(_a,t)}translateOnAxis(t,e){return ga.copy(t).applyQuaternion(this.quaternion),this.position.add(ga.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ya,t)}translateY(t){return this.translateOnAxis(xa,t)}translateZ(t){return this.translateOnAxis(_a,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(gn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?Cr.copy(t):Cr.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),Xi.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?gn.lookAt(Xi,Cr,this.up):gn.lookAt(Cr,Xi,this.up),this.quaternion.setFromRotationMatrix(gn),i&&(gn.extractRotation(i.matrixWorld),mi.setFromRotationMatrix(gn),this.quaternion.premultiply(mi.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Jh)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(wa)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(wa)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),gn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),gn.multiply(t.parent.matrixWorld)),t.applyMatrix4(gn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const s=this.children[n].getObjectByProperty(t,e);if(s!==void 0)return s}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Xi,t,Zh),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Xi,jh,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let r=0,s=i.length;r<s;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let h=0,u=l.length;h<u;h++){const c=l[h];r(t.shapes,c)}else r(t.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,h=this.material.length;l<h;l++)o.push(r(t.materials,this.material[l]));i.material=o}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(r(t.animations,l))}}if(e){const o=s(t.geometries),l=s(t.materials),h=s(t.textures),u=s(t.images),c=s(t.shapes),d=s(t.skeletons),p=s(t.animations);o.length>0&&(n.geometries=o),l.length>0&&(n.materials=l),h.length>0&&(n.textures=h),u.length>0&&(n.images=u),c.length>0&&(n.shapes=c),d.length>0&&(n.skeletons=d),p.length>0&&(n.animations=p)}return n.object=i,n;function s(o){const l=[];for(const h in o){const u=o[h];delete u.metadata,l.push(u)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}Qt.DefaultUp=new G(0,1,0);Qt.DefaultMatrixAutoUpdate=!0;Qt.prototype.isObject3D=!0;const en=new G,yn=new G,Ds=new G,xn=new G,vi=new G,gi=new G,Ma=new G,Ns=new G,zs=new G,Vs=new G;class ve{constructor(t=new G,e=new G,n=new G){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),en.subVectors(t,e),i.cross(en);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){en.subVectors(i,e),yn.subVectors(n,e),Ds.subVectors(t,e);const s=en.dot(en),o=en.dot(yn),l=en.dot(Ds),h=yn.dot(yn),u=yn.dot(Ds),c=s*h-o*o;if(c===0)return r.set(-2,-1,-1);const d=1/c,p=(h*l-o*u)*d,f=(s*u-o*l)*d;return r.set(1-p-f,f,p)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,xn),xn.x>=0&&xn.y>=0&&xn.x+xn.y<=1}static getUV(t,e,n,i,r,s,o,l){return this.getBarycoord(t,e,n,i,xn),l.set(0,0),l.addScaledVector(r,xn.x),l.addScaledVector(s,xn.y),l.addScaledVector(o,xn.z),l}static isFrontFacing(t,e,n,i){return en.subVectors(n,e),yn.subVectors(t,e),en.cross(yn).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return en.subVectors(this.c,this.b),yn.subVectors(this.a,this.b),en.cross(yn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ve.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ve.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return ve.getUV(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return ve.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ve.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let s,o;vi.subVectors(i,n),gi.subVectors(r,n),Ns.subVectors(t,n);const l=vi.dot(Ns),h=gi.dot(Ns);if(l<=0&&h<=0)return e.copy(n);zs.subVectors(t,i);const u=vi.dot(zs),c=gi.dot(zs);if(u>=0&&c<=u)return e.copy(i);const d=l*c-u*h;if(d<=0&&l>=0&&u<=0)return s=l/(l-u),e.copy(n).addScaledVector(vi,s);Vs.subVectors(t,r);const p=vi.dot(Vs),f=gi.dot(Vs);if(f>=0&&p<=f)return e.copy(r);const g=p*h-l*f;if(g<=0&&h>=0&&f<=0)return o=h/(h-f),e.copy(n).addScaledVector(gi,o);const y=u*f-p*c;if(y<=0&&c-u>=0&&p-f>=0)return Ma.subVectors(r,i),o=(c-u)/(c-u+(p-f)),e.copy(i).addScaledVector(Ma,o);const m=1/(y+g+d);return s=g*m,o=d*m,e.copy(n).addScaledVector(vi,s).addScaledVector(gi,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Qh=0;class Ce extends qn{constructor(){super();Object.defineProperty(this,"id",{value:Qh++}),this.uuid=on(),this.name="",this.type="Material",this.fog=!0,this.blending=Oi,this.side=Vi,this.vertexColors=!1,this.opacity=1,this.format=Ie,this.transparent=!1,this.blendSrc=ko,this.blendDst=qo,this.blendEquation=Kn,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=us,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Vh,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ws,this.stencilZFail=ws,this.stencilZPass=ws,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Vo;continue}const i=this[e];if(i===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Oi&&(n.blending=this.blending),this.side!==Vi&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==Ie&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(r){const s=[];for(const o in r){const l=r[o];delete l.metadata,s.push(l)}return s}if(e){const r=i(t.textures),s=i(t.images);r.length>0&&(n.textures=r),s.length>0&&(n.images=s)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const i=e.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Ce.prototype.isMaterial=!0;const ba={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},nn={h:0,s:0,l:0},Rr={h:0,s:0,l:0};function Os(a,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?a+(t-a)*6*e:e<1/2?t:e<2/3?a+(t-a)*6*(2/3-e):a}function Us(a){return a<.04045?a*.0773993808:Math.pow(a*.9478672986+.0521327014,2.4)}function Ws(a){return a<.0031308?a*12.92:1.055*Math.pow(a,.41666)-.055}class Ot{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=Oh(t,1),e=ke(e,0,1),n=ke(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Os(r,i,t+1/3),this.g=Os(r,i,t),this.b=Os(r,i,t-1/3)}return this}setStyle(t){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let i;const r=n[1],s=n[2];switch(r){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,e(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,e(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const o=parseFloat(i[1])/360,l=parseInt(i[2],10)/100,h=parseInt(i[3],10)/100;return e(i[4]),this.setHSL(o,l,h)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],r=i.length;if(r===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=ba[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=Us(t.r),this.g=Us(t.g),this.b=Us(t.b),this}copyLinearToSRGB(t){return this.r=Ws(t.r),this.g=Ws(t.g),this.b=Ws(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,i=this.b,r=Math.max(e,n,i),s=Math.min(e,n,i);let o,l;const h=(s+r)/2;if(s===r)o=0,l=0;else{const u=r-s;switch(l=h<=.5?u/(r+s):u/(2-r-s),r){case e:o=(n-i)/u+(n<i?6:0);break;case n:o=(i-e)/u+2;break;case i:o=(e-n)/u+4;break}o/=6}return t.h=o,t.s=l,t.l=h,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(nn),nn.h+=t,nn.s+=e,nn.l+=n,this.setHSL(nn.h,nn.s,nn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(nn),t.getHSL(Rr);const n=Ss(nn.h,Rr.h,e),i=Ss(nn.s,Rr.s,e),r=Ss(nn.l,Rr.l,e);return this.setHSL(n,i,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ot.NAMES=ba;Ot.prototype.isColor=!0;Ot.prototype.r=1;Ot.prototype.g=1;Ot.prototype.b=1;class Gs extends Ce{constructor(t){super();this.type="MeshBasicMaterial",this.color=new Ot(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=pr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}Gs.prototype.isMeshBasicMaterial=!0;const ne=new G,Lr=new Tt;class ye{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=Hi,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let s=t[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),s=new Ot),e[n++]=s.r,e[n++]=s.g,e[n++]=s.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let s=t[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),s=new Tt),e[n++]=s.x,e[n++]=s.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let s=t[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),s=new G),e[n++]=s.x,e[n++]=s.y,e[n++]=s.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,r=t.length;i<r;i++){let s=t[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),s=new ee),e[n++]=s.x,e[n++]=s.y,e[n++]=s.z,e[n++]=s.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)Lr.fromBufferAttribute(this,e),Lr.applyMatrix3(t),this.setXY(e,Lr.x,Lr.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)ne.fromBufferAttribute(this,e),ne.applyMatrix3(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.applyMatrix4(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.applyNormalMatrix(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)ne.x=this.getX(e),ne.y=this.getY(e),ne.z=this.getZ(e),ne.transformDirection(t),this.setXYZ(e,ne.x,ne.y,ne.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Hi&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}ye.prototype.isBufferAttribute=!0;class Sa extends ye{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Ea extends ye{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class $h extends ye{constructor(t,e,n){super(new Uint16Array(t),e,n)}}$h.prototype.isFloat16BufferAttribute=!0;class we extends ye{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Kh=0;const Je=new Wt,Hs=new Qt,yi=new G,Xe=new Ke,Yi=new Ke,Me=new G;class se extends qn{constructor(){super();Object.defineProperty(this,"id",{value:Kh++}),this.uuid=on(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(ua(t)>65535?Ea:Sa)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new Ee().getNormalMatrix(t);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Je.makeRotationFromQuaternion(t),this.applyMatrix4(Je),this}rotateX(t){return Je.makeRotationX(t),this.applyMatrix4(Je),this}rotateY(t){return Je.makeRotationY(t),this.applyMatrix4(Je),this}rotateZ(t){return Je.makeRotationZ(t),this.applyMatrix4(Je),this}translate(t,e,n){return Je.makeTranslation(t,e,n),this.applyMatrix4(Je),this}scale(t,e,n){return Je.makeScale(t,e,n),this.applyMatrix4(Je),this}lookAt(t){return Hs.lookAt(t),Hs.updateMatrix(),this.applyMatrix4(Hs.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(yi).negate(),this.translate(yi.x,yi.y,yi.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new we(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ke);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new G(-1/0,-1/0,-1/0),new G(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const r=e[n];Xe.setFromBufferAttribute(r),this.morphTargetsRelative?(Me.addVectors(this.boundingBox.min,Xe.min),this.boundingBox.expandByPoint(Me),Me.addVectors(this.boundingBox.max,Xe.max),this.boundingBox.expandByPoint(Me)):(this.boundingBox.expandByPoint(Xe.min),this.boundingBox.expandByPoint(Xe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ui);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new G,1/0);return}if(t){const n=this.boundingSphere.center;if(Xe.setFromBufferAttribute(t),e)for(let r=0,s=e.length;r<s;r++){const o=e[r];Yi.setFromBufferAttribute(o),this.morphTargetsRelative?(Me.addVectors(Xe.min,Yi.min),Xe.expandByPoint(Me),Me.addVectors(Xe.max,Yi.max),Xe.expandByPoint(Me)):(Xe.expandByPoint(Yi.min),Xe.expandByPoint(Yi.max))}Xe.getCenter(n);let i=0;for(let r=0,s=t.count;r<s;r++)Me.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(Me));if(e)for(let r=0,s=e.length;r<s;r++){const o=e[r],l=this.morphTargetsRelative;for(let h=0,u=o.count;h<u;h++)Me.fromBufferAttribute(o,h),l&&(yi.fromBufferAttribute(t,h),Me.add(yi)),i=Math.max(i,n.distanceToSquared(Me))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,i=e.position.array,r=e.normal.array,s=e.uv.array,o=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new ye(new Float32Array(4*o),4));const l=e.tangent.array,h=[],u=[];for(let N=0;N<o;N++)h[N]=new G,u[N]=new G;const c=new G,d=new G,p=new G,f=new Tt,g=new Tt,y=new Tt,m=new G,v=new G;function _(N,b,U){c.fromArray(i,N*3),d.fromArray(i,b*3),p.fromArray(i,U*3),f.fromArray(s,N*2),g.fromArray(s,b*2),y.fromArray(s,U*2),d.sub(c),p.sub(c),g.sub(f),y.sub(f);const V=1/(g.x*y.y-y.x*g.y);!isFinite(V)||(m.copy(d).multiplyScalar(y.y).addScaledVector(p,-g.y).multiplyScalar(V),v.copy(p).multiplyScalar(g.x).addScaledVector(d,-y.x).multiplyScalar(V),h[N].add(m),h[b].add(m),h[U].add(m),u[N].add(v),u[b].add(v),u[U].add(v))}let x=this.groups;x.length===0&&(x=[{start:0,count:n.length}]);for(let N=0,b=x.length;N<b;++N){const U=x[N],V=U.start,H=U.count;for(let Y=V,Q=V+H;Y<Q;Y+=3)_(n[Y+0],n[Y+1],n[Y+2])}const w=new G,C=new G,M=new G,D=new G;function j(N){M.fromArray(r,N*3),D.copy(M);const b=h[N];w.copy(b),w.sub(M.multiplyScalar(M.dot(b))).normalize(),C.crossVectors(D,b);const V=C.dot(u[N])<0?-1:1;l[N*4]=w.x,l[N*4+1]=w.y,l[N*4+2]=w.z,l[N*4+3]=V}for(let N=0,b=x.length;N<b;++N){const U=x[N],V=U.start,H=U.count;for(let Y=V,Q=V+H;Y<Q;Y+=3)j(n[Y+0]),j(n[Y+1]),j(n[Y+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new ye(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let d=0,p=n.count;d<p;d++)n.setXYZ(d,0,0,0);const i=new G,r=new G,s=new G,o=new G,l=new G,h=new G,u=new G,c=new G;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),g=t.getX(d+1),y=t.getX(d+2);i.fromBufferAttribute(e,f),r.fromBufferAttribute(e,g),s.fromBufferAttribute(e,y),u.subVectors(s,r),c.subVectors(i,r),u.cross(c),o.fromBufferAttribute(n,f),l.fromBufferAttribute(n,g),h.fromBufferAttribute(n,y),o.add(u),l.add(u),h.add(u),n.setXYZ(f,o.x,o.y,o.z),n.setXYZ(g,l.x,l.y,l.z),n.setXYZ(y,h.x,h.y,h.z)}else for(let d=0,p=e.count;d<p;d+=3)i.fromBufferAttribute(e,d+0),r.fromBufferAttribute(e,d+1),s.fromBufferAttribute(e,d+2),u.subVectors(s,r),c.subVectors(i,r),u.cross(c),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(t.attributes[i]===void 0)continue;const s=n[i].array,o=t.attributes[i],l=o.array,h=o.itemSize*e,u=Math.min(l.length,s.length-h);for(let c=0,d=h;c<u;c++,d++)s[d]=l[c]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Me.fromBufferAttribute(t,e),Me.normalize(),t.setXYZ(e,Me.x,Me.y,Me.z)}toNonIndexed(){function t(o,l){const h=o.array,u=o.itemSize,c=o.normalized,d=new h.constructor(l.length*u);let p=0,f=0;for(let g=0,y=l.length;g<y;g++){o.isInterleavedBufferAttribute?p=l[g]*o.data.stride+o.offset:p=l[g]*u;for(let m=0;m<u;m++)d[f++]=h[p++]}return new ye(d,u,c)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new se,n=this.index.array,i=this.attributes;for(const o in i){const l=i[o],h=t(l,n);e.setAttribute(o,h)}const r=this.morphAttributes;for(const o in r){const l=[],h=r[o];for(let u=0,c=h.length;u<c;u++){const d=h[u],p=t(d,n);l.push(p)}e.morphAttributes[o]=l}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,l=s.length;o<l;o++){const h=s[o];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const h in l)l[h]!==void 0&&(t[h]=l[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const l in n){const h=n[l];t.data.attributes[l]=h.toJSON(t.data)}const i={};let r=!1;for(const l in this.morphAttributes){const h=this.morphAttributes[l],u=[];for(let c=0,d=h.length;c<d;c++){const p=h[c];u.push(p.toJSON(t.data))}u.length>0&&(i[l]=u,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const h in i){const u=i[h];this.setAttribute(h,u.clone(e))}const r=t.morphAttributes;for(const h in r){const u=[],c=r[h];for(let d=0,p=c.length;d<p;d++)u.push(c[d].clone(e));this.morphAttributes[h]=u}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let h=0,u=s.length;h<u;h++){const c=s[h];this.addGroup(c.start,c.count,c.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}se.prototype.isBufferGeometry=!0;const Ta=new Wt,xi=new di,ks=new ui,Ln=new G,Pn=new G,In=new G,qs=new G,Xs=new G,Ys=new G,Pr=new G,Ir=new G,Br=new G,Fr=new Tt,Dr=new Tt,Nr=new Tt,Zs=new G,zr=new G;class Oe extends Qt{constructor(t=new se,e=new Gs){super();this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),ks.copy(n.boundingSphere),ks.applyMatrix4(r),t.ray.intersectsSphere(ks)===!1)||(Ta.copy(r).invert(),xi.copy(t.ray).applyMatrix4(Ta),n.boundingBox!==null&&xi.intersectsBox(n.boundingBox)===!1))return;let s;if(n.isBufferGeometry){const o=n.index,l=n.attributes.position,h=n.morphAttributes.position,u=n.morphTargetsRelative,c=n.attributes.uv,d=n.attributes.uv2,p=n.groups,f=n.drawRange;if(o!==null)if(Array.isArray(i))for(let g=0,y=p.length;g<y;g++){const m=p[g],v=i[m.materialIndex],_=Math.max(m.start,f.start),x=Math.min(o.count,Math.min(m.start+m.count,f.start+f.count));for(let w=_,C=x;w<C;w+=3){const M=o.getX(w),D=o.getX(w+1),j=o.getX(w+2);s=Vr(this,v,t,xi,l,h,u,c,d,M,D,j),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=m.materialIndex,e.push(s))}}else{const g=Math.max(0,f.start),y=Math.min(o.count,f.start+f.count);for(let m=g,v=y;m<v;m+=3){const _=o.getX(m),x=o.getX(m+1),w=o.getX(m+2);s=Vr(this,i,t,xi,l,h,u,c,d,_,x,w),s&&(s.faceIndex=Math.floor(m/3),e.push(s))}}else if(l!==void 0)if(Array.isArray(i))for(let g=0,y=p.length;g<y;g++){const m=p[g],v=i[m.materialIndex],_=Math.max(m.start,f.start),x=Math.min(l.count,Math.min(m.start+m.count,f.start+f.count));for(let w=_,C=x;w<C;w+=3){const M=w,D=w+1,j=w+2;s=Vr(this,v,t,xi,l,h,u,c,d,M,D,j),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=m.materialIndex,e.push(s))}}else{const g=Math.max(0,f.start),y=Math.min(l.count,f.start+f.count);for(let m=g,v=y;m<v;m+=3){const _=m,x=m+1,w=m+2;s=Vr(this,i,t,xi,l,h,u,c,d,_,x,w),s&&(s.faceIndex=Math.floor(m/3),e.push(s))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Oe.prototype.isMesh=!0;function tu(a,t,e,n,i,r,s,o){let l;if(t.side===ge?l=n.intersectTriangle(s,r,i,!0,o):l=n.intersectTriangle(i,r,s,t.side!==$n,o),l===null)return null;zr.copy(o),zr.applyMatrix4(a.matrixWorld);const h=e.ray.origin.distanceTo(zr);return h<e.near||h>e.far?null:{distance:h,point:zr.clone(),object:a}}function Vr(a,t,e,n,i,r,s,o,l,h,u,c){Ln.fromBufferAttribute(i,h),Pn.fromBufferAttribute(i,u),In.fromBufferAttribute(i,c);const d=a.morphTargetInfluences;if(r&&d){Pr.set(0,0,0),Ir.set(0,0,0),Br.set(0,0,0);for(let f=0,g=r.length;f<g;f++){const y=d[f],m=r[f];y!==0&&(qs.fromBufferAttribute(m,h),Xs.fromBufferAttribute(m,u),Ys.fromBufferAttribute(m,c),s?(Pr.addScaledVector(qs,y),Ir.addScaledVector(Xs,y),Br.addScaledVector(Ys,y)):(Pr.addScaledVector(qs.sub(Ln),y),Ir.addScaledVector(Xs.sub(Pn),y),Br.addScaledVector(Ys.sub(In),y)))}Ln.add(Pr),Pn.add(Ir),In.add(Br)}a.isSkinnedMesh&&(a.boneTransform(h,Ln),a.boneTransform(u,Pn),a.boneTransform(c,In));const p=tu(a,t,e,n,Ln,Pn,In,Zs);if(p){o&&(Fr.fromBufferAttribute(o,h),Dr.fromBufferAttribute(o,u),Nr.fromBufferAttribute(o,c),p.uv=ve.getUV(Zs,Ln,Pn,In,Fr,Dr,Nr,new Tt)),l&&(Fr.fromBufferAttribute(l,h),Dr.fromBufferAttribute(l,u),Nr.fromBufferAttribute(l,c),p.uv2=ve.getUV(Zs,Ln,Pn,In,Fr,Dr,Nr,new Tt));const f={a:h,b:u,c,normal:new G,materialIndex:0};ve.getNormal(Ln,Pn,In,f.normal),p.face=f}return p}class Zi extends se{constructor(t=1,e=1,n=1,i=1,r=1,s=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:s};const o=this;i=Math.floor(i),r=Math.floor(r),s=Math.floor(s);const l=[],h=[],u=[],c=[];let d=0,p=0;f("z","y","x",-1,-1,n,e,t,s,r,0),f("z","y","x",1,-1,n,e,-t,s,r,1),f("x","z","y",1,1,t,n,e,i,s,2),f("x","z","y",1,-1,t,n,-e,i,s,3),f("x","y","z",1,-1,t,e,n,i,r,4),f("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(l),this.setAttribute("position",new we(h,3)),this.setAttribute("normal",new we(u,3)),this.setAttribute("uv",new we(c,2));function f(g,y,m,v,_,x,w,C,M,D,j){const N=x/M,b=w/D,U=x/2,V=w/2,H=C/2,Y=M+1,Q=D+1;let P=0,z=0;const it=new G;for(let W=0;W<Q;W++){const T=W*b-V;for(let Z=0;Z<Y;Z++){const A=Z*N-U;it[g]=A*v,it[y]=T*_,it[m]=H,h.push(it.x,it.y,it.z),it[g]=0,it[y]=0,it[m]=C>0?1:-1,u.push(it.x,it.y,it.z),c.push(Z/M),c.push(1-W/D),P+=1}}for(let W=0;W<D;W++)for(let T=0;T<M;T++){const Z=d+T+Y*W,A=d+T+Y*(W+1),I=d+(T+1)+Y*(W+1),R=d+(T+1)+Y*W;l.push(Z,A,R),l.push(A,I,R),z+=6}o.addGroup(p,z,j),p+=z,d+=P}}static fromJSON(t){return new Zi(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function _i(a){const t={};for(const e in a){t[e]={};for(const n in a[e]){const i=a[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function Re(a){const t={};for(let e=0;e<a.length;e++){const n=_i(a[e]);for(const i in n)t[i]=n[i]}return t}const eu={clone:_i,merge:Re};var nu=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,iu=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Zn extends Ce{constructor(t){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=nu,this.fragmentShader=iu,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=_i(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const s=this.uniforms[i].value;s&&s.isTexture?e.uniforms[i]={type:"t",value:s.toJSON(t).uuid}:s&&s.isColor?e.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?e.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?e.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?e.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?e.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?e.uniforms[i]={type:"m4",value:s.toArray()}:e.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}Zn.prototype.isShaderMaterial=!0;class js extends Qt{constructor(){super();this.type="Camera",this.matrixWorldInverse=new Wt,this.projectionMatrix=new Wt,this.projectionMatrixInverse=new Wt}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}js.prototype.isCamera=!0;class Ue extends js{constructor(t=50,e=1,n=.1,i=2e3){super();this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=bs*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Ms*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return bs*2*Math.atan(Math.tan(Ms*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,s){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Ms*.5*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const s=this.view;if(this.view!==null&&this.view.enabled){const l=s.fullWidth,h=s.fullHeight;r+=s.offsetX*i/l,e-=s.offsetY*n/h,i*=s.width/l,n*=s.height/h}const o=this.filmOffset;o!==0&&(r+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Ue.prototype.isPerspectiveCamera=!0;const wi=90,Mi=1;class Js extends Qt{constructor(t,e,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new Ue(wi,Mi,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new G(1,0,0)),this.add(i);const r=new Ue(wi,Mi,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new G(-1,0,0)),this.add(r);const s=new Ue(wi,Mi,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new G(0,1,0)),this.add(s);const o=new Ue(wi,Mi,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new G(0,-1,0)),this.add(o);const l=new Ue(wi,Mi,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new G(0,0,1)),this.add(l);const h=new Ue(wi,Mi,t,e);h.layers=this.layers,h.up.set(0,-1,0),h.lookAt(new G(0,0,-1)),this.add(h)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,r,s,o,l,h]=this.children,u=t.xr.enabled,c=t.getRenderTarget();t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,r),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,o),t.setRenderTarget(n,4),t.render(e,l),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,h),t.setRenderTarget(c),t.xr.enabled=u}}class Or extends Te{constructor(t,e,n,i,r,s,o,l,h,u){t=t!==void 0?t:[],e=e!==void 0?e:Ui;super(t,e,n,i,r,s,o,l,h,u);this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Or.prototype.isCubeTexture=!0;class Aa extends je{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n);super(t,t,e);e=e||{},this.texture=new Or(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Ze,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=Ie,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Zi(5,5,5),r=new Zn({name:"CubemapFromEquirect",uniforms:_i(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ge,blending:bn});r.uniforms.tEquirect.value=e;const s=new Oe(i,r),o=e.minFilter;return e.minFilter===mr&&(e.minFilter=Ze),new Js(1,10,this).update(t,s),e.minFilter=o,s.geometry.dispose(),s.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let s=0;s<6;s++)t.setRenderTarget(this,s),t.clear(e,n,i);t.setRenderTarget(r)}}Aa.prototype.isWebGLCubeRenderTarget=!0;const Qs=new G,ru=new G,su=new Ee;class _n{constructor(t=new G(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Qs.subVectors(n,e).cross(ru.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(Qs),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||su.getNormalMatrix(t),i=this.coplanarPoint(Qs).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}_n.prototype.isPlane=!0;const bi=new ui,Ur=new G;class Wr{constructor(t=new _n,e=new _n,n=new _n,i=new _n,r=new _n,s=new _n){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(i),o[4].copy(r),o[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],o=n[3],l=n[4],h=n[5],u=n[6],c=n[7],d=n[8],p=n[9],f=n[10],g=n[11],y=n[12],m=n[13],v=n[14],_=n[15];return e[0].setComponents(o-i,c-l,g-d,_-y).normalize(),e[1].setComponents(o+i,c+l,g+d,_+y).normalize(),e[2].setComponents(o+r,c+h,g+p,_+m).normalize(),e[3].setComponents(o-r,c-h,g-p,_-m).normalize(),e[4].setComponents(o-s,c-u,g-f,_-v).normalize(),e[5].setComponents(o+s,c+u,g+f,_+v).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),bi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(bi)}intersectsSprite(t){return bi.center.set(0,0,0),bi.radius=.7071067811865476,bi.applyMatrix4(t.matrixWorld),this.intersectsSphere(bi)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Ur.x=i.normal.x>0?t.max.x:t.min.x,Ur.y=i.normal.y>0?t.max.y:t.min.y,Ur.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Ur)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Ca(){let a=null,t=!1,e=null,n=null;function i(r,s){e(r,s),n=a.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=a.requestAnimationFrame(i),t=!0)},stop:function(){a.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){a=r}}}function ou(a,t){const e=t.isWebGL2,n=new WeakMap;function i(h,u){const c=h.array,d=h.usage,p=a.createBuffer();a.bindBuffer(u,p),a.bufferData(u,c,d),h.onUploadCallback();let f=5126;return c instanceof Float32Array?f=5126:c instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):c instanceof Uint16Array?h.isFloat16BufferAttribute?e?f=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):f=5123:c instanceof Int16Array?f=5122:c instanceof Uint32Array?f=5125:c instanceof Int32Array?f=5124:c instanceof Int8Array?f=5120:(c instanceof Uint8Array||c instanceof Uint8ClampedArray)&&(f=5121),{buffer:p,type:f,bytesPerElement:c.BYTES_PER_ELEMENT,version:h.version}}function r(h,u,c){const d=u.array,p=u.updateRange;a.bindBuffer(c,h),p.count===-1?a.bufferSubData(c,0,d):(e?a.bufferSubData(c,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):a.bufferSubData(c,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}function s(h){return h.isInterleavedBufferAttribute&&(h=h.data),n.get(h)}function o(h){h.isInterleavedBufferAttribute&&(h=h.data);const u=n.get(h);u&&(a.deleteBuffer(u.buffer),n.delete(h))}function l(h,u){if(h.isGLBufferAttribute){const d=n.get(h);(!d||d.version<h.version)&&n.set(h,{buffer:h.buffer,type:h.type,bytesPerElement:h.elementSize,version:h.version});return}h.isInterleavedBufferAttribute&&(h=h.data);const c=n.get(h);c===void 0?n.set(h,i(h,u)):c.version<h.version&&(r(c.buffer,h,u),c.version=h.version)}return{get:s,remove:o,update:l}}class $s extends se{constructor(t=1,e=1,n=1,i=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,s=e/2,o=Math.floor(n),l=Math.floor(i),h=o+1,u=l+1,c=t/o,d=e/l,p=[],f=[],g=[],y=[];for(let m=0;m<u;m++){const v=m*d-s;for(let _=0;_<h;_++){const x=_*c-r;f.push(x,-v,0),g.push(0,0,1),y.push(_/o),y.push(1-m/l)}}for(let m=0;m<l;m++)for(let v=0;v<o;v++){const _=v+h*m,x=v+h*(m+1),w=v+1+h*(m+1),C=v+1+h*m;p.push(_,x,C),p.push(x,w,C)}this.setIndex(p),this.setAttribute("position",new we(f,3)),this.setAttribute("normal",new we(g,3)),this.setAttribute("uv",new we(y,2))}static fromJSON(t){return new $s(t.width,t.height,t.widthSegments,t.heightSegments)}}var au=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,lu=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,cu=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,hu=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,uu=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,du=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,pu="vec3 transformed = vec3( position );",fu=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,mu=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,vu=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,gu=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,yu=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,xu=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,_u=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,wu=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Mu=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,bu=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Su=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Eu=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Tu=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Au=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Cu=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Ru=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Lu=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Pu=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Iu="gl_FragColor = linearToOutputTexel( gl_FragColor );",Bu=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}`,Fu=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Du=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Nu=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,zu=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Vu=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Ou=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,Uu=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Wu=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Gu=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Hu=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,ku=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,qu=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Xu=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Yu=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Zu=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,ju=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Ju=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Qu=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,$u=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,Ku=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,td=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,ed=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,nd=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,id=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,rd=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,sd=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,od=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,ad=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,ld=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,cd=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,hd=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,ud=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,dd=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,pd=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,fd=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,md=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,vd=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,gd=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,yd=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,xd=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,_d=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,wd=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Md=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,bd=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Sd=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,Ed=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Td=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Ad=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Cd=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Rd=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Ld=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Pd=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Id=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Bd=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Fd=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Dd=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Nd=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,zd=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Vd=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Od=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Ud=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Wd=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Gd=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Hd=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,kd=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,qd=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Xd=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,Yd=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Zd=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,jd=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Jd=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Qd=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,$d=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Kd=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,tp=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const ep=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,np=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ip=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,rp=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,sp=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,op=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,ap=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,lp=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,cp=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,hp=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,up=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,dp=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,pp=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fp=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,mp=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,vp=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,gp=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,yp=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xp=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,_p=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,wp=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Mp=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bp=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Sp=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ep=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Tp=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ap=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Cp=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Rp=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Lp=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Pp=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Ip=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Zt={alphamap_fragment:au,alphamap_pars_fragment:lu,alphatest_fragment:cu,alphatest_pars_fragment:hu,aomap_fragment:uu,aomap_pars_fragment:du,begin_vertex:pu,beginnormal_vertex:fu,bsdfs:mu,bumpmap_pars_fragment:vu,clipping_planes_fragment:gu,clipping_planes_pars_fragment:yu,clipping_planes_pars_vertex:xu,clipping_planes_vertex:_u,color_fragment:wu,color_pars_fragment:Mu,color_pars_vertex:bu,color_vertex:Su,common:Eu,cube_uv_reflection_fragment:Tu,defaultnormal_vertex:Au,displacementmap_pars_vertex:Cu,displacementmap_vertex:Ru,emissivemap_fragment:Lu,emissivemap_pars_fragment:Pu,encodings_fragment:Iu,encodings_pars_fragment:Bu,envmap_fragment:Fu,envmap_common_pars_fragment:Du,envmap_pars_fragment:Nu,envmap_pars_vertex:zu,envmap_physical_pars_fragment:Zu,envmap_vertex:Vu,fog_vertex:Ou,fog_pars_vertex:Uu,fog_fragment:Wu,fog_pars_fragment:Gu,gradientmap_pars_fragment:Hu,lightmap_fragment:ku,lightmap_pars_fragment:qu,lights_lambert_vertex:Xu,lights_pars_begin:Yu,lights_toon_fragment:ju,lights_toon_pars_fragment:Ju,lights_phong_fragment:Qu,lights_phong_pars_fragment:$u,lights_physical_fragment:Ku,lights_physical_pars_fragment:td,lights_fragment_begin:ed,lights_fragment_maps:nd,lights_fragment_end:id,logdepthbuf_fragment:rd,logdepthbuf_pars_fragment:sd,logdepthbuf_pars_vertex:od,logdepthbuf_vertex:ad,map_fragment:ld,map_pars_fragment:cd,map_particle_fragment:hd,map_particle_pars_fragment:ud,metalnessmap_fragment:dd,metalnessmap_pars_fragment:pd,morphnormal_vertex:fd,morphtarget_pars_vertex:md,morphtarget_vertex:vd,normal_fragment_begin:gd,normal_fragment_maps:yd,normal_pars_fragment:xd,normal_pars_vertex:_d,normal_vertex:wd,normalmap_pars_fragment:Md,clearcoat_normal_fragment_begin:bd,clearcoat_normal_fragment_maps:Sd,clearcoat_pars_fragment:Ed,output_fragment:Td,packing:Ad,premultiplied_alpha_fragment:Cd,project_vertex:Rd,dithering_fragment:Ld,dithering_pars_fragment:Pd,roughnessmap_fragment:Id,roughnessmap_pars_fragment:Bd,shadowmap_pars_fragment:Fd,shadowmap_pars_vertex:Dd,shadowmap_vertex:Nd,shadowmask_pars_fragment:zd,skinbase_vertex:Vd,skinning_pars_vertex:Od,skinning_vertex:Ud,skinnormal_vertex:Wd,specularmap_fragment:Gd,specularmap_pars_fragment:Hd,tonemapping_fragment:kd,tonemapping_pars_fragment:qd,transmission_fragment:Xd,transmission_pars_fragment:Yd,uv_pars_fragment:Zd,uv_pars_vertex:jd,uv_vertex:Jd,uv2_pars_fragment:Qd,uv2_pars_vertex:$d,uv2_vertex:Kd,worldpos_vertex:tp,background_vert:ep,background_frag:np,cube_vert:ip,cube_frag:rp,depth_vert:sp,depth_frag:op,distanceRGBA_vert:ap,distanceRGBA_frag:lp,equirect_vert:cp,equirect_frag:hp,linedashed_vert:up,linedashed_frag:dp,meshbasic_vert:pp,meshbasic_frag:fp,meshlambert_vert:mp,meshlambert_frag:vp,meshmatcap_vert:gp,meshmatcap_frag:yp,meshnormal_vert:xp,meshnormal_frag:_p,meshphong_vert:wp,meshphong_frag:Mp,meshphysical_vert:bp,meshphysical_frag:Sp,meshtoon_vert:Ep,meshtoon_frag:Tp,points_vert:Ap,points_frag:Cp,shadow_vert:Rp,shadow_frag:Lp,sprite_vert:Pp,sprite_frag:Ip},It={common:{diffuse:{value:new Ot(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ee},uv2Transform:{value:new Ee},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Tt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ot(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ot(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ee}},sprite:{diffuse:{value:new Ot(16777215)},opacity:{value:1},center:{value:new Tt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ee}}},an={basic:{uniforms:Re([It.common,It.specularmap,It.envmap,It.aomap,It.lightmap,It.fog]),vertexShader:Zt.meshbasic_vert,fragmentShader:Zt.meshbasic_frag},lambert:{uniforms:Re([It.common,It.specularmap,It.envmap,It.aomap,It.lightmap,It.emissivemap,It.fog,It.lights,{emissive:{value:new Ot(0)}}]),vertexShader:Zt.meshlambert_vert,fragmentShader:Zt.meshlambert_frag},phong:{uniforms:Re([It.common,It.specularmap,It.envmap,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.fog,It.lights,{emissive:{value:new Ot(0)},specular:{value:new Ot(1118481)},shininess:{value:30}}]),vertexShader:Zt.meshphong_vert,fragmentShader:Zt.meshphong_frag},standard:{uniforms:Re([It.common,It.envmap,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.roughnessmap,It.metalnessmap,It.fog,It.lights,{emissive:{value:new Ot(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Zt.meshphysical_vert,fragmentShader:Zt.meshphysical_frag},toon:{uniforms:Re([It.common,It.aomap,It.lightmap,It.emissivemap,It.bumpmap,It.normalmap,It.displacementmap,It.gradientmap,It.fog,It.lights,{emissive:{value:new Ot(0)}}]),vertexShader:Zt.meshtoon_vert,fragmentShader:Zt.meshtoon_frag},matcap:{uniforms:Re([It.common,It.bumpmap,It.normalmap,It.displacementmap,It.fog,{matcap:{value:null}}]),vertexShader:Zt.meshmatcap_vert,fragmentShader:Zt.meshmatcap_frag},points:{uniforms:Re([It.points,It.fog]),vertexShader:Zt.points_vert,fragmentShader:Zt.points_frag},dashed:{uniforms:Re([It.common,It.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Zt.linedashed_vert,fragmentShader:Zt.linedashed_frag},depth:{uniforms:Re([It.common,It.displacementmap]),vertexShader:Zt.depth_vert,fragmentShader:Zt.depth_frag},normal:{uniforms:Re([It.common,It.bumpmap,It.normalmap,It.displacementmap,{opacity:{value:1}}]),vertexShader:Zt.meshnormal_vert,fragmentShader:Zt.meshnormal_frag},sprite:{uniforms:Re([It.sprite,It.fog]),vertexShader:Zt.sprite_vert,fragmentShader:Zt.sprite_frag},background:{uniforms:{uvTransform:{value:new Ee},t2D:{value:null}},vertexShader:Zt.background_vert,fragmentShader:Zt.background_frag},cube:{uniforms:Re([It.envmap,{opacity:{value:1}}]),vertexShader:Zt.cube_vert,fragmentShader:Zt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Zt.equirect_vert,fragmentShader:Zt.equirect_frag},distanceRGBA:{uniforms:Re([It.common,It.displacementmap,{referencePosition:{value:new G},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Zt.distanceRGBA_vert,fragmentShader:Zt.distanceRGBA_frag},shadow:{uniforms:Re([It.lights,It.fog,{color:{value:new Ot(0)},opacity:{value:1}}]),vertexShader:Zt.shadow_vert,fragmentShader:Zt.shadow_frag}};an.physical={uniforms:Re([an.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Tt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Ot(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Tt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Ot(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Ot(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Zt.meshphysical_vert,fragmentShader:Zt.meshphysical_frag};function Bp(a,t,e,n,i){const r=new Ot(0);let s=0,o,l,h=null,u=0,c=null;function d(f,g){let y=!1,m=g.isScene===!0?g.background:null;m&&m.isTexture&&(m=t.get(m));const v=a.xr,_=v.getSession&&v.getSession();_&&_.environmentBlendMode==="additive"&&(m=null),m===null?p(r,s):m&&m.isColor&&(p(m,1),y=!0),(a.autoClear||y)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),m&&(m.isCubeTexture||m.mapping===fr)?(l===void 0&&(l=new Oe(new Zi(1,1,1),new Zn({name:"BackgroundCubeMaterial",uniforms:_i(an.cube.uniforms),vertexShader:an.cube.vertexShader,fragmentShader:an.cube.fragmentShader,side:ge,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(x,w,C){this.matrixWorld.copyPosition(C.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(l)),l.material.uniforms.envMap.value=m,l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m.isRenderTargetTexture===!1?-1:1,(h!==m||u!==m.version||c!==a.toneMapping)&&(l.material.needsUpdate=!0,h=m,u=m.version,c=a.toneMapping),f.unshift(l,l.geometry,l.material,0,0,null)):m&&m.isTexture&&(o===void 0&&(o=new Oe(new $s(2,2),new Zn({name:"BackgroundMaterial",uniforms:_i(an.background.uniforms),vertexShader:an.background.vertexShader,fragmentShader:an.background.fragmentShader,side:Vi,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=m,m.matrixAutoUpdate===!0&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),(h!==m||u!==m.version||c!==a.toneMapping)&&(o.material.needsUpdate=!0,h=m,u=m.version,c=a.toneMapping),f.unshift(o,o.geometry,o.material,0,0,null))}function p(f,g){e.buffers.color.setClear(f.r,f.g,f.b,g,i)}return{getClearColor:function(){return r},setClearColor:function(f,g=1){r.set(f),s=g,p(r,s)},getClearAlpha:function(){return s},setClearAlpha:function(f){s=f,p(r,s)},render:d}}function Fp(a,t,e,n){const i=a.getParameter(34921),r=n.isWebGL2?null:t.get("OES_vertex_array_object"),s=n.isWebGL2||r!==null,o={},l=g(null);let h=l;function u(V,H,Y,Q,P){let z=!1;if(s){const it=f(Q,Y,H);h!==it&&(h=it,d(h.object)),z=y(Q,P),z&&m(Q,P)}else{const it=H.wireframe===!0;(h.geometry!==Q.id||h.program!==Y.id||h.wireframe!==it)&&(h.geometry=Q.id,h.program=Y.id,h.wireframe=it,z=!0)}V.isInstancedMesh===!0&&(z=!0),P!==null&&e.update(P,34963),z&&(M(V,H,Y,Q),P!==null&&a.bindBuffer(34963,e.get(P).buffer))}function c(){return n.isWebGL2?a.createVertexArray():r.createVertexArrayOES()}function d(V){return n.isWebGL2?a.bindVertexArray(V):r.bindVertexArrayOES(V)}function p(V){return n.isWebGL2?a.deleteVertexArray(V):r.deleteVertexArrayOES(V)}function f(V,H,Y){const Q=Y.wireframe===!0;let P=o[V.id];P===void 0&&(P={},o[V.id]=P);let z=P[H.id];z===void 0&&(z={},P[H.id]=z);let it=z[Q];return it===void 0&&(it=g(c()),z[Q]=it),it}function g(V){const H=[],Y=[],Q=[];for(let P=0;P<i;P++)H[P]=0,Y[P]=0,Q[P]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:H,enabledAttributes:Y,attributeDivisors:Q,object:V,attributes:{},index:null}}function y(V,H){const Y=h.attributes,Q=V.attributes;let P=0;for(const z in Q){const it=Y[z],W=Q[z];if(it===void 0||it.attribute!==W||it.data!==W.data)return!0;P++}return h.attributesNum!==P||h.index!==H}function m(V,H){const Y={},Q=V.attributes;let P=0;for(const z in Q){const it=Q[z],W={};W.attribute=it,it.data&&(W.data=it.data),Y[z]=W,P++}h.attributes=Y,h.attributesNum=P,h.index=H}function v(){const V=h.newAttributes;for(let H=0,Y=V.length;H<Y;H++)V[H]=0}function _(V){x(V,0)}function x(V,H){const Y=h.newAttributes,Q=h.enabledAttributes,P=h.attributeDivisors;Y[V]=1,Q[V]===0&&(a.enableVertexAttribArray(V),Q[V]=1),P[V]!==H&&((n.isWebGL2?a:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](V,H),P[V]=H)}function w(){const V=h.newAttributes,H=h.enabledAttributes;for(let Y=0,Q=H.length;Y<Q;Y++)H[Y]!==V[Y]&&(a.disableVertexAttribArray(Y),H[Y]=0)}function C(V,H,Y,Q,P,z){n.isWebGL2===!0&&(Y===5124||Y===5125)?a.vertexAttribIPointer(V,H,Y,P,z):a.vertexAttribPointer(V,H,Y,Q,P,z)}function M(V,H,Y,Q){if(n.isWebGL2===!1&&(V.isInstancedMesh||Q.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;v();const P=Q.attributes,z=Y.getAttributes(),it=H.defaultAttributeValues;for(const W in z){const T=z[W];if(T.location>=0){let Z=P[W];if(Z===void 0&&(W==="instanceMatrix"&&V.instanceMatrix&&(Z=V.instanceMatrix),W==="instanceColor"&&V.instanceColor&&(Z=V.instanceColor)),Z!==void 0){const A=Z.normalized,I=Z.itemSize,R=e.get(Z);if(R===void 0)continue;const F=R.buffer,ot=R.type,et=R.bytesPerElement;if(Z.isInterleavedBufferAttribute){const k=Z.data,nt=k.stride,lt=Z.offset;if(k&&k.isInstancedInterleavedBuffer){for(let $=0;$<T.locationSize;$++)x(T.location+$,k.meshPerAttribute);V.isInstancedMesh!==!0&&Q._maxInstanceCount===void 0&&(Q._maxInstanceCount=k.meshPerAttribute*k.count)}else for(let $=0;$<T.locationSize;$++)_(T.location+$);a.bindBuffer(34962,F);for(let $=0;$<T.locationSize;$++)C(T.location+$,I/T.locationSize,ot,A,nt*et,(lt+I/T.locationSize*$)*et)}else{if(Z.isInstancedBufferAttribute){for(let k=0;k<T.locationSize;k++)x(T.location+k,Z.meshPerAttribute);V.isInstancedMesh!==!0&&Q._maxInstanceCount===void 0&&(Q._maxInstanceCount=Z.meshPerAttribute*Z.count)}else for(let k=0;k<T.locationSize;k++)_(T.location+k);a.bindBuffer(34962,F);for(let k=0;k<T.locationSize;k++)C(T.location+k,I/T.locationSize,ot,A,I*et,I/T.locationSize*k*et)}}else if(it!==void 0){const A=it[W];if(A!==void 0)switch(A.length){case 2:a.vertexAttrib2fv(T.location,A);break;case 3:a.vertexAttrib3fv(T.location,A);break;case 4:a.vertexAttrib4fv(T.location,A);break;default:a.vertexAttrib1fv(T.location,A)}}}}w()}function D(){b();for(const V in o){const H=o[V];for(const Y in H){const Q=H[Y];for(const P in Q)p(Q[P].object),delete Q[P];delete H[Y]}delete o[V]}}function j(V){if(o[V.id]===void 0)return;const H=o[V.id];for(const Y in H){const Q=H[Y];for(const P in Q)p(Q[P].object),delete Q[P];delete H[Y]}delete o[V.id]}function N(V){for(const H in o){const Y=o[H];if(Y[V.id]===void 0)continue;const Q=Y[V.id];for(const P in Q)p(Q[P].object),delete Q[P];delete Y[V.id]}}function b(){U(),h!==l&&(h=l,d(h.object))}function U(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:b,resetDefaultState:U,dispose:D,releaseStatesOfGeometry:j,releaseStatesOfProgram:N,initAttributes:v,enableAttribute:_,disableUnusedAttributes:w}}function Dp(a,t,e,n){const i=n.isWebGL2;let r;function s(h){r=h}function o(h,u){a.drawArrays(r,h,u),e.update(u,r,1)}function l(h,u,c){if(c===0)return;let d,p;if(i)d=a,p="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](r,h,u,c),e.update(u,r,c)}this.setMode=s,this.render=o,this.renderInstances=l}function Np(a,t,e){let n;function i(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const M=t.get("EXT_texture_filter_anisotropic");n=a.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function r(M){if(M==="highp"){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";M="mediump"}return M==="mediump"&&a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s=typeof WebGL2RenderingContext!="undefined"&&a instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&a instanceof WebGL2ComputeRenderingContext;let o=e.precision!==void 0?e.precision:"highp";const l=r(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const h=s||t.has("WEBGL_draw_buffers"),u=e.logarithmicDepthBuffer===!0,c=a.getParameter(34930),d=a.getParameter(35660),p=a.getParameter(3379),f=a.getParameter(34076),g=a.getParameter(34921),y=a.getParameter(36347),m=a.getParameter(36348),v=a.getParameter(36349),_=d>0,x=s||t.has("OES_texture_float"),w=_&&x,C=s?a.getParameter(36183):0;return{isWebGL2:s,drawBuffers:h,getMaxAnisotropy:i,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:u,maxTextures:c,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:f,maxAttributes:g,maxVertexUniforms:y,maxVaryings:m,maxFragmentUniforms:v,vertexTextures:_,floatFragmentTextures:x,floatVertexTextures:w,maxSamples:C}}function zp(a){const t=this;let e=null,n=0,i=!1,r=!1;const s=new _n,o=new Ee,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(c,d,p){const f=c.length!==0||d||n!==0||i;return i=d,e=u(c,p,0),n=c.length,f},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1,h()},this.setState=function(c,d,p){const f=c.clippingPlanes,g=c.clipIntersection,y=c.clipShadows,m=a.get(c);if(!i||f===null||f.length===0||r&&!y)r?u(null):h();else{const v=r?0:n,_=v*4;let x=m.clippingState||null;l.value=x,x=u(f,d,_,p);for(let w=0;w!==_;++w)x[w]=e[w];m.clippingState=x,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=v}};function h(){l.value!==e&&(l.value=e,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function u(c,d,p,f){const g=c!==null?c.length:0;let y=null;if(g!==0){if(y=l.value,f!==!0||y===null){const m=p+g*4,v=d.matrixWorldInverse;o.getNormalMatrix(v),(y===null||y.length<m)&&(y=new Float32Array(m));for(let _=0,x=p;_!==g;++_,x+=4)s.copy(c[_]).applyMatrix4(v,o),s.normal.toArray(y,x),y[x+3]=s.constant}l.value=y,l.needsUpdate=!0}return t.numPlanes=g,t.numIntersection=0,y}}function Vp(a){let t=new WeakMap;function e(s,o){return o===ds?s.mapping=Ui:o===ps&&(s.mapping=Wi),s}function n(s){if(s&&s.isTexture&&s.isRenderTargetTexture===!1){const o=s.mapping;if(o===ds||o===ps)if(t.has(s)){const l=t.get(s).texture;return e(l,s.mapping)}else{const l=s.image;if(l&&l.height>0){const h=a.getRenderTarget(),u=new Aa(l.height/2);return u.fromEquirectangularTexture(a,s),t.set(s,u),a.setRenderTarget(h),s.addEventListener("dispose",i),e(u.texture,s.mapping)}else return null}}return s}function i(s){const o=s.target;o.removeEventListener("dispose",i);const l=t.get(o);l!==void 0&&(t.delete(o),l.dispose())}function r(){t=new WeakMap}return{get:n,dispose:r}}class Ks extends js{constructor(t=-1,e=1,n=1,i=-1,r=.1,s=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,s){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,s=n+t,o=i+e,l=i-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=h*this.view.offsetX,s=r+h*this.view.width,o-=u*this.view.offsetY,l=o-u*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Ks.prototype.isOrthographicCamera=!0;class Gr extends Zn{constructor(t){super(t);this.type="RawShaderMaterial"}}Gr.prototype.isRawShaderMaterial=!0;const Si=4,Bn=8,ln=Math.pow(2,Bn),Ra=[.125,.215,.35,.446,.526,.582],La=Bn-Si+1+Ra.length,Ei=20,jn={[ze]:0,[_r]:1,[_s]:2,[oa]:3,[aa]:4,[la]:5,[xs]:6},to=new Ks,{_lodPlanes:ji,_sizeLods:Pa,_sigmas:Hr}=Wp(),Ia=new Ot;let eo=null;const Jn=(1+Math.sqrt(5))/2,Ti=1/Jn,Ba=[new G(1,1,1),new G(-1,1,1),new G(1,1,-1),new G(-1,1,-1),new G(0,Jn,Ti),new G(0,Jn,-Ti),new G(Ti,0,Jn),new G(-Ti,0,Jn),new G(Jn,Ti,0),new G(-Jn,Ti,0)];class Op{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=Gp(Ei),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){eo=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Na(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Da(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<ji.length;t++)ji[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(eo),t.scissorTest=!1,kr(t,0,0,t.width,t.height)}_fromTexture(t){eo=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:_e,minFilter:_e,generateMipmaps:!1,type:Sn,format:Zc,encoding:Up(t)?t.encoding:_s,depthBuffer:!1},n=Fa(e);return n.depthBuffer=!t,this._pingPongRenderTarget=Fa(e),n}_compileMaterial(t){const e=new Oe(ji[0],t);this._renderer.compile(e,to)}_sceneToCubeUV(t,e,n,i){const r=90,s=1,o=new Ue(r,s,e,n),l=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],u=this._renderer,c=u.autoClear,d=u.outputEncoding,p=u.toneMapping;u.getClearColor(Ia),u.toneMapping=Gn,u.outputEncoding=ze,u.autoClear=!1;const f=new Gs({name:"PMREM.Background",side:ge,depthWrite:!1,depthTest:!1}),g=new Oe(new Zi,f);let y=!1;const m=t.background;m?m.isColor&&(f.color.copy(m),t.background=null,y=!0):(f.color.copy(Ia),y=!0);for(let v=0;v<6;v++){const _=v%3;_==0?(o.up.set(0,l[v],0),o.lookAt(h[v],0,0)):_==1?(o.up.set(0,0,l[v]),o.lookAt(0,h[v],0)):(o.up.set(0,l[v],0),o.lookAt(0,0,h[v])),kr(i,_*ln,v>2?ln:0,ln,ln),u.setRenderTarget(i),y&&u.render(g,o),u.render(t,o)}g.geometry.dispose(),g.material.dispose(),u.toneMapping=p,u.outputEncoding=d,u.autoClear=c,t.background=m}_setEncoding(t,e){t.value=jn[e.encoding]}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===Ui||t.mapping===Wi;i?this._cubemapShader==null&&(this._cubemapShader=Na()):this._equirectShader==null&&(this._equirectShader=Da());const r=i?this._cubemapShader:this._equirectShader,s=new Oe(ji[0],r),o=r.uniforms;o.envMap.value=t,i||o.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(o.inputEncoding,t),this._setEncoding(o.outputEncoding,e.texture),kr(e,0,0,3*ln,2*ln),n.setRenderTarget(e),n.render(s,to)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let i=1;i<La;i++){const r=Math.sqrt(Hr[i]*Hr[i]-Hr[i-1]*Hr[i-1]),s=Ba[(i-1)%Ba.length];this._blur(t,i-1,i,r,s)}e.autoClear=n}_blur(t,e,n,i,r){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,i,"latitudinal",r),this._halfBlur(s,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,s,o){const l=this._renderer,h=this._blurMaterial;s!=="latitudinal"&&s!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,c=new Oe(ji[i],h),d=h.uniforms,p=Pa[n]-1,f=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*Ei-1),g=r/f,y=isFinite(r)?1+Math.floor(u*g):Ei;y>Ei&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Ei}`);const m=[];let v=0;for(let C=0;C<Ei;++C){const M=C/g,D=Math.exp(-M*M/2);m.push(D),C==0?v+=D:C<y&&(v+=2*D)}for(let C=0;C<m.length;C++)m[C]=m[C]/v;d.envMap.value=t.texture,d.samples.value=y,d.weights.value=m,d.latitudinal.value=s==="latitudinal",o&&(d.poleAxis.value=o),d.dTheta.value=f,d.mipInt.value=Bn-n,this._setEncoding(d.inputEncoding,t.texture),this._setEncoding(d.outputEncoding,t.texture);const _=Pa[i],x=3*Math.max(0,ln-2*_),w=(i===0?0:2*ln)+2*_*(i>Bn-Si?i-Bn+Si:0);kr(e,x,w,3*_,2*_),l.setRenderTarget(e),l.render(c,to)}}function Up(a){return a===void 0||a.type!==Sn?!1:a.encoding===ze||a.encoding===_r||a.encoding===xs}function Wp(){const a=[],t=[],e=[];let n=Bn;for(let i=0;i<La;i++){const r=Math.pow(2,n);t.push(r);let s=1/r;i>Bn-Si?s=Ra[i-Bn+Si-1]:i==0&&(s=0),e.push(s);const o=1/(r-1),l=-o/2,h=1+o/2,u=[l,l,h,l,h,h,l,l,h,h,l,h],c=6,d=6,p=3,f=2,g=1,y=new Float32Array(p*d*c),m=new Float32Array(f*d*c),v=new Float32Array(g*d*c);for(let x=0;x<c;x++){const w=x%3*2/3-1,C=x>2?0:-1,M=[w,C,0,w+2/3,C,0,w+2/3,C+1,0,w,C,0,w+2/3,C+1,0,w,C+1,0];y.set(M,p*d*x),m.set(u,f*d*x);const D=[x,x,x,x,x,x];v.set(D,g*d*x)}const _=new se;_.setAttribute("position",new ye(y,p)),_.setAttribute("uv",new ye(m,f)),_.setAttribute("faceIndex",new ye(v,g)),a.push(_),n>Si&&n--}return{_lodPlanes:a,_sizeLods:t,_sigmas:e}}function Fa(a){const t=new je(3*ln,3*ln,a);return t.texture.mapping=fr,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function kr(a,t,e,n,i){a.viewport.set(t,e,n,i),a.scissor.set(t,e,n,i)}function Gp(a){const t=new Float32Array(a),e=new G(0,1,0);return new Gr({name:"SphericalGaussianBlur",defines:{n:a},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e},inputEncoding:{value:jn[ze]},outputEncoding:{value:jn[ze]}},vertexShader:no(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${io()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:bn,depthTest:!1,depthWrite:!1})}function Da(){const a=new Tt(1,1);return new Gr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:a},inputEncoding:{value:jn[ze]},outputEncoding:{value:jn[ze]}},vertexShader:no(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${io()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:bn,depthTest:!1,depthWrite:!1})}function Na(){return new Gr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:jn[ze]},outputEncoding:{value:jn[ze]}},vertexShader:no(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${io()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:bn,depthTest:!1,depthWrite:!1})}function no(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function io(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Hp(a){let t=new WeakMap,e=null;function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const l=o.mapping,h=l===ds||l===ps,u=l===Ui||l===Wi;if(h||u){if(t.has(o))return t.get(o).texture;{const c=o.image;if(h&&c&&c.height>0||u&&c&&i(c)){const d=a.getRenderTarget();e===null&&(e=new Op(a));const p=h?e.fromEquirectangular(o):e.fromCubemap(o);return t.set(o,p),a.setRenderTarget(d),o.addEventListener("dispose",r),p.texture}else return null}}}return o}function i(o){let l=0;const h=6;for(let u=0;u<h;u++)o[u]!==void 0&&l++;return l===h}function r(o){const l=o.target;l.removeEventListener("dispose",r);const h=t.get(l);h!==void 0&&(t.delete(l),h.dispose())}function s(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:s}}function kp(a){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=a.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function qp(a,t,e,n){const i={},r=new WeakMap;function s(c){const d=c.target;d.index!==null&&t.remove(d.index);for(const f in d.attributes)t.remove(d.attributes[f]);d.removeEventListener("dispose",s),delete i[d.id];const p=r.get(d);p&&(t.remove(p),r.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function o(c,d){return i[d.id]===!0||(d.addEventListener("dispose",s),i[d.id]=!0,e.memory.geometries++),d}function l(c){const d=c.attributes;for(const f in d)t.update(d[f],34962);const p=c.morphAttributes;for(const f in p){const g=p[f];for(let y=0,m=g.length;y<m;y++)t.update(g[y],34962)}}function h(c){const d=[],p=c.index,f=c.attributes.position;let g=0;if(p!==null){const v=p.array;g=p.version;for(let _=0,x=v.length;_<x;_+=3){const w=v[_+0],C=v[_+1],M=v[_+2];d.push(w,C,C,M,M,w)}}else{const v=f.array;g=f.version;for(let _=0,x=v.length/3-1;_<x;_+=3){const w=_+0,C=_+1,M=_+2;d.push(w,C,C,M,M,w)}}const y=new(ua(d)>65535?Ea:Sa)(d,1);y.version=g;const m=r.get(c);m&&t.remove(m),r.set(c,y)}function u(c){const d=r.get(c);if(d){const p=c.index;p!==null&&d.version<p.version&&h(c)}else h(c);return r.get(c)}return{get:o,update:l,getWireframeAttribute:u}}function Xp(a,t,e,n){const i=n.isWebGL2;let r;function s(d){r=d}let o,l;function h(d){o=d.type,l=d.bytesPerElement}function u(d,p){a.drawElements(r,p,o,d*l),e.update(p,r,1)}function c(d,p,f){if(f===0)return;let g,y;if(i)g=a,y="drawElementsInstanced";else if(g=t.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",g===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[y](r,p,o,d*l,f),e.update(p,r,f)}this.setMode=s,this.setIndex=h,this.render=u,this.renderInstances=c}function Yp(a){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,s,o){switch(e.calls++,s){case 4:e.triangles+=o*(r/3);break;case 1:e.lines+=o*(r/2);break;case 3:e.lines+=o*(r-1);break;case 2:e.lines+=o*r;break;case 0:e.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",s);break}}function i(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:i,update:n}}class ro extends Te{constructor(t=null,e=1,n=1,i=1){super(null);this.image={data:t,width:e,height:n,depth:i},this.magFilter=_e,this.minFilter=_e,this.wrapR=He,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}ro.prototype.isDataTexture2DArray=!0;function Zp(a,t){return a[0]-t[0]}function jp(a,t){return Math.abs(t[1])-Math.abs(a[1])}function za(a,t){let e=1;const n=t.isInterleavedBufferAttribute?t.data.array:t.array;n instanceof Int8Array?e=127:n instanceof Int16Array?e=32767:n instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),a.divideScalar(e)}function Jp(a,t,e){const n={},i=new Float32Array(8),r=new WeakMap,s=new G,o=[];for(let h=0;h<8;h++)o[h]=[h,0];function l(h,u,c,d){const p=h.morphTargetInfluences;if(t.isWebGL2===!0){const f=u.morphAttributes.position.length;let g=r.get(u);if(g===void 0||g.count!==f){g!==void 0&&g.texture.dispose();const v=u.morphAttributes.normal!==void 0,_=u.morphAttributes.position,x=u.morphAttributes.normal||[],w=u.attributes.position.count,C=v===!0?2:1;let M=w*C,D=1;M>t.maxTextureSize&&(D=Math.ceil(M/t.maxTextureSize),M=t.maxTextureSize);const j=new Float32Array(M*D*4*f),N=new ro(j,M,D,f);N.format=Ie,N.type=En;const b=C*4;for(let U=0;U<f;U++){const V=_[U],H=x[U],Y=M*D*4*U;for(let Q=0;Q<V.count;Q++){s.fromBufferAttribute(V,Q),V.normalized===!0&&za(s,V);const P=Q*b;j[Y+P+0]=s.x,j[Y+P+1]=s.y,j[Y+P+2]=s.z,j[Y+P+3]=0,v===!0&&(s.fromBufferAttribute(H,Q),H.normalized===!0&&za(s,H),j[Y+P+4]=s.x,j[Y+P+5]=s.y,j[Y+P+6]=s.z,j[Y+P+7]=0)}}g={count:f,texture:N,size:new Tt(M,D)},r.set(u,g)}let y=0;for(let v=0;v<p.length;v++)y+=p[v];const m=u.morphTargetsRelative?1:1-y;d.getUniforms().setValue(a,"morphTargetBaseInfluence",m),d.getUniforms().setValue(a,"morphTargetInfluences",p),d.getUniforms().setValue(a,"morphTargetsTexture",g.texture,e),d.getUniforms().setValue(a,"morphTargetsTextureSize",g.size)}else{const f=p===void 0?0:p.length;let g=n[u.id];if(g===void 0||g.length!==f){g=[];for(let x=0;x<f;x++)g[x]=[x,0];n[u.id]=g}for(let x=0;x<f;x++){const w=g[x];w[0]=x,w[1]=p[x]}g.sort(jp);for(let x=0;x<8;x++)x<f&&g[x][1]?(o[x][0]=g[x][0],o[x][1]=g[x][1]):(o[x][0]=Number.MAX_SAFE_INTEGER,o[x][1]=0);o.sort(Zp);const y=u.morphAttributes.position,m=u.morphAttributes.normal;let v=0;for(let x=0;x<8;x++){const w=o[x],C=w[0],M=w[1];C!==Number.MAX_SAFE_INTEGER&&M?(y&&u.getAttribute("morphTarget"+x)!==y[C]&&u.setAttribute("morphTarget"+x,y[C]),m&&u.getAttribute("morphNormal"+x)!==m[C]&&u.setAttribute("morphNormal"+x,m[C]),i[x]=M,v+=M):(y&&u.hasAttribute("morphTarget"+x)===!0&&u.deleteAttribute("morphTarget"+x),m&&u.hasAttribute("morphNormal"+x)===!0&&u.deleteAttribute("morphNormal"+x),i[x]=0)}const _=u.morphTargetsRelative?1:1-v;d.getUniforms().setValue(a,"morphTargetBaseInfluence",_),d.getUniforms().setValue(a,"morphTargetInfluences",i)}}return{update:l}}function Qp(a,t,e,n){let i=new WeakMap;function r(l){const h=n.render.frame,u=l.geometry,c=t.get(l,u);return i.get(c)!==h&&(t.update(c),i.set(c,h)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),e.update(l.instanceMatrix,34962),l.instanceColor!==null&&e.update(l.instanceColor,34962)),c}function s(){i=new WeakMap}function o(l){const h=l.target;h.removeEventListener("dispose",o),e.remove(h.instanceMatrix),h.instanceColor!==null&&e.remove(h.instanceColor)}return{update:r,dispose:s}}class Va extends Te{constructor(t=null,e=1,n=1,i=1){super(null);this.image={data:t,width:e,height:n,depth:i},this.magFilter=_e,this.minFilter=_e,this.wrapR=He,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Va.prototype.isDataTexture3D=!0;const Oa=new Te,Ua=new ro,Wa=new Va,Ga=new Or,Ha=[],ka=[],qa=new Float32Array(16),Xa=new Float32Array(9),Ya=new Float32Array(4);function Ai(a,t,e){const n=a[0];if(n<=0||n>0)return a;const i=t*e;let r=Ha[i];if(r===void 0&&(r=new Float32Array(i),Ha[i]=r),t!==0){n.toArray(r,0);for(let s=1,o=0;s!==t;++s)o+=e,a[s].toArray(r,o)}return r}function Be(a,t){if(a.length!==t.length)return!1;for(let e=0,n=a.length;e<n;e++)if(a[e]!==t[e])return!1;return!0}function Le(a,t){for(let e=0,n=t.length;e<n;e++)a[e]=t[e]}function qr(a,t){let e=ka[t];e===void 0&&(e=new Int32Array(t),ka[t]=e);for(let n=0;n!==t;++n)e[n]=a.allocateTextureUnit();return e}function $p(a,t){const e=this.cache;e[0]!==t&&(a.uniform1f(this.addr,t),e[0]=t)}function Kp(a,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(a.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Be(e,t))return;a.uniform2fv(this.addr,t),Le(e,t)}}function tf(a,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(a.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(a.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Be(e,t))return;a.uniform3fv(this.addr,t),Le(e,t)}}function ef(a,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(a.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Be(e,t))return;a.uniform4fv(this.addr,t),Le(e,t)}}function nf(a,t){const e=this.cache,n=t.elements;if(n===void 0){if(Be(e,t))return;a.uniformMatrix2fv(this.addr,!1,t),Le(e,t)}else{if(Be(e,n))return;Ya.set(n),a.uniformMatrix2fv(this.addr,!1,Ya),Le(e,n)}}function rf(a,t){const e=this.cache,n=t.elements;if(n===void 0){if(Be(e,t))return;a.uniformMatrix3fv(this.addr,!1,t),Le(e,t)}else{if(Be(e,n))return;Xa.set(n),a.uniformMatrix3fv(this.addr,!1,Xa),Le(e,n)}}function sf(a,t){const e=this.cache,n=t.elements;if(n===void 0){if(Be(e,t))return;a.uniformMatrix4fv(this.addr,!1,t),Le(e,t)}else{if(Be(e,n))return;qa.set(n),a.uniformMatrix4fv(this.addr,!1,qa),Le(e,n)}}function of(a,t){const e=this.cache;e[0]!==t&&(a.uniform1i(this.addr,t),e[0]=t)}function af(a,t){const e=this.cache;Be(e,t)||(a.uniform2iv(this.addr,t),Le(e,t))}function lf(a,t){const e=this.cache;Be(e,t)||(a.uniform3iv(this.addr,t),Le(e,t))}function cf(a,t){const e=this.cache;Be(e,t)||(a.uniform4iv(this.addr,t),Le(e,t))}function hf(a,t){const e=this.cache;e[0]!==t&&(a.uniform1ui(this.addr,t),e[0]=t)}function uf(a,t){const e=this.cache;Be(e,t)||(a.uniform2uiv(this.addr,t),Le(e,t))}function df(a,t){const e=this.cache;Be(e,t)||(a.uniform3uiv(this.addr,t),Le(e,t))}function pf(a,t){const e=this.cache;Be(e,t)||(a.uniform4uiv(this.addr,t),Le(e,t))}function ff(a,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),e.safeSetTexture2D(t||Oa,i)}function mf(a,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||Wa,i)}function vf(a,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),e.safeSetTextureCube(t||Ga,i)}function gf(a,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(a.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||Ua,i)}function yf(a){switch(a){case 5126:return $p;case 35664:return Kp;case 35665:return tf;case 35666:return ef;case 35674:return nf;case 35675:return rf;case 35676:return sf;case 5124:case 35670:return of;case 35667:case 35671:return af;case 35668:case 35672:return lf;case 35669:case 35673:return cf;case 5125:return hf;case 36294:return uf;case 36295:return df;case 36296:return pf;case 35678:case 36198:case 36298:case 36306:case 35682:return ff;case 35679:case 36299:case 36307:return mf;case 35680:case 36300:case 36308:case 36293:return vf;case 36289:case 36303:case 36311:case 36292:return gf}}function xf(a,t){a.uniform1fv(this.addr,t)}function _f(a,t){const e=Ai(t,this.size,2);a.uniform2fv(this.addr,e)}function wf(a,t){const e=Ai(t,this.size,3);a.uniform3fv(this.addr,e)}function Mf(a,t){const e=Ai(t,this.size,4);a.uniform4fv(this.addr,e)}function bf(a,t){const e=Ai(t,this.size,4);a.uniformMatrix2fv(this.addr,!1,e)}function Sf(a,t){const e=Ai(t,this.size,9);a.uniformMatrix3fv(this.addr,!1,e)}function Ef(a,t){const e=Ai(t,this.size,16);a.uniformMatrix4fv(this.addr,!1,e)}function Tf(a,t){a.uniform1iv(this.addr,t)}function Af(a,t){a.uniform2iv(this.addr,t)}function Cf(a,t){a.uniform3iv(this.addr,t)}function Rf(a,t){a.uniform4iv(this.addr,t)}function Lf(a,t){a.uniform1uiv(this.addr,t)}function Pf(a,t){a.uniform2uiv(this.addr,t)}function If(a,t){a.uniform3uiv(this.addr,t)}function Bf(a,t){a.uniform4uiv(this.addr,t)}function Ff(a,t,e){const n=t.length,i=qr(e,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)e.safeSetTexture2D(t[r]||Oa,i[r])}function Df(a,t,e){const n=t.length,i=qr(e,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)e.setTexture3D(t[r]||Wa,i[r])}function Nf(a,t,e){const n=t.length,i=qr(e,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)e.safeSetTextureCube(t[r]||Ga,i[r])}function zf(a,t,e){const n=t.length,i=qr(e,n);a.uniform1iv(this.addr,i);for(let r=0;r!==n;++r)e.setTexture2DArray(t[r]||Ua,i[r])}function Vf(a){switch(a){case 5126:return xf;case 35664:return _f;case 35665:return wf;case 35666:return Mf;case 35674:return bf;case 35675:return Sf;case 35676:return Ef;case 5124:case 35670:return Tf;case 35667:case 35671:return Af;case 35668:case 35672:return Cf;case 35669:case 35673:return Rf;case 5125:return Lf;case 36294:return Pf;case 36295:return If;case 36296:return Bf;case 35678:case 36198:case 36298:case 36306:case 35682:return Ff;case 35679:case 36299:case 36307:return Df;case 35680:case 36300:case 36308:case 36293:return Nf;case 36289:case 36303:case 36311:case 36292:return zf}}function Of(a,t,e){this.id=a,this.addr=e,this.cache=[],this.setValue=yf(t.type)}function Za(a,t,e){this.id=a,this.addr=e,this.cache=[],this.size=t.size,this.setValue=Vf(t.type)}Za.prototype.updateCache=function(a){const t=this.cache;a instanceof Float32Array&&t.length!==a.length&&(this.cache=new Float32Array(a.length)),Le(t,a)};function ja(a){this.id=a,this.seq=[],this.map={}}ja.prototype.setValue=function(a,t,e){const n=this.seq;for(let i=0,r=n.length;i!==r;++i){const s=n[i];s.setValue(a,t[s.id],e)}};const so=/(\w+)(\])?(\[|\.)?/g;function Ja(a,t){a.seq.push(t),a.map[t.id]=t}function Uf(a,t,e){const n=a.name,i=n.length;for(so.lastIndex=0;;){const r=so.exec(n),s=so.lastIndex;let o=r[1];const l=r[2]==="]",h=r[3];if(l&&(o=o|0),h===void 0||h==="["&&s+2===i){Ja(e,h===void 0?new Of(o,a,t):new Za(o,a,t));break}else{let c=e.map[o];c===void 0&&(c=new ja(o),Ja(e,c)),e=c}}}function Fn(a,t){this.seq=[],this.map={};const e=a.getProgramParameter(t,35718);for(let n=0;n<e;++n){const i=a.getActiveUniform(t,n),r=a.getUniformLocation(t,i.name);Uf(i,r,this)}}Fn.prototype.setValue=function(a,t,e,n){const i=this.map[t];i!==void 0&&i.setValue(a,e,n)};Fn.prototype.setOptional=function(a,t,e){const n=t[e];n!==void 0&&this.setValue(a,e,n)};Fn.upload=function(a,t,e,n){for(let i=0,r=t.length;i!==r;++i){const s=t[i],o=e[s.id];o.needsUpdate!==!1&&s.setValue(a,o.value,n)}};Fn.seqWithValue=function(a,t){const e=[];for(let n=0,i=a.length;n!==i;++n){const r=a[n];r.id in t&&e.push(r)}return e};function Qa(a,t,e){const n=a.createShader(t);return a.shaderSource(n,e),a.compileShader(n),n}let Wf=0;function Gf(a){const t=a.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function $a(a){switch(a){case ze:return["Linear","( value )"];case _r:return["sRGB","( value )"];case _s:return["RGBE","( value )"];case oa:return["RGBM","( value, 7.0 )"];case aa:return["RGBM","( value, 16.0 )"];case la:return["RGBD","( value, 256.0 )"];case xs:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",a),["Linear","( value )"]}}function Ka(a,t,e){const n=a.getShaderParameter(t,35713),i=a.getShaderInfoLog(t).trim();return n&&i===""?"":e.toUpperCase()+`

`+i+`

`+Gf(a.getShaderSource(t))}function Qn(a,t){const e=$a(t);return"vec4 "+a+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function Hf(a,t){const e=$a(t);return"vec4 "+a+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function kf(a,t){let e;switch(t){case Bc:e="Linear";break;case Fc:e="Reinhard";break;case Dc:e="OptimizedCineon";break;case Nc:e="ACESFilmic";break;case zc:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+a+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function qf(a){return[a.extensionDerivatives||a.envMapCubeUV||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||a.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ji).join(`
`)}function Xf(a){const t=[];for(const e in a){const n=a[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Yf(a,t){const e={},n=a.getProgramParameter(t,35721);for(let i=0;i<n;i++){const r=a.getActiveAttrib(t,i),s=r.name;let o=1;r.type===35674&&(o=2),r.type===35675&&(o=3),r.type===35676&&(o=4),e[s]={type:r.type,location:a.getAttribLocation(t,s),locationSize:o}}return e}function Ji(a){return a!==""}function tl(a,t){return a.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function el(a,t){return a.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Zf=/^[ \t]*#include +<([\w\d./]+)>/gm;function oo(a){return a.replace(Zf,jf)}function jf(a,t){const e=Zt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return oo(e)}const Jf=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Qf=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function nl(a){return a.replace(Qf,il).replace(Jf,$f)}function $f(a,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),il(a,t,e,n)}function il(a,t,e,n){let i="";for(let r=parseInt(t);r<parseInt(e);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function rl(a){let t="precision "+a.precision+` float;
precision `+a.precision+" int;";return a.precision==="highp"?t+=`
#define HIGH_PRECISION`:a.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:a.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Kf(a){let t="SHADOWMAP_TYPE_BASIC";return a.shadowMapType===zo?t="SHADOWMAP_TYPE_PCF":a.shadowMapType===uc?t="SHADOWMAP_TYPE_PCF_SOFT":a.shadowMapType===zi&&(t="SHADOWMAP_TYPE_VSM"),t}function tm(a){let t="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case Ui:case Wi:t="ENVMAP_TYPE_CUBE";break;case fr:case fs:t="ENVMAP_TYPE_CUBE_UV";break}return t}function em(a){let t="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case Wi:case fs:t="ENVMAP_MODE_REFRACTION";break}return t}function nm(a){let t="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case pr:t="ENVMAP_BLENDING_MULTIPLY";break;case Pc:t="ENVMAP_BLENDING_MIX";break;case Ic:t="ENVMAP_BLENDING_ADD";break}return t}function im(a,t,e,n){const i=a.getContext(),r=e.defines;let s=e.vertexShader,o=e.fragmentShader;const l=Kf(e),h=tm(e),u=em(e),c=nm(e),d=a.gammaFactor>0?a.gammaFactor:1,p=e.isWebGL2?"":qf(e),f=Xf(r),g=i.createProgram();let y,m,v=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(y=[f].filter(Ji).join(`
`),y.length>0&&(y+=`
`),m=[p,f].filter(Ji).join(`
`),m.length>0&&(m+=`
`)):(y=[rl(e),"#define SHADER_NAME "+e.shaderName,f,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ji).join(`
`),m=[p,rl(e),"#define SHADER_NAME "+e.shaderName,f,"#define GAMMA_FACTOR "+d,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.envMap?"#define "+u:"",e.envMap?"#define "+c:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==Gn?"#define TONE_MAPPING":"",e.toneMapping!==Gn?Zt.tonemapping_pars_fragment:"",e.toneMapping!==Gn?kf("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===Hn?"#define OPAQUE":"",Zt.encodings_pars_fragment,e.map?Qn("mapTexelToLinear",e.mapEncoding):"",e.matcap?Qn("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?Qn("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?Qn("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularColorMap?Qn("specularColorMapTexelToLinear",e.specularColorMapEncoding):"",e.sheenColorMap?Qn("sheenColorMapTexelToLinear",e.sheenColorMapEncoding):"",e.lightMap?Qn("lightMapTexelToLinear",e.lightMapEncoding):"",Hf("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Ji).join(`
`)),s=oo(s),s=tl(s,e),s=el(s,e),o=oo(o),o=tl(o,e),o=el(o,e),s=nl(s),o=nl(o),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,y=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,m=["#define varying in",e.glslVersion===ca?"":"out highp vec4 pc_fragColor;",e.glslVersion===ca?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+m);const _=v+y+s,x=v+m+o,w=Qa(i,35633,_),C=Qa(i,35632,x);if(i.attachShader(g,w),i.attachShader(g,C),e.index0AttributeName!==void 0?i.bindAttribLocation(g,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(g,0,"position"),i.linkProgram(g),a.debug.checkShaderErrors){const j=i.getProgramInfoLog(g).trim(),N=i.getShaderInfoLog(w).trim(),b=i.getShaderInfoLog(C).trim();let U=!0,V=!0;if(i.getProgramParameter(g,35714)===!1){U=!1;const H=Ka(i,w,"vertex"),Y=Ka(i,C,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(g,35715)+`

Program Info Log: `+j+`
`+H+`
`+Y)}else j!==""?console.warn("THREE.WebGLProgram: Program Info Log:",j):(N===""||b==="")&&(V=!1);V&&(this.diagnostics={runnable:U,programLog:j,vertexShader:{log:N,prefix:y},fragmentShader:{log:b,prefix:m}})}i.deleteShader(w),i.deleteShader(C);let M;this.getUniforms=function(){return M===void 0&&(M=new Fn(i,g)),M};let D;return this.getAttributes=function(){return D===void 0&&(D=Yf(i,g)),D},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(g),this.program=void 0},this.name=e.shaderName,this.id=Wf++,this.cacheKey=t,this.usedTimes=1,this.program=g,this.vertexShader=w,this.fragmentShader=C,this}function rm(a,t,e,n,i,r,s){const o=[],l=i.isWebGL2,h=i.logarithmicDepthBuffer,u=i.floatVertexTextures,c=i.maxVertexUniforms,d=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},g=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function y(M){const j=M.skeleton.bones;if(u)return 1024;{const b=Math.floor((c-20)/4),U=Math.min(b,j.length);return U<j.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+j.length+" bones. This GPU supports "+U+"."),0):U}}function m(M){let D;return M&&M.isTexture?D=M.encoding:M&&M.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),D=M.texture.encoding):D=ze,D}function v(M,D,j,N,b){const U=N.fog,V=M.isMeshStandardMaterial?N.environment:null,H=(M.isMeshStandardMaterial?e:t).get(M.envMap||V),Y=f[M.type],Q=b.isSkinnedMesh?y(b):0;M.precision!==null&&(p=i.getMaxPrecision(M.precision),p!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",p,"instead."));let P,z;if(Y){const A=an[Y];P=A.vertexShader,z=A.fragmentShader}else P=M.vertexShader,z=M.fragmentShader;const it=a.getRenderTarget(),W=M.alphaTest>0,T=M.clearcoat>0;return{isWebGL2:l,shaderID:Y,shaderName:M.type,vertexShader:P,fragmentShader:z,defines:M.defines,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:p,instancing:b.isInstancedMesh===!0,instancingColor:b.isInstancedMesh===!0&&b.instanceColor!==null,supportsVertexTextures:d,outputEncoding:it!==null?m(it.texture):a.outputEncoding,map:!!M.map,mapEncoding:m(M.map),matcap:!!M.matcap,matcapEncoding:m(M.matcap),envMap:!!H,envMapMode:H&&H.mapping,envMapEncoding:m(H),envMapCubeUV:!!H&&(H.mapping===fr||H.mapping===fs),lightMap:!!M.lightMap,lightMapEncoding:m(M.lightMap),aoMap:!!M.aoMap,emissiveMap:!!M.emissiveMap,emissiveMapEncoding:m(M.emissiveMap),bumpMap:!!M.bumpMap,normalMap:!!M.normalMap,objectSpaceNormalMap:M.normalMapType===zh,tangentSpaceNormalMap:M.normalMapType===si,clearcoat:T,clearcoatMap:T&&!!M.clearcoatMap,clearcoatRoughnessMap:T&&!!M.clearcoatRoughnessMap,clearcoatNormalMap:T&&!!M.clearcoatNormalMap,displacementMap:!!M.displacementMap,roughnessMap:!!M.roughnessMap,metalnessMap:!!M.metalnessMap,specularMap:!!M.specularMap,specularIntensityMap:!!M.specularIntensityMap,specularColorMap:!!M.specularColorMap,specularColorMapEncoding:m(M.specularColorMap),alphaMap:!!M.alphaMap,alphaTest:W,gradientMap:!!M.gradientMap,sheen:M.sheen>0,sheenColorMap:!!M.sheenColorMap,sheenColorMapEncoding:m(M.sheenColorMap),sheenRoughnessMap:!!M.sheenRoughnessMap,transmission:M.transmission>0,transmissionMap:!!M.transmissionMap,thicknessMap:!!M.thicknessMap,combine:M.combine,vertexTangents:!!M.normalMap&&!!b.geometry&&!!b.geometry.attributes.tangent,vertexColors:M.vertexColors,vertexAlphas:M.vertexColors===!0&&!!b.geometry&&!!b.geometry.attributes.color&&b.geometry.attributes.color.itemSize===4,vertexUvs:!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatMap||!!M.clearcoatRoughnessMap||!!M.clearcoatNormalMap||!!M.displacementMap||!!M.transmissionMap||!!M.thicknessMap||!!M.specularIntensityMap||!!M.specularColorMap||!!M.sheenColorMap||M.sheenRoughnessMap,uvsVertexOnly:!(!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatNormalMap||M.transmission>0||!!M.transmissionMap||!!M.thicknessMap||!!M.specularIntensityMap||!!M.specularColorMap||M.sheen>0||!!M.sheenColorMap||!!M.sheenRoughnessMap)&&!!M.displacementMap,fog:!!U,useFog:M.fog,fogExp2:U&&U.isFogExp2,flatShading:!!M.flatShading,sizeAttenuation:M.sizeAttenuation,logarithmicDepthBuffer:h,skinning:b.isSkinnedMesh===!0&&Q>0,maxBones:Q,useVertexTexture:u,morphTargets:!!b.geometry&&!!b.geometry.morphAttributes.position,morphNormals:!!b.geometry&&!!b.geometry.morphAttributes.normal,morphTargetsCount:!!b.geometry&&!!b.geometry.morphAttributes.position?b.geometry.morphAttributes.position.length:0,numDirLights:D.directional.length,numPointLights:D.point.length,numSpotLights:D.spot.length,numRectAreaLights:D.rectArea.length,numHemiLights:D.hemi.length,numDirLightShadows:D.directionalShadowMap.length,numPointLightShadows:D.pointShadowMap.length,numSpotLightShadows:D.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,format:M.format,dithering:M.dithering,shadowMapEnabled:a.shadowMap.enabled&&j.length>0,shadowMapType:a.shadowMap.type,toneMapping:M.toneMapped?a.toneMapping:Gn,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:M.premultipliedAlpha,doubleSided:M.side===$n,flipSided:M.side===ge,depthPacking:M.depthPacking!==void 0?M.depthPacking:!1,index0AttributeName:M.index0AttributeName,extensionDerivatives:M.extensions&&M.extensions.derivatives,extensionFragDepth:M.extensions&&M.extensions.fragDepth,extensionDrawBuffers:M.extensions&&M.extensions.drawBuffers,extensionShaderTextureLOD:M.extensions&&M.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||n.has("EXT_shader_texture_lod"),customProgramCacheKey:M.customProgramCacheKey()}}function _(M){const D=[];if(M.shaderID?D.push(M.shaderID):(D.push(da(M.fragmentShader)),D.push(da(M.vertexShader))),M.defines!==void 0)for(const j in M.defines)D.push(j),D.push(M.defines[j]);if(M.isRawShaderMaterial===!1){for(let j=0;j<g.length;j++)D.push(M[g[j]]);D.push(a.outputEncoding),D.push(a.gammaFactor)}return D.push(M.customProgramCacheKey),D.join()}function x(M){const D=f[M.type];let j;if(D){const N=an[D];j=eu.clone(N.uniforms)}else j=M.uniforms;return j}function w(M,D){let j;for(let N=0,b=o.length;N<b;N++){const U=o[N];if(U.cacheKey===D){j=U,++j.usedTimes;break}}return j===void 0&&(j=new im(a,D,M,r),o.push(j)),j}function C(M){if(--M.usedTimes==0){const D=o.indexOf(M);o[D]=o[o.length-1],o.pop(),M.destroy()}}return{getParameters:v,getProgramCacheKey:_,getUniforms:x,acquireProgram:w,releaseProgram:C,programs:o}}function sm(){let a=new WeakMap;function t(r){let s=a.get(r);return s===void 0&&(s={},a.set(r,s)),s}function e(r){a.delete(r)}function n(r,s,o){a.get(r)[s]=o}function i(){a=new WeakMap}return{get:t,remove:e,update:n,dispose:i}}function om(a,t){return a.groupOrder!==t.groupOrder?a.groupOrder-t.groupOrder:a.renderOrder!==t.renderOrder?a.renderOrder-t.renderOrder:a.program!==t.program?a.program.id-t.program.id:a.material.id!==t.material.id?a.material.id-t.material.id:a.z!==t.z?a.z-t.z:a.id-t.id}function sl(a,t){return a.groupOrder!==t.groupOrder?a.groupOrder-t.groupOrder:a.renderOrder!==t.renderOrder?a.renderOrder-t.renderOrder:a.z!==t.z?t.z-a.z:a.id-t.id}function ol(a){const t=[];let e=0;const n=[],i=[],r=[],s={id:-1};function o(){e=0,n.length=0,i.length=0,r.length=0}function l(p,f,g,y,m,v){let _=t[e];const x=a.get(g);return _===void 0?(_={id:p.id,object:p,geometry:f,material:g,program:x.program||s,groupOrder:y,renderOrder:p.renderOrder,z:m,group:v},t[e]=_):(_.id=p.id,_.object=p,_.geometry=f,_.material=g,_.program=x.program||s,_.groupOrder=y,_.renderOrder=p.renderOrder,_.z=m,_.group=v),e++,_}function h(p,f,g,y,m,v){const _=l(p,f,g,y,m,v);g.transmission>0?i.push(_):g.transparent===!0?r.push(_):n.push(_)}function u(p,f,g,y,m,v){const _=l(p,f,g,y,m,v);g.transmission>0?i.unshift(_):g.transparent===!0?r.unshift(_):n.unshift(_)}function c(p,f){n.length>1&&n.sort(p||om),i.length>1&&i.sort(f||sl),r.length>1&&r.sort(f||sl)}function d(){for(let p=e,f=t.length;p<f;p++){const g=t[p];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.program=null,g.group=null}}return{opaque:n,transmissive:i,transparent:r,init:o,push:h,unshift:u,finish:d,sort:c}}function am(a){let t=new WeakMap;function e(i,r){let s;return t.has(i)===!1?(s=new ol(a),t.set(i,[s])):r>=t.get(i).length?(s=new ol(a),t.get(i).push(s)):s=t.get(i)[r],s}function n(){t=new WeakMap}return{get:e,dispose:n}}function lm(){const a={};return{get:function(t){if(a[t.id]!==void 0)return a[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new G,color:new Ot};break;case"SpotLight":e={position:new G,direction:new G,color:new Ot,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new G,color:new Ot,distance:0,decay:0};break;case"HemisphereLight":e={direction:new G,skyColor:new Ot,groundColor:new Ot};break;case"RectAreaLight":e={color:new Ot,position:new G,halfWidth:new G,halfHeight:new G};break}return a[t.id]=e,e}}}function cm(){const a={};return{get:function(t){if(a[t.id]!==void 0)return a[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Tt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Tt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Tt,shadowCameraNear:1,shadowCameraFar:1e3};break}return a[t.id]=e,e}}}let hm=0;function um(a,t){return(t.castShadow?1:0)-(a.castShadow?1:0)}function dm(a,t){const e=new lm,n=cm(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)i.probe.push(new G);const r=new G,s=new Wt,o=new Wt;function l(u,c){let d=0,p=0,f=0;for(let j=0;j<9;j++)i.probe[j].set(0,0,0);let g=0,y=0,m=0,v=0,_=0,x=0,w=0,C=0;u.sort(um);const M=c!==!0?Math.PI:1;for(let j=0,N=u.length;j<N;j++){const b=u[j],U=b.color,V=b.intensity,H=b.distance,Y=b.shadow&&b.shadow.map?b.shadow.map.texture:null;if(b.isAmbientLight)d+=U.r*V*M,p+=U.g*V*M,f+=U.b*V*M;else if(b.isLightProbe)for(let Q=0;Q<9;Q++)i.probe[Q].addScaledVector(b.sh.coefficients[Q],V);else if(b.isDirectionalLight){const Q=e.get(b);if(Q.color.copy(b.color).multiplyScalar(b.intensity*M),b.castShadow){const P=b.shadow,z=n.get(b);z.shadowBias=P.bias,z.shadowNormalBias=P.normalBias,z.shadowRadius=P.radius,z.shadowMapSize=P.mapSize,i.directionalShadow[g]=z,i.directionalShadowMap[g]=Y,i.directionalShadowMatrix[g]=b.shadow.matrix,x++}i.directional[g]=Q,g++}else if(b.isSpotLight){const Q=e.get(b);if(Q.position.setFromMatrixPosition(b.matrixWorld),Q.color.copy(U).multiplyScalar(V*M),Q.distance=H,Q.coneCos=Math.cos(b.angle),Q.penumbraCos=Math.cos(b.angle*(1-b.penumbra)),Q.decay=b.decay,b.castShadow){const P=b.shadow,z=n.get(b);z.shadowBias=P.bias,z.shadowNormalBias=P.normalBias,z.shadowRadius=P.radius,z.shadowMapSize=P.mapSize,i.spotShadow[m]=z,i.spotShadowMap[m]=Y,i.spotShadowMatrix[m]=b.shadow.matrix,C++}i.spot[m]=Q,m++}else if(b.isRectAreaLight){const Q=e.get(b);Q.color.copy(U).multiplyScalar(V),Q.halfWidth.set(b.width*.5,0,0),Q.halfHeight.set(0,b.height*.5,0),i.rectArea[v]=Q,v++}else if(b.isPointLight){const Q=e.get(b);if(Q.color.copy(b.color).multiplyScalar(b.intensity*M),Q.distance=b.distance,Q.decay=b.decay,b.castShadow){const P=b.shadow,z=n.get(b);z.shadowBias=P.bias,z.shadowNormalBias=P.normalBias,z.shadowRadius=P.radius,z.shadowMapSize=P.mapSize,z.shadowCameraNear=P.camera.near,z.shadowCameraFar=P.camera.far,i.pointShadow[y]=z,i.pointShadowMap[y]=Y,i.pointShadowMatrix[y]=b.shadow.matrix,w++}i.point[y]=Q,y++}else if(b.isHemisphereLight){const Q=e.get(b);Q.skyColor.copy(b.color).multiplyScalar(V*M),Q.groundColor.copy(b.groundColor).multiplyScalar(V*M),i.hemi[_]=Q,_++}}v>0&&(t.isWebGL2||a.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=It.LTC_FLOAT_1,i.rectAreaLTC2=It.LTC_FLOAT_2):a.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=It.LTC_HALF_1,i.rectAreaLTC2=It.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=p,i.ambient[2]=f;const D=i.hash;(D.directionalLength!==g||D.pointLength!==y||D.spotLength!==m||D.rectAreaLength!==v||D.hemiLength!==_||D.numDirectionalShadows!==x||D.numPointShadows!==w||D.numSpotShadows!==C)&&(i.directional.length=g,i.spot.length=m,i.rectArea.length=v,i.point.length=y,i.hemi.length=_,i.directionalShadow.length=x,i.directionalShadowMap.length=x,i.pointShadow.length=w,i.pointShadowMap.length=w,i.spotShadow.length=C,i.spotShadowMap.length=C,i.directionalShadowMatrix.length=x,i.pointShadowMatrix.length=w,i.spotShadowMatrix.length=C,D.directionalLength=g,D.pointLength=y,D.spotLength=m,D.rectAreaLength=v,D.hemiLength=_,D.numDirectionalShadows=x,D.numPointShadows=w,D.numSpotShadows=C,i.version=hm++)}function h(u,c){let d=0,p=0,f=0,g=0,y=0;const m=c.matrixWorldInverse;for(let v=0,_=u.length;v<_;v++){const x=u[v];if(x.isDirectionalLight){const w=i.directional[d];w.direction.setFromMatrixPosition(x.matrixWorld),r.setFromMatrixPosition(x.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(m),d++}else if(x.isSpotLight){const w=i.spot[f];w.position.setFromMatrixPosition(x.matrixWorld),w.position.applyMatrix4(m),w.direction.setFromMatrixPosition(x.matrixWorld),r.setFromMatrixPosition(x.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(m),f++}else if(x.isRectAreaLight){const w=i.rectArea[g];w.position.setFromMatrixPosition(x.matrixWorld),w.position.applyMatrix4(m),o.identity(),s.copy(x.matrixWorld),s.premultiply(m),o.extractRotation(s),w.halfWidth.set(x.width*.5,0,0),w.halfHeight.set(0,x.height*.5,0),w.halfWidth.applyMatrix4(o),w.halfHeight.applyMatrix4(o),g++}else if(x.isPointLight){const w=i.point[p];w.position.setFromMatrixPosition(x.matrixWorld),w.position.applyMatrix4(m),p++}else if(x.isHemisphereLight){const w=i.hemi[y];w.direction.setFromMatrixPosition(x.matrixWorld),w.direction.transformDirection(m),w.direction.normalize(),y++}}}return{setup:l,setupView:h,state:i}}function al(a,t){const e=new dm(a,t),n=[],i=[];function r(){n.length=0,i.length=0}function s(c){n.push(c)}function o(c){i.push(c)}function l(c){e.setup(n,c)}function h(c){e.setupView(n,c)}return{init:r,state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:l,setupLightsView:h,pushLight:s,pushShadow:o}}function pm(a,t){let e=new WeakMap;function n(r,s=0){let o;return e.has(r)===!1?(o=new al(a,t),e.set(r,[o])):s>=e.get(r).length?(o=new al(a,t),e.get(r).push(o)):o=e.get(r)[s],o}function i(){e=new WeakMap}return{get:n,dispose:i}}class ll extends Ce{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=Dh,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}ll.prototype.isMeshDepthMaterial=!0;class cl extends Ce{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new G,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}cl.prototype.isMeshDistanceMaterial=!0;const fm=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,mm=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function hl(a,t,e){let n=new Wr;const i=new Tt,r=new Tt,s=new ee,o=new ll({depthPacking:Nh}),l=new cl,h={},u=e.maxTextureSize,c={0:ge,1:Vi,2:$n},d=new Zn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Tt},radius:{value:4}},vertexShader:fm,fragmentShader:mm}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new se;f.setAttribute("position",new ye(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new Oe(f,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=zo,this.render=function(x,w,C){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||x.length===0)return;const M=a.getRenderTarget(),D=a.getActiveCubeFace(),j=a.getActiveMipmapLevel(),N=a.state;N.setBlending(bn),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let b=0,U=x.length;b<U;b++){const V=x[b],H=V.shadow;if(H===void 0){console.warn("THREE.WebGLShadowMap:",V,"has no shadow.");continue}if(H.autoUpdate===!1&&H.needsUpdate===!1)continue;i.copy(H.mapSize);const Y=H.getFrameExtents();if(i.multiply(Y),r.copy(H.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/Y.x),i.x=r.x*Y.x,H.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/Y.y),i.y=r.y*Y.y,H.mapSize.y=r.y)),H.map===null&&!H.isPointLightShadow&&this.type===zi){const P={minFilter:Ze,magFilter:Ze,format:Ie};H.map=new je(i.x,i.y,P),H.map.texture.name=V.name+".shadowMap",H.mapPass=new je(i.x,i.y,P),H.camera.updateProjectionMatrix()}if(H.map===null){const P={minFilter:_e,magFilter:_e,format:Ie};H.map=new je(i.x,i.y,P),H.map.texture.name=V.name+".shadowMap",H.camera.updateProjectionMatrix()}a.setRenderTarget(H.map),a.clear();const Q=H.getViewportCount();for(let P=0;P<Q;P++){const z=H.getViewport(P);s.set(r.x*z.x,r.y*z.y,r.x*z.z,r.y*z.w),N.viewport(s),H.updateMatrices(V,P),n=H.getFrustum(),_(w,C,H.camera,V,this.type)}!H.isPointLightShadow&&this.type===zi&&m(H,C),H.needsUpdate=!1}y.needsUpdate=!1,a.setRenderTarget(M,D,j)};function m(x,w){const C=t.update(g);d.defines.VSM_SAMPLES!==x.blurSamples&&(d.defines.VSM_SAMPLES=x.blurSamples,p.defines.VSM_SAMPLES=x.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=x.map.texture,d.uniforms.resolution.value=x.mapSize,d.uniforms.radius.value=x.radius,a.setRenderTarget(x.mapPass),a.clear(),a.renderBufferDirect(w,null,C,d,g,null),p.uniforms.shadow_pass.value=x.mapPass.texture,p.uniforms.resolution.value=x.mapSize,p.uniforms.radius.value=x.radius,a.setRenderTarget(x.map),a.clear(),a.renderBufferDirect(w,null,C,p,g,null)}function v(x,w,C,M,D,j,N){let b=null;const U=M.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(U!==void 0?b=U:b=M.isPointLight===!0?l:o,a.localClippingEnabled&&C.clipShadows===!0&&C.clippingPlanes.length!==0||C.displacementMap&&C.displacementScale!==0||C.alphaMap&&C.alphaTest>0){const V=b.uuid,H=C.uuid;let Y=h[V];Y===void 0&&(Y={},h[V]=Y);let Q=Y[H];Q===void 0&&(Q=b.clone(),Y[H]=Q),b=Q}return b.visible=C.visible,b.wireframe=C.wireframe,N===zi?b.side=C.shadowSide!==null?C.shadowSide:C.side:b.side=C.shadowSide!==null?C.shadowSide:c[C.side],b.alphaMap=C.alphaMap,b.alphaTest=C.alphaTest,b.clipShadows=C.clipShadows,b.clippingPlanes=C.clippingPlanes,b.clipIntersection=C.clipIntersection,b.displacementMap=C.displacementMap,b.displacementScale=C.displacementScale,b.displacementBias=C.displacementBias,b.wireframeLinewidth=C.wireframeLinewidth,b.linewidth=C.linewidth,M.isPointLight===!0&&b.isMeshDistanceMaterial===!0&&(b.referencePosition.setFromMatrixPosition(M.matrixWorld),b.nearDistance=D,b.farDistance=j),b}function _(x,w,C,M,D){if(x.visible===!1)return;if(x.layers.test(w.layers)&&(x.isMesh||x.isLine||x.isPoints)&&(x.castShadow||x.receiveShadow&&D===zi)&&(!x.frustumCulled||n.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse,x.matrixWorld);const b=t.update(x),U=x.material;if(Array.isArray(U)){const V=b.groups;for(let H=0,Y=V.length;H<Y;H++){const Q=V[H],P=U[Q.materialIndex];if(P&&P.visible){const z=v(x,b,P,M,C.near,C.far,D);a.renderBufferDirect(C,null,b,z,x,Q)}}}else if(U.visible){const V=v(x,b,U,M,C.near,C.far,D);a.renderBufferDirect(C,null,b,V,x,null)}}const N=x.children;for(let b=0,U=N.length;b<U;b++)_(N[b],w,C,M,D)}}function vm(a,t,e){const n=e.isWebGL2;function i(){let J=!1;const yt=new ee;let gt=null;const Rt=new ee(0,0,0,0);return{setMask:function(At){gt!==At&&!J&&(a.colorMask(At,At,At,At),gt=At)},setLocked:function(At){J=At},setClear:function(At,Ft,Dt,Ut,Jt){Jt===!0&&(At*=Ut,Ft*=Ut,Dt*=Ut),yt.set(At,Ft,Dt,Ut),Rt.equals(yt)===!1&&(a.clearColor(At,Ft,Dt,Ut),Rt.copy(yt))},reset:function(){J=!1,gt=null,Rt.set(-1,0,0,0)}}}function r(){let J=!1,yt=null,gt=null,Rt=null;return{setTest:function(At){At?A(2929):I(2929)},setMask:function(At){yt!==At&&!J&&(a.depthMask(At),yt=At)},setFunc:function(At){if(gt!==At){if(At)switch(At){case Sc:a.depthFunc(512);break;case Ec:a.depthFunc(519);break;case Tc:a.depthFunc(513);break;case us:a.depthFunc(515);break;case Ac:a.depthFunc(514);break;case Cc:a.depthFunc(518);break;case Rc:a.depthFunc(516);break;case Lc:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);gt=At}},setLocked:function(At){J=At},setClear:function(At){Rt!==At&&(a.clearDepth(At),Rt=At)},reset:function(){J=!1,yt=null,gt=null,Rt=null}}}function s(){let J=!1,yt=null,gt=null,Rt=null,At=null,Ft=null,Dt=null,Ut=null,Jt=null;return{setTest:function(Yt){J||(Yt?A(2960):I(2960))},setMask:function(Yt){yt!==Yt&&!J&&(a.stencilMask(Yt),yt=Yt)},setFunc:function(Yt,he,ae){(gt!==Yt||Rt!==he||At!==ae)&&(a.stencilFunc(Yt,he,ae),gt=Yt,Rt=he,At=ae)},setOp:function(Yt,he,ae){(Ft!==Yt||Dt!==he||Ut!==ae)&&(a.stencilOp(Yt,he,ae),Ft=Yt,Dt=he,Ut=ae)},setLocked:function(Yt){J=Yt},setClear:function(Yt){Jt!==Yt&&(a.clearStencil(Yt),Jt=Yt)},reset:function(){J=!1,yt=null,gt=null,Rt=null,At=null,Ft=null,Dt=null,Ut=null,Jt=null}}}const o=new i,l=new r,h=new s;let u={},c={},d=null,p=!1,f=null,g=null,y=null,m=null,v=null,_=null,x=null,w=!1,C=null,M=null,D=null,j=null,N=null;const b=a.getParameter(35661);let U=!1,V=0;const H=a.getParameter(7938);H.indexOf("WebGL")!==-1?(V=parseFloat(/^WebGL (\d)/.exec(H)[1]),U=V>=1):H.indexOf("OpenGL ES")!==-1&&(V=parseFloat(/^OpenGL ES (\d)/.exec(H)[1]),U=V>=2);let Y=null,Q={};const P=a.getParameter(3088),z=a.getParameter(2978),it=new ee().fromArray(P),W=new ee().fromArray(z);function T(J,yt,gt){const Rt=new Uint8Array(4),At=a.createTexture();a.bindTexture(J,At),a.texParameteri(J,10241,9728),a.texParameteri(J,10240,9728);for(let Ft=0;Ft<gt;Ft++)a.texImage2D(yt+Ft,0,6408,1,1,0,6408,5121,Rt);return At}const Z={};Z[3553]=T(3553,3553,1),Z[34067]=T(34067,34069,6),o.setClear(0,0,0,1),l.setClear(1),h.setClear(0),A(2929),l.setFunc(us),lt(!1),$(No),A(2884),k(bn);function A(J){u[J]!==!0&&(a.enable(J),u[J]=!0)}function I(J){u[J]!==!1&&(a.disable(J),u[J]=!1)}function R(J,yt){return c[J]!==yt?(a.bindFramebuffer(J,yt),c[J]=yt,n&&(J===36009&&(c[36160]=yt),J===36160&&(c[36009]=yt)),!0):!1}function F(J){return d!==J?(a.useProgram(J),d=J,!0):!1}const ot={[Kn]:32774,[pc]:32778,[fc]:32779};if(n)ot[Go]=32775,ot[Ho]=32776;else{const J=t.get("EXT_blend_minmax");J!==null&&(ot[Go]=J.MIN_EXT,ot[Ho]=J.MAX_EXT)}const et={[mc]:0,[vc]:1,[gc]:768,[ko]:770,[bc]:776,[wc]:774,[xc]:772,[yc]:769,[qo]:771,[Mc]:775,[_c]:773};function k(J,yt,gt,Rt,At,Ft,Dt,Ut){if(J===bn){p===!0&&(I(3042),p=!1);return}if(p===!1&&(A(3042),p=!0),J!==dc){if(J!==f||Ut!==w){if((g!==Kn||v!==Kn)&&(a.blendEquation(32774),g=Kn,v=Kn),Ut)switch(J){case Oi:a.blendFuncSeparate(1,771,1,771);break;case Oo:a.blendFunc(1,1);break;case Uo:a.blendFuncSeparate(0,0,769,771);break;case Wo:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",J);break}else switch(J){case Oi:a.blendFuncSeparate(770,771,1,771);break;case Oo:a.blendFunc(770,1);break;case Uo:a.blendFunc(0,769);break;case Wo:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",J);break}y=null,m=null,_=null,x=null,f=J,w=Ut}return}At=At||yt,Ft=Ft||gt,Dt=Dt||Rt,(yt!==g||At!==v)&&(a.blendEquationSeparate(ot[yt],ot[At]),g=yt,v=At),(gt!==y||Rt!==m||Ft!==_||Dt!==x)&&(a.blendFuncSeparate(et[gt],et[Rt],et[Ft],et[Dt]),y=gt,m=Rt,_=Ft,x=Dt),f=J,w=null}function nt(J,yt){J.side===$n?I(2884):A(2884);let gt=J.side===ge;yt&&(gt=!gt),lt(gt),J.blending===Oi&&J.transparent===!1?k(bn):k(J.blending,J.blendEquation,J.blendSrc,J.blendDst,J.blendEquationAlpha,J.blendSrcAlpha,J.blendDstAlpha,J.premultipliedAlpha),l.setFunc(J.depthFunc),l.setTest(J.depthTest),l.setMask(J.depthWrite),o.setMask(J.colorWrite);const Rt=J.stencilWrite;h.setTest(Rt),Rt&&(h.setMask(J.stencilWriteMask),h.setFunc(J.stencilFunc,J.stencilRef,J.stencilFuncMask),h.setOp(J.stencilFail,J.stencilZFail,J.stencilZPass)),st(J.polygonOffset,J.polygonOffsetFactor,J.polygonOffsetUnits),J.alphaToCoverage===!0?A(32926):I(32926)}function lt(J){C!==J&&(J?a.frontFace(2304):a.frontFace(2305),C=J)}function $(J){J!==cc?(A(2884),J!==M&&(J===No?a.cullFace(1029):J===hc?a.cullFace(1028):a.cullFace(1032))):I(2884),M=J}function rt(J){J!==D&&(U&&a.lineWidth(J),D=J)}function st(J,yt,gt){J?(A(32823),(j!==yt||N!==gt)&&(a.polygonOffset(yt,gt),j=yt,N=gt)):I(32823)}function K(J){J?A(3089):I(3089)}function tt(J){J===void 0&&(J=33984+b-1),Y!==J&&(a.activeTexture(J),Y=J)}function Lt(J,yt){Y===null&&tt();let gt=Q[Y];gt===void 0&&(gt={type:void 0,texture:void 0},Q[Y]=gt),(gt.type!==J||gt.texture!==yt)&&(a.bindTexture(J,yt||Z[J]),gt.type=J,gt.texture=yt)}function St(){const J=Q[Y];J!==void 0&&J.type!==void 0&&(a.bindTexture(J.type,null),J.type=void 0,J.texture=void 0)}function zt(){try{a.compressedTexImage2D.apply(a,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Pt(){try{a.texSubImage2D.apply(a,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function L(){try{a.texStorage2D.apply(a,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function E(){try{a.texImage2D.apply(a,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function at(){try{a.texImage3D.apply(a,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function ht(J){it.equals(J)===!1&&(a.scissor(J.x,J.y,J.z,J.w),it.copy(J))}function bt(J){W.equals(J)===!1&&(a.viewport(J.x,J.y,J.z,J.w),W.copy(J))}function Ct(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),n===!0&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),u={},Y=null,Q={},c={},d=null,p=!1,f=null,g=null,y=null,m=null,v=null,_=null,x=null,w=!1,C=null,M=null,D=null,j=null,N=null,it.set(0,0,a.canvas.width,a.canvas.height),W.set(0,0,a.canvas.width,a.canvas.height),o.reset(),l.reset(),h.reset()}return{buffers:{color:o,depth:l,stencil:h},enable:A,disable:I,bindFramebuffer:R,useProgram:F,setBlending:k,setMaterial:nt,setFlipSided:lt,setCullFace:$,setLineWidth:rt,setPolygonOffset:st,setScissorTest:K,activeTexture:tt,bindTexture:Lt,unbindTexture:St,compressedTexImage2D:zt,texImage2D:E,texImage3D:at,texStorage2D:L,texSubImage2D:Pt,scissor:ht,viewport:bt,reset:Ct}}function gm(a,t,e,n,i,r,s){const o=i.isWebGL2,l=i.maxTextures,h=i.maxCubemapSize,u=i.maxTextureSize,c=i.maxSamples,p=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):void 0,f=new WeakMap;let g,y=!1;try{y=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(L,E){return y?new OffscreenCanvas(L,E):Mr("canvas")}function v(L,E,at,ht){let bt=1;if((L.width>ht||L.height>ht)&&(bt=ht/Math.max(L.width,L.height)),bt<1||E===!0)if(typeof HTMLImageElement!="undefined"&&L instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&L instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&L instanceof ImageBitmap){const Ct=E?Uh:Math.floor,J=Ct(bt*L.width),yt=Ct(bt*L.height);g===void 0&&(g=m(J,yt));const gt=at?m(J,yt):g;return gt.width=J,gt.height=yt,gt.getContext("2d").drawImage(L,0,0,J,yt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+L.width+"x"+L.height+") to ("+J+"x"+yt+")."),gt}else return"data"in L&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+L.width+"x"+L.height+")."),L;return L}function _(L){return ha(L.width)&&ha(L.height)}function x(L){return o?!1:L.wrapS!==He||L.wrapT!==He||L.minFilter!==_e&&L.minFilter!==Ze}function w(L,E){return L.generateMipmaps&&E&&L.minFilter!==_e&&L.minFilter!==Ze}function C(L){a.generateMipmap(L)}function M(L,E,at){if(o===!1)return E;if(L!==null){if(a[L]!==void 0)return a[L];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+L+"'")}let ht=E;return E===6403&&(at===5126&&(ht=33326),at===5131&&(ht=33325),at===5121&&(ht=33321)),E===6407&&(at===5126&&(ht=34837),at===5131&&(ht=34843),at===5121&&(ht=32849)),E===6408&&(at===5126&&(ht=34836),at===5131&&(ht=34842),at===5121&&(ht=32856)),(ht===33325||ht===33326||ht===34842||ht===34836)&&t.get("EXT_color_buffer_float"),ht}function D(L,E,at){return w(L,at)===!0?Math.log2(Math.max(E.width,E.height))+1:L.mipmaps.length>0?L.mipmaps.length:1}function j(L){return L===_e||L===Yo||L===Zo?9728:9729}function N(L){const E=L.target;E.removeEventListener("dispose",N),U(E),E.isVideoTexture&&f.delete(E),s.memory.textures--}function b(L){const E=L.target;E.removeEventListener("dispose",b),V(E)}function U(L){const E=n.get(L);E.__webglInit!==void 0&&(a.deleteTexture(E.__webglTexture),n.remove(L))}function V(L){const E=L.texture,at=n.get(L),ht=n.get(E);if(!!L){if(ht.__webglTexture!==void 0&&(a.deleteTexture(ht.__webglTexture),s.memory.textures--),L.depthTexture&&L.depthTexture.dispose(),L.isWebGLCubeRenderTarget)for(let bt=0;bt<6;bt++)a.deleteFramebuffer(at.__webglFramebuffer[bt]),at.__webglDepthbuffer&&a.deleteRenderbuffer(at.__webglDepthbuffer[bt]);else a.deleteFramebuffer(at.__webglFramebuffer),at.__webglDepthbuffer&&a.deleteRenderbuffer(at.__webglDepthbuffer),at.__webglMultisampledFramebuffer&&a.deleteFramebuffer(at.__webglMultisampledFramebuffer),at.__webglColorRenderbuffer&&a.deleteRenderbuffer(at.__webglColorRenderbuffer),at.__webglDepthRenderbuffer&&a.deleteRenderbuffer(at.__webglDepthRenderbuffer);if(L.isWebGLMultipleRenderTargets)for(let bt=0,Ct=E.length;bt<Ct;bt++){const J=n.get(E[bt]);J.__webglTexture&&(a.deleteTexture(J.__webglTexture),s.memory.textures--),n.remove(E[bt])}n.remove(E),n.remove(L)}}let H=0;function Y(){H=0}function Q(){const L=H;return L>=l&&console.warn("THREE.WebGLTextures: Trying to use "+L+" texture units while this GPU supports only "+l),H+=1,L}function P(L,E){const at=n.get(L);if(L.isVideoTexture&&tt(L),L.version>0&&at.__version!==L.version){const ht=L.image;if(ht===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(ht.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{R(at,L,E);return}}e.activeTexture(33984+E),e.bindTexture(3553,at.__webglTexture)}function z(L,E){const at=n.get(L);if(L.version>0&&at.__version!==L.version){R(at,L,E);return}e.activeTexture(33984+E),e.bindTexture(35866,at.__webglTexture)}function it(L,E){const at=n.get(L);if(L.version>0&&at.__version!==L.version){R(at,L,E);return}e.activeTexture(33984+E),e.bindTexture(32879,at.__webglTexture)}function W(L,E){const at=n.get(L);if(L.version>0&&at.__version!==L.version){F(at,L,E);return}e.activeTexture(33984+E),e.bindTexture(34067,at.__webglTexture)}const T={[ms]:10497,[He]:33071,[vs]:33648},Z={[_e]:9728,[Yo]:9984,[Zo]:9986,[Ze]:9729,[Vc]:9985,[mr]:9987};function A(L,E,at){if(at?(a.texParameteri(L,10242,T[E.wrapS]),a.texParameteri(L,10243,T[E.wrapT]),(L===32879||L===35866)&&a.texParameteri(L,32882,T[E.wrapR]),a.texParameteri(L,10240,Z[E.magFilter]),a.texParameteri(L,10241,Z[E.minFilter])):(a.texParameteri(L,10242,33071),a.texParameteri(L,10243,33071),(L===32879||L===35866)&&a.texParameteri(L,32882,33071),(E.wrapS!==He||E.wrapT!==He)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(L,10240,j(E.magFilter)),a.texParameteri(L,10241,j(E.minFilter)),E.minFilter!==_e&&E.minFilter!==Ze&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const ht=t.get("EXT_texture_filter_anisotropic");if(E.type===En&&t.has("OES_texture_float_linear")===!1||o===!1&&E.type===ti&&t.has("OES_texture_half_float_linear")===!1)return;(E.anisotropy>1||n.get(E).__currentAnisotropy)&&(a.texParameterf(L,ht.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(E.anisotropy,i.getMaxAnisotropy())),n.get(E).__currentAnisotropy=E.anisotropy)}}function I(L,E){L.__webglInit===void 0&&(L.__webglInit=!0,E.addEventListener("dispose",N),L.__webglTexture=a.createTexture(),s.memory.textures++)}function R(L,E,at){let ht=3553;E.isDataTexture2DArray&&(ht=35866),E.isDataTexture3D&&(ht=32879),I(L,E),e.activeTexture(33984+at),e.bindTexture(ht,L.__webglTexture),a.pixelStorei(37440,E.flipY),a.pixelStorei(37441,E.premultiplyAlpha),a.pixelStorei(3317,E.unpackAlignment),a.pixelStorei(37443,0);const bt=x(E)&&_(E.image)===!1,Ct=v(E.image,bt,!1,u),J=_(Ct)||o,yt=r.convert(E.format);let gt=r.convert(E.type),Rt=M(E.internalFormat,yt,gt,E.encoding);A(ht,E,J);let At;const Ft=E.mipmaps;if(E.isDepthTexture)Rt=6402,o?E.type===En?Rt=36012:E.type===vr?Rt=33190:E.type===ei?Rt=35056:Rt=33189:E.type===En&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),E.format===kn&&Rt===6402&&E.type!==Gi&&E.type!==vr&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),E.type=Gi,gt=r.convert(E.type)),E.format===ni&&Rt===6402&&(Rt=34041,E.type!==ei&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),E.type=ei,gt=r.convert(E.type))),e.texImage2D(3553,0,Rt,Ct.width,Ct.height,0,yt,gt,null);else if(E.isDataTexture)if(Ft.length>0&&J){for(let Dt=0,Ut=Ft.length;Dt<Ut;Dt++)At=Ft[Dt],e.texImage2D(3553,Dt,Rt,At.width,At.height,0,yt,gt,At.data);E.generateMipmaps=!1}else e.texImage2D(3553,0,Rt,Ct.width,Ct.height,0,yt,gt,Ct.data);else if(E.isCompressedTexture)for(let Dt=0,Ut=Ft.length;Dt<Ut;Dt++)At=Ft[Dt],E.format!==Ie&&E.format!==Hn?yt!==null?e.compressedTexImage2D(3553,Dt,Rt,At.width,At.height,0,At.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,Dt,Rt,At.width,At.height,0,yt,gt,At.data);else if(E.isDataTexture2DArray)e.texImage3D(35866,0,Rt,Ct.width,Ct.height,Ct.depth,0,yt,gt,Ct.data);else if(E.isDataTexture3D)e.texImage3D(32879,0,Rt,Ct.width,Ct.height,Ct.depth,0,yt,gt,Ct.data);else{const Dt=D(E,Ct,J),Ut=o&&E.isVideoTexture!==!0,Jt=L.__version===void 0;if(Ft.length>0&&J){Ut&&Jt&&e.texStorage2D(3553,Dt,Rt,Ft[0].width,Ft[0].height);for(let Yt=0,he=Ft.length;Yt<he;Yt++)At=Ft[Yt],Ut?e.texSubImage2D(3553,Yt,0,0,yt,gt,At):e.texImage2D(3553,Yt,Rt,yt,gt,At);E.generateMipmaps=!1}else Ut?(Jt&&e.texStorage2D(3553,Dt,Rt,Ct.width,Ct.height),e.texSubImage2D(3553,0,0,0,yt,gt,Ct)):e.texImage2D(3553,0,Rt,yt,gt,Ct)}w(E,J)&&C(ht),L.__version=E.version,E.onUpdate&&E.onUpdate(E)}function F(L,E,at){if(E.image.length!==6)return;I(L,E),e.activeTexture(33984+at),e.bindTexture(34067,L.__webglTexture),a.pixelStorei(37440,E.flipY),a.pixelStorei(37441,E.premultiplyAlpha),a.pixelStorei(3317,E.unpackAlignment),a.pixelStorei(37443,0);const ht=E&&(E.isCompressedTexture||E.image[0].isCompressedTexture),bt=E.image[0]&&E.image[0].isDataTexture,Ct=[];for(let Dt=0;Dt<6;Dt++)!ht&&!bt?Ct[Dt]=v(E.image[Dt],!1,!0,h):Ct[Dt]=bt?E.image[Dt].image:E.image[Dt];const J=Ct[0],yt=_(J)||o,gt=r.convert(E.format),Rt=r.convert(E.type),At=M(E.internalFormat,gt,Rt,E.encoding);A(34067,E,yt);let Ft;if(ht)for(let Dt=0;Dt<6;Dt++){Ft=Ct[Dt].mipmaps;for(let Ut=0;Ut<Ft.length;Ut++){const Jt=Ft[Ut];E.format!==Ie&&E.format!==Hn?gt!==null?e.compressedTexImage2D(34069+Dt,Ut,At,Jt.width,Jt.height,0,Jt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+Dt,Ut,At,Jt.width,Jt.height,0,gt,Rt,Jt.data)}}else{Ft=E.mipmaps;for(let Dt=0;Dt<6;Dt++)if(bt){e.texImage2D(34069+Dt,0,At,Ct[Dt].width,Ct[Dt].height,0,gt,Rt,Ct[Dt].data);for(let Ut=0;Ut<Ft.length;Ut++){const Yt=Ft[Ut].image[Dt].image;e.texImage2D(34069+Dt,Ut+1,At,Yt.width,Yt.height,0,gt,Rt,Yt.data)}}else{e.texImage2D(34069+Dt,0,At,gt,Rt,Ct[Dt]);for(let Ut=0;Ut<Ft.length;Ut++){const Jt=Ft[Ut];e.texImage2D(34069+Dt,Ut+1,At,gt,Rt,Jt.image[Dt])}}}w(E,yt)&&C(34067),L.__version=E.version,E.onUpdate&&E.onUpdate(E)}function ot(L,E,at,ht,bt){const Ct=r.convert(at.format),J=r.convert(at.type),yt=M(at.internalFormat,Ct,J,at.encoding);n.get(E).__hasExternalTextures||(bt===32879||bt===35866?e.texImage3D(bt,0,yt,E.width,E.height,E.depth,0,Ct,J,null):e.texImage2D(bt,0,yt,E.width,E.height,0,Ct,J,null)),e.bindFramebuffer(36160,L),E.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,ht,bt,n.get(at).__webglTexture,0,K(E)):a.framebufferTexture2D(36160,ht,bt,n.get(at).__webglTexture,0),e.bindFramebuffer(36160,null)}function et(L,E,at){if(a.bindRenderbuffer(36161,L),E.depthBuffer&&!E.stencilBuffer){let ht=33189;if(at||E.useRenderToTexture){const bt=E.depthTexture;bt&&bt.isDepthTexture&&(bt.type===En?ht=36012:bt.type===vr&&(ht=33190));const Ct=K(E);E.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,Ct,ht,E.width,E.height):a.renderbufferStorageMultisample(36161,Ct,ht,E.width,E.height)}else a.renderbufferStorage(36161,ht,E.width,E.height);a.framebufferRenderbuffer(36160,36096,36161,L)}else if(E.depthBuffer&&E.stencilBuffer){const ht=K(E);at&&E.useRenderbuffer?a.renderbufferStorageMultisample(36161,ht,35056,E.width,E.height):E.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,ht,35056,E.width,E.height):a.renderbufferStorage(36161,34041,E.width,E.height),a.framebufferRenderbuffer(36160,33306,36161,L)}else{const ht=E.isWebGLMultipleRenderTargets===!0?E.texture[0]:E.texture,bt=r.convert(ht.format),Ct=r.convert(ht.type),J=M(ht.internalFormat,bt,Ct,ht.encoding),yt=K(E);at&&E.useRenderbuffer?a.renderbufferStorageMultisample(36161,yt,J,E.width,E.height):E.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,yt,J,E.width,E.height):a.renderbufferStorage(36161,J,E.width,E.height)}a.bindRenderbuffer(36161,null)}function k(L,E){if(E&&E.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,L),!(E.depthTexture&&E.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(E.depthTexture).__webglTexture||E.depthTexture.image.width!==E.width||E.depthTexture.image.height!==E.height)&&(E.depthTexture.image.width=E.width,E.depthTexture.image.height=E.height,E.depthTexture.needsUpdate=!0),P(E.depthTexture,0);const ht=n.get(E.depthTexture).__webglTexture,bt=K(E);if(E.depthTexture.format===kn)E.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,36096,3553,ht,0,bt):a.framebufferTexture2D(36160,36096,3553,ht,0);else if(E.depthTexture.format===ni)E.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,33306,3553,ht,0,bt):a.framebufferTexture2D(36160,33306,3553,ht,0);else throw new Error("Unknown depthTexture format")}function nt(L){const E=n.get(L),at=L.isWebGLCubeRenderTarget===!0;if(L.depthTexture&&!E.__autoAllocateDepthBuffer){if(at)throw new Error("target.depthTexture not supported in Cube render targets");k(E.__webglFramebuffer,L)}else if(at){E.__webglDepthbuffer=[];for(let ht=0;ht<6;ht++)e.bindFramebuffer(36160,E.__webglFramebuffer[ht]),E.__webglDepthbuffer[ht]=a.createRenderbuffer(),et(E.__webglDepthbuffer[ht],L,!1)}else e.bindFramebuffer(36160,E.__webglFramebuffer),E.__webglDepthbuffer=a.createRenderbuffer(),et(E.__webglDepthbuffer,L,!1);e.bindFramebuffer(36160,null)}function lt(L,E,at){const ht=n.get(L);E!==void 0&&ot(ht.__webglFramebuffer,L,L.texture,36064,3553),at!==void 0&&nt(L)}function $(L){const E=L.texture,at=n.get(L),ht=n.get(E);L.addEventListener("dispose",b),L.isWebGLMultipleRenderTargets!==!0&&(ht.__webglTexture===void 0&&(ht.__webglTexture=a.createTexture()),ht.__version=E.version,s.memory.textures++);const bt=L.isWebGLCubeRenderTarget===!0,Ct=L.isWebGLMultipleRenderTargets===!0,J=E.isDataTexture3D||E.isDataTexture2DArray,yt=_(L)||o;if(o&&E.format===Hn&&(E.type===En||E.type===ti)&&(E.format=Ie,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),bt){at.__webglFramebuffer=[];for(let gt=0;gt<6;gt++)at.__webglFramebuffer[gt]=a.createFramebuffer()}else if(at.__webglFramebuffer=a.createFramebuffer(),Ct)if(i.drawBuffers){const gt=L.texture;for(let Rt=0,At=gt.length;Rt<At;Rt++){const Ft=n.get(gt[Rt]);Ft.__webglTexture===void 0&&(Ft.__webglTexture=a.createTexture(),s.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(L.useRenderbuffer)if(o){at.__webglMultisampledFramebuffer=a.createFramebuffer(),at.__webglColorRenderbuffer=a.createRenderbuffer(),a.bindRenderbuffer(36161,at.__webglColorRenderbuffer);const gt=r.convert(E.format),Rt=r.convert(E.type),At=M(E.internalFormat,gt,Rt,E.encoding),Ft=K(L);a.renderbufferStorageMultisample(36161,Ft,At,L.width,L.height),e.bindFramebuffer(36160,at.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064,36161,at.__webglColorRenderbuffer),a.bindRenderbuffer(36161,null),L.depthBuffer&&(at.__webglDepthRenderbuffer=a.createRenderbuffer(),et(at.__webglDepthRenderbuffer,L,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(bt){e.bindTexture(34067,ht.__webglTexture),A(34067,E,yt);for(let gt=0;gt<6;gt++)ot(at.__webglFramebuffer[gt],L,E,36064,34069+gt);w(E,yt)&&C(34067),e.unbindTexture()}else if(Ct){const gt=L.texture;for(let Rt=0,At=gt.length;Rt<At;Rt++){const Ft=gt[Rt],Dt=n.get(Ft);e.bindTexture(3553,Dt.__webglTexture),A(3553,Ft,yt),ot(at.__webglFramebuffer,L,Ft,36064+Rt,3553),w(Ft,yt)&&C(3553)}e.unbindTexture()}else{let gt=3553;J&&(o?gt=E.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(gt,ht.__webglTexture),A(gt,E,yt),ot(at.__webglFramebuffer,L,E,36064,gt),w(E,yt)&&C(gt),e.unbindTexture()}L.depthBuffer&&nt(L)}function rt(L){const E=_(L)||o,at=L.isWebGLMultipleRenderTargets===!0?L.texture:[L.texture];for(let ht=0,bt=at.length;ht<bt;ht++){const Ct=at[ht];if(w(Ct,E)){const J=L.isWebGLCubeRenderTarget?34067:3553,yt=n.get(Ct).__webglTexture;e.bindTexture(J,yt),C(J),e.unbindTexture()}}}function st(L){if(L.useRenderbuffer)if(o){const E=L.width,at=L.height;let ht=16384;const bt=[36064],Ct=L.stencilBuffer?33306:36096;L.depthBuffer&&bt.push(Ct),L.ignoreDepthForMultisampleCopy||(L.depthBuffer&&(ht|=256),L.stencilBuffer&&(ht|=1024));const J=n.get(L);e.bindFramebuffer(36008,J.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,J.__webglFramebuffer),L.ignoreDepthForMultisampleCopy&&(a.invalidateFramebuffer(36008,[Ct]),a.invalidateFramebuffer(36009,[Ct])),a.blitFramebuffer(0,0,E,at,0,0,E,at,ht,9728),a.invalidateFramebuffer(36008,bt),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,J.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function K(L){return o&&(L.useRenderbuffer||L.useRenderToTexture)?Math.min(c,L.samples):0}function tt(L){const E=s.render.frame;f.get(L)!==E&&(f.set(L,E),L.update())}let Lt=!1,St=!1;function zt(L,E){L&&L.isWebGLRenderTarget&&(Lt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Lt=!0),L=L.texture),P(L,E)}function Pt(L,E){L&&L.isWebGLCubeRenderTarget&&(St===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),St=!0),L=L.texture),W(L,E)}this.allocateTextureUnit=Q,this.resetTextureUnits=Y,this.setTexture2D=P,this.setTexture2DArray=z,this.setTexture3D=it,this.setTextureCube=W,this.rebindTextures=lt,this.setupRenderTarget=$,this.updateRenderTargetMipmap=rt,this.updateMultisampleRenderTarget=st,this.setupDepthRenderbuffer=nt,this.setupFrameBufferTexture=ot,this.safeSetTexture2D=zt,this.safeSetTextureCube=Pt}function ym(a,t,e){const n=e.isWebGL2;function i(r){let s;if(r===Sn)return 5121;if(r===Gc)return 32819;if(r===Hc)return 32820;if(r===kc)return 33635;if(r===Oc)return 5120;if(r===Uc)return 5122;if(r===Gi)return 5123;if(r===Wc)return 5124;if(r===vr)return 5125;if(r===En)return 5126;if(r===ti)return n?5131:(s=t.get("OES_texture_half_float"),s!==null?s.HALF_FLOAT_OES:null);if(r===qc)return 6406;if(r===Hn)return 6407;if(r===Ie)return 6408;if(r===Xc)return 6409;if(r===Yc)return 6410;if(r===kn)return 6402;if(r===ni)return 34041;if(r===jc)return 6403;if(r===Jc)return 36244;if(r===Qc)return 33319;if(r===$c)return 33320;if(r===Kc)return 36248;if(r===th)return 36249;if(r===jo||r===Jo||r===Qo||r===$o)if(s=t.get("WEBGL_compressed_texture_s3tc"),s!==null){if(r===jo)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Jo)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===Qo)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===$o)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===Ko||r===ta||r===ea||r===na)if(s=t.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(r===Ko)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===ta)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===ea)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===na)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===eh)return s=t.get("WEBGL_compressed_texture_etc1"),s!==null?s.COMPRESSED_RGB_ETC1_WEBGL:null;if((r===ia||r===ra)&&(s=t.get("WEBGL_compressed_texture_etc"),s!==null)){if(r===ia)return s.COMPRESSED_RGB8_ETC2;if(r===ra)return s.COMPRESSED_RGBA8_ETC2_EAC}if(r===nh||r===ih||r===rh||r===sh||r===oh||r===ah||r===lh||r===ch||r===hh||r===uh||r===dh||r===ph||r===fh||r===mh||r===gh||r===yh||r===xh||r===_h||r===wh||r===Mh||r===bh||r===Sh||r===Eh||r===Th||r===Ah||r===Ch||r===Rh||r===Lh)return s=t.get("WEBGL_compressed_texture_astc"),s!==null?r:null;if(r===vh)return s=t.get("EXT_texture_compression_bptc"),s!==null?r:null;if(r===ei)return n?34042:(s=t.get("WEBGL_depth_texture"),s!==null?s.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}class ul extends Ue{constructor(t=[]){super();this.cameras=t}}ul.prototype.isArrayCamera=!0;class Qi extends Qt{constructor(){super();this.type="Group"}}Qi.prototype.isGroup=!0;const xm={type:"move"};class ao{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Qi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Qi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new G,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new G),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Qi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new G,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new G),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,s=null;const o=this._targetRay,l=this._grip,h=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(o!==null&&(i=e.getPose(t.targetRaySpace,n),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(xm))),h&&t.hand){s=!0;for(const g of t.hand.values()){const y=e.getJointPose(g,n);if(h.joints[g.jointName]===void 0){const v=new Qi;v.matrixAutoUpdate=!1,v.visible=!1,h.joints[g.jointName]=v,h.add(v)}const m=h.joints[g.jointName];y!==null&&(m.matrix.fromArray(y.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.jointRadius=y.radius),m.visible=y!==null}const u=h.joints["index-finger-tip"],c=h.joints["thumb-tip"],d=u.position.distanceTo(c.position),p=.02,f=.005;h.inputState.pinching&&d>p+f?(h.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!h.inputState.pinching&&d<=p-f&&(h.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=r!==null),h!==null&&(h.visible=s!==null),this}}class lo extends Te{constructor(t,e,n,i,r,s,o,l,h,u){if(u=u!==void 0?u:kn,u!==kn&&u!==ni)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===kn&&(n=Gi),n===void 0&&u===ni&&(n=ei);super(null,i,r,s,o,l,u,n,h);this.image={width:t,height:e},this.magFilter=o!==void 0?o:_e,this.minFilter=l!==void 0?l:_e,this.flipY=!1,this.generateMipmaps=!1}}lo.prototype.isDepthTexture=!0;class _m extends qn{constructor(t,e){super();const n=this;let i=null,r=1,s=null,o="local-floor";const l=t.extensions.has("WEBGL_multisampled_render_to_texture");let h=null,u=null,c=null,d=null,p=!1,f=null;const g=e.getContextAttributes();let y=null,m=null;const v=[],_=new Map,x=new Ue;x.layers.enable(1),x.viewport=new ee;const w=new Ue;w.layers.enable(2),w.viewport=new ee;const C=[x,w],M=new ul;M.layers.enable(1),M.layers.enable(2);let D=null,j=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(W){let T=v[W];return T===void 0&&(T=new ao,v[W]=T),T.getTargetRaySpace()},this.getControllerGrip=function(W){let T=v[W];return T===void 0&&(T=new ao,v[W]=T),T.getGripSpace()},this.getHand=function(W){let T=v[W];return T===void 0&&(T=new ao,v[W]=T),T.getHandSpace()};function N(W){const T=_.get(W.inputSource);T&&T.dispatchEvent({type:W.type,data:W.inputSource})}function b(){_.forEach(function(W,T){W.disconnect(T)}),_.clear(),D=null,j=null,t.setRenderTarget(y),d=null,c=null,u=null,i=null,m=null,it.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(W){r=W,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(W){o=W,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getBaseLayer=function(){return c!==null?c:d},this.getBinding=function(){return u},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(W){if(i=W,i!==null){if(y=t.getRenderTarget(),i.addEventListener("select",N),i.addEventListener("selectstart",N),i.addEventListener("selectend",N),i.addEventListener("squeeze",N),i.addEventListener("squeezestart",N),i.addEventListener("squeezeend",N),i.addEventListener("end",b),i.addEventListener("inputsourceschange",U),g.xrCompatible!==!0&&await e.makeXRCompatible(),i.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const T={antialias:i.renderState.layers===void 0?g.antialias:!0,alpha:g.alpha,depth:g.depth,stencil:g.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,e,T),i.updateRenderState({baseLayer:d}),m=new je(d.framebufferWidth,d.framebufferHeight)}else{p=g.antialias;let T=null,Z=null,A=null;g.depth&&(A=g.stencil?35056:33189,T=g.stencil?ni:kn,Z=g.stencil?ei:Gi);const I={colorFormat:g.alpha||p?32856:32849,depthFormat:A,scaleFactor:r};u=new XRWebGLBinding(i,e),c=u.createProjectionLayer(I),i.updateRenderState({layers:[c]}),p?m=new Ts(c.textureWidth,c.textureHeight,{format:Ie,type:Sn,depthTexture:new lo(c.textureWidth,c.textureHeight,Z,void 0,void 0,void 0,void 0,void 0,void 0,T),stencilBuffer:g.stencil,ignoreDepth:c.ignoreDepthValues,useRenderToTexture:l}):m=new je(c.textureWidth,c.textureHeight,{format:g.alpha?Ie:Hn,type:Sn,depthTexture:new lo(c.textureWidth,c.textureHeight,Z,void 0,void 0,void 0,void 0,void 0,void 0,T),stencilBuffer:g.stencil,ignoreDepth:c.ignoreDepthValues})}this.setFoveation(0),s=await i.requestReferenceSpace(o),it.setContext(i),it.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function U(W){const T=i.inputSources;for(let Z=0;Z<v.length;Z++)_.set(T[Z],v[Z]);for(let Z=0;Z<W.removed.length;Z++){const A=W.removed[Z],I=_.get(A);I&&(I.dispatchEvent({type:"disconnected",data:A}),_.delete(A))}for(let Z=0;Z<W.added.length;Z++){const A=W.added[Z],I=_.get(A);I&&I.dispatchEvent({type:"connected",data:A})}}const V=new G,H=new G;function Y(W,T,Z){V.setFromMatrixPosition(T.matrixWorld),H.setFromMatrixPosition(Z.matrixWorld);const A=V.distanceTo(H),I=T.projectionMatrix.elements,R=Z.projectionMatrix.elements,F=I[14]/(I[10]-1),ot=I[14]/(I[10]+1),et=(I[9]+1)/I[5],k=(I[9]-1)/I[5],nt=(I[8]-1)/I[0],lt=(R[8]+1)/R[0],$=F*nt,rt=F*lt,st=A/(-nt+lt),K=st*-nt;T.matrixWorld.decompose(W.position,W.quaternion,W.scale),W.translateX(K),W.translateZ(st),W.matrixWorld.compose(W.position,W.quaternion,W.scale),W.matrixWorldInverse.copy(W.matrixWorld).invert();const tt=F+st,Lt=ot+st,St=$-K,zt=rt+(A-K),Pt=et*ot/Lt*tt,L=k*ot/Lt*tt;W.projectionMatrix.makePerspective(St,zt,Pt,L,tt,Lt)}function Q(W,T){T===null?W.matrixWorld.copy(W.matrix):W.matrixWorld.multiplyMatrices(T.matrixWorld,W.matrix),W.matrixWorldInverse.copy(W.matrixWorld).invert()}this.updateCamera=function(W){if(i===null)return;M.near=w.near=x.near=W.near,M.far=w.far=x.far=W.far,(D!==M.near||j!==M.far)&&(i.updateRenderState({depthNear:M.near,depthFar:M.far}),D=M.near,j=M.far);const T=W.parent,Z=M.cameras;Q(M,T);for(let I=0;I<Z.length;I++)Q(Z[I],T);M.matrixWorld.decompose(M.position,M.quaternion,M.scale),W.position.copy(M.position),W.quaternion.copy(M.quaternion),W.scale.copy(M.scale),W.matrix.copy(M.matrix),W.matrixWorld.copy(M.matrixWorld);const A=W.children;for(let I=0,R=A.length;I<R;I++)A[I].updateMatrixWorld(!0);Z.length===2?Y(M,x,w):M.projectionMatrix.copy(x.projectionMatrix)},this.getCamera=function(){return M},this.getFoveation=function(){if(c!==null)return c.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(W){c!==null&&(c.fixedFoveation=W),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=W)};let P=null;function z(W,T){if(h=T.getViewerPose(s),f=T,h!==null){const A=h.views;d!==null&&(t.setRenderTargetFramebuffer(m,d.framebuffer),t.setRenderTarget(m));let I=!1;A.length!==M.cameras.length&&(M.cameras.length=0,I=!0);for(let R=0;R<A.length;R++){const F=A[R];let ot=null;if(d!==null)ot=d.getViewport(F);else{const k=u.getViewSubImage(c,F);ot=k.viewport,R===0&&(t.setRenderTargetTextures(m,k.colorTexture,c.ignoreDepthValues?void 0:k.depthStencilTexture),t.setRenderTarget(m))}const et=C[R];et.matrix.fromArray(F.transform.matrix),et.projectionMatrix.fromArray(F.projectionMatrix),et.viewport.set(ot.x,ot.y,ot.width,ot.height),R===0&&M.matrix.copy(et.matrix),I===!0&&M.cameras.push(et)}}const Z=i.inputSources;for(let A=0;A<v.length;A++){const I=v[A],R=Z[A];I.update(R,T,s)}P&&P(W,T),f=null}const it=new Ca;it.setAnimationLoop(z),this.setAnimationLoop=function(W){P=W},this.dispose=function(){}}}function wm(a){function t(m,v){m.fogColor.value.copy(v.color),v.isFog?(m.fogNear.value=v.near,m.fogFar.value=v.far):v.isFogExp2&&(m.fogDensity.value=v.density)}function e(m,v,_,x,w){v.isMeshBasicMaterial?n(m,v):v.isMeshLambertMaterial?(n(m,v),l(m,v)):v.isMeshToonMaterial?(n(m,v),u(m,v)):v.isMeshPhongMaterial?(n(m,v),h(m,v)):v.isMeshStandardMaterial?(n(m,v),v.isMeshPhysicalMaterial?d(m,v,w):c(m,v)):v.isMeshMatcapMaterial?(n(m,v),p(m,v)):v.isMeshDepthMaterial?(n(m,v),f(m,v)):v.isMeshDistanceMaterial?(n(m,v),g(m,v)):v.isMeshNormalMaterial?(n(m,v),y(m,v)):v.isLineBasicMaterial?(i(m,v),v.isLineDashedMaterial&&r(m,v)):v.isPointsMaterial?s(m,v,_,x):v.isSpriteMaterial?o(m,v):v.isShadowMaterial?(m.color.value.copy(v.color),m.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function n(m,v){m.opacity.value=v.opacity,v.color&&m.diffuse.value.copy(v.color),v.emissive&&m.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(m.map.value=v.map),v.alphaMap&&(m.alphaMap.value=v.alphaMap),v.specularMap&&(m.specularMap.value=v.specularMap),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);const _=a.get(v).envMap;_&&(m.envMap.value=_,m.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=v.reflectivity,m.ior.value=v.ior,m.refractionRatio.value=v.refractionRatio),v.lightMap&&(m.lightMap.value=v.lightMap,m.lightMapIntensity.value=v.lightMapIntensity),v.aoMap&&(m.aoMap.value=v.aoMap,m.aoMapIntensity.value=v.aoMapIntensity);let x;v.map?x=v.map:v.specularMap?x=v.specularMap:v.displacementMap?x=v.displacementMap:v.normalMap?x=v.normalMap:v.bumpMap?x=v.bumpMap:v.roughnessMap?x=v.roughnessMap:v.metalnessMap?x=v.metalnessMap:v.alphaMap?x=v.alphaMap:v.emissiveMap?x=v.emissiveMap:v.clearcoatMap?x=v.clearcoatMap:v.clearcoatNormalMap?x=v.clearcoatNormalMap:v.clearcoatRoughnessMap?x=v.clearcoatRoughnessMap:v.specularIntensityMap?x=v.specularIntensityMap:v.specularColorMap?x=v.specularColorMap:v.transmissionMap?x=v.transmissionMap:v.thicknessMap?x=v.thicknessMap:v.sheenColorMap?x=v.sheenColorMap:v.sheenRoughnessMap&&(x=v.sheenRoughnessMap),x!==void 0&&(x.isWebGLRenderTarget&&(x=x.texture),x.matrixAutoUpdate===!0&&x.updateMatrix(),m.uvTransform.value.copy(x.matrix));let w;v.aoMap?w=v.aoMap:v.lightMap&&(w=v.lightMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),m.uv2Transform.value.copy(w.matrix))}function i(m,v){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity}function r(m,v){m.dashSize.value=v.dashSize,m.totalSize.value=v.dashSize+v.gapSize,m.scale.value=v.scale}function s(m,v,_,x){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,m.size.value=v.size*_,m.scale.value=x*.5,v.map&&(m.map.value=v.map),v.alphaMap&&(m.alphaMap.value=v.alphaMap),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);let w;v.map?w=v.map:v.alphaMap&&(w=v.alphaMap),w!==void 0&&(w.matrixAutoUpdate===!0&&w.updateMatrix(),m.uvTransform.value.copy(w.matrix))}function o(m,v){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,m.rotation.value=v.rotation,v.map&&(m.map.value=v.map),v.alphaMap&&(m.alphaMap.value=v.alphaMap),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);let _;v.map?_=v.map:v.alphaMap&&(_=v.alphaMap),_!==void 0&&(_.matrixAutoUpdate===!0&&_.updateMatrix(),m.uvTransform.value.copy(_.matrix))}function l(m,v){v.emissiveMap&&(m.emissiveMap.value=v.emissiveMap)}function h(m,v){m.specular.value.copy(v.specular),m.shininess.value=Math.max(v.shininess,1e-4),v.emissiveMap&&(m.emissiveMap.value=v.emissiveMap),v.bumpMap&&(m.bumpMap.value=v.bumpMap,m.bumpScale.value=v.bumpScale,v.side===ge&&(m.bumpScale.value*=-1)),v.normalMap&&(m.normalMap.value=v.normalMap,m.normalScale.value.copy(v.normalScale),v.side===ge&&m.normalScale.value.negate()),v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias)}function u(m,v){v.gradientMap&&(m.gradientMap.value=v.gradientMap),v.emissiveMap&&(m.emissiveMap.value=v.emissiveMap),v.bumpMap&&(m.bumpMap.value=v.bumpMap,m.bumpScale.value=v.bumpScale,v.side===ge&&(m.bumpScale.value*=-1)),v.normalMap&&(m.normalMap.value=v.normalMap,m.normalScale.value.copy(v.normalScale),v.side===ge&&m.normalScale.value.negate()),v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias)}function c(m,v){m.roughness.value=v.roughness,m.metalness.value=v.metalness,v.roughnessMap&&(m.roughnessMap.value=v.roughnessMap),v.metalnessMap&&(m.metalnessMap.value=v.metalnessMap),v.emissiveMap&&(m.emissiveMap.value=v.emissiveMap),v.bumpMap&&(m.bumpMap.value=v.bumpMap,m.bumpScale.value=v.bumpScale,v.side===ge&&(m.bumpScale.value*=-1)),v.normalMap&&(m.normalMap.value=v.normalMap,m.normalScale.value.copy(v.normalScale),v.side===ge&&m.normalScale.value.negate()),v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias),a.get(v).envMap&&(m.envMapIntensity.value=v.envMapIntensity)}function d(m,v,_){c(m,v),m.ior.value=v.ior,v.sheen>0&&(m.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),m.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(m.sheenColorMap.value=v.sheenColorMap),v.sheenRoughnessMap&&(m.sheenRoughnessMap.value=v.sheenRoughnessMap)),v.clearcoat>0&&(m.clearcoat.value=v.clearcoat,m.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(m.clearcoatMap.value=v.clearcoatMap),v.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap),v.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),m.clearcoatNormalMap.value=v.clearcoatNormalMap,v.side===ge&&m.clearcoatNormalScale.value.negate())),v.transmission>0&&(m.transmission.value=v.transmission,m.transmissionSamplerMap.value=_.texture,m.transmissionSamplerSize.value.set(_.width,_.height),v.transmissionMap&&(m.transmissionMap.value=v.transmissionMap),m.thickness.value=v.thickness,v.thicknessMap&&(m.thicknessMap.value=v.thicknessMap),m.attenuationDistance.value=v.attenuationDistance,m.attenuationColor.value.copy(v.attenuationColor)),m.specularIntensity.value=v.specularIntensity,m.specularColor.value.copy(v.specularColor),v.specularIntensityMap&&(m.specularIntensityMap.value=v.specularIntensityMap),v.specularColorMap&&(m.specularColorMap.value=v.specularColorMap)}function p(m,v){v.matcap&&(m.matcap.value=v.matcap),v.bumpMap&&(m.bumpMap.value=v.bumpMap,m.bumpScale.value=v.bumpScale,v.side===ge&&(m.bumpScale.value*=-1)),v.normalMap&&(m.normalMap.value=v.normalMap,m.normalScale.value.copy(v.normalScale),v.side===ge&&m.normalScale.value.negate()),v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias)}function f(m,v){v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias)}function g(m,v){v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias),m.referencePosition.value.copy(v.referencePosition),m.nearDistance.value=v.nearDistance,m.farDistance.value=v.farDistance}function y(m,v){v.bumpMap&&(m.bumpMap.value=v.bumpMap,m.bumpScale.value=v.bumpScale,v.side===ge&&(m.bumpScale.value*=-1)),v.normalMap&&(m.normalMap.value=v.normalMap,m.normalScale.value.copy(v.normalScale),v.side===ge&&m.normalScale.value.negate()),v.displacementMap&&(m.displacementMap.value=v.displacementMap,m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function Mm(){const a=Mr("canvas");return a.style.display="block",a}function Kt(a={}){const t=a.canvas!==void 0?a.canvas:Mm(),e=a.context!==void 0?a.context:null,n=a.alpha!==void 0?a.alpha:!1,i=a.depth!==void 0?a.depth:!0,r=a.stencil!==void 0?a.stencil:!0,s=a.antialias!==void 0?a.antialias:!1,o=a.premultipliedAlpha!==void 0?a.premultipliedAlpha:!0,l=a.preserveDrawingBuffer!==void 0?a.preserveDrawingBuffer:!1,h=a.powerPreference!==void 0?a.powerPreference:"default",u=a.failIfMajorPerformanceCaveat!==void 0?a.failIfMajorPerformanceCaveat:!1;let c=null,d=null;const p=[],f=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=ze,this.physicallyCorrectLights=!1,this.toneMapping=Gn,this.toneMappingExposure=1;const g=this;let y=!1,m=0,v=0,_=null,x=-1,w=null;const C=new ee,M=new ee;let D=null,j=t.width,N=t.height,b=1,U=null,V=null;const H=new ee(0,0,j,N),Y=new ee(0,0,j,N);let Q=!1;const P=[],z=new Wr;let it=!1,W=!1,T=null;const Z=new Wt,A=new G,I={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function R(){return _===null?b:1}let F=e;function ot(S,O){for(let q=0;q<S.length;q++){const X=S[q],B=t.getContext(X,O);if(B!==null)return B}return null}try{const S={alpha:n,depth:i,stencil:r,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:h,failIfMajorPerformanceCaveat:u};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${hs}`),t.addEventListener("webglcontextlost",Dt,!1),t.addEventListener("webglcontextrestored",Ut,!1),F===null){const O=["webgl2","webgl","experimental-webgl"];if(g.isWebGL1Renderer===!0&&O.shift(),F=ot(O,S),F===null)throw ot(O)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}F.getShaderPrecisionFormat===void 0&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(S){throw console.error("THREE.WebGLRenderer: "+S.message),S}let et,k,nt,lt,$,rt,st,K,tt,Lt,St,zt,Pt,L,E,at,ht,bt,Ct,J,yt,gt,Rt;function At(){et=new kp(F),k=new Np(F,et,a),et.init(k),gt=new ym(F,et,k),nt=new vm(F,et,k),P[0]=1029,lt=new Yp(F),$=new sm,rt=new gm(F,et,nt,$,k,gt,lt),st=new Vp(g),K=new Hp(g),tt=new ou(F,k),Rt=new Fp(F,et,tt,k),Lt=new qp(F,tt,lt,Rt),St=new Qp(F,Lt,tt,lt),Ct=new Jp(F,k,rt),at=new zp($),zt=new rm(g,st,K,et,k,Rt,at),Pt=new wm($),L=new am($),E=new pm(et,k),bt=new Bp(g,st,nt,St,o),ht=new hl(g,St,k),J=new Dp(F,et,lt,k),yt=new Xp(F,et,lt,k),lt.programs=zt.programs,g.capabilities=k,g.extensions=et,g.properties=$,g.renderLists=L,g.shadowMap=ht,g.state=nt,g.info=lt}At();const Ft=new _m(g,F);this.xr=Ft,this.getContext=function(){return F},this.getContextAttributes=function(){return F.getContextAttributes()},this.forceContextLoss=function(){const S=et.get("WEBGL_lose_context");S&&S.loseContext()},this.forceContextRestore=function(){const S=et.get("WEBGL_lose_context");S&&S.restoreContext()},this.getPixelRatio=function(){return b},this.setPixelRatio=function(S){S!==void 0&&(b=S,this.setSize(j,N,!1))},this.getSize=function(S){return S.set(j,N)},this.setSize=function(S,O,q){if(Ft.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}j=S,N=O,t.width=Math.floor(S*b),t.height=Math.floor(O*b),q!==!1&&(t.style.width=S+"px",t.style.height=O+"px"),this.setViewport(0,0,S,O)},this.getDrawingBufferSize=function(S){return S.set(j*b,N*b).floor()},this.setDrawingBufferSize=function(S,O,q){j=S,N=O,b=q,t.width=Math.floor(S*q),t.height=Math.floor(O*q),this.setViewport(0,0,S,O)},this.getCurrentViewport=function(S){return S.copy(C)},this.getViewport=function(S){return S.copy(H)},this.setViewport=function(S,O,q,X){S.isVector4?H.set(S.x,S.y,S.z,S.w):H.set(S,O,q,X),nt.viewport(C.copy(H).multiplyScalar(b).floor())},this.getScissor=function(S){return S.copy(Y)},this.setScissor=function(S,O,q,X){S.isVector4?Y.set(S.x,S.y,S.z,S.w):Y.set(S,O,q,X),nt.scissor(M.copy(Y).multiplyScalar(b).floor())},this.getScissorTest=function(){return Q},this.setScissorTest=function(S){nt.setScissorTest(Q=S)},this.setOpaqueSort=function(S){U=S},this.setTransparentSort=function(S){V=S},this.getClearColor=function(S){return S.copy(bt.getClearColor())},this.setClearColor=function(){bt.setClearColor.apply(bt,arguments)},this.getClearAlpha=function(){return bt.getClearAlpha()},this.setClearAlpha=function(){bt.setClearAlpha.apply(bt,arguments)},this.clear=function(S,O,q){let X=0;(S===void 0||S)&&(X|=16384),(O===void 0||O)&&(X|=256),(q===void 0||q)&&(X|=1024),F.clear(X)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Dt,!1),t.removeEventListener("webglcontextrestored",Ut,!1),L.dispose(),E.dispose(),$.dispose(),st.dispose(),K.dispose(),St.dispose(),Rt.dispose(),Ft.dispose(),Ft.removeEventListener("sessionstart",We),Ft.removeEventListener("sessionend",Fe),T&&(T.dispose(),T=null),le.stop()};function Dt(S){S.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function Ut(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const S=lt.autoReset,O=ht.enabled,q=ht.autoUpdate,X=ht.needsUpdate,B=ht.type;At(),lt.autoReset=S,ht.enabled=O,ht.autoUpdate=q,ht.needsUpdate=X,ht.type=B}function Jt(S){const O=S.target;O.removeEventListener("dispose",Jt),Yt(O)}function Yt(S){he(S),$.remove(S)}function he(S){const O=$.get(S).programs;O!==void 0&&O.forEach(function(q){zt.releaseProgram(q)})}this.renderBufferDirect=function(S,O,q,X,B,ut){O===null&&(O=I);const dt=B.isMesh&&B.matrixWorld.determinant()<0,xt=mt(S,O,q,X,B);nt.setMaterial(X,dt);let pt=q.index;const ft=q.attributes.position;if(pt===null){if(ft===void 0||ft.count===0)return}else if(pt.count===0)return;let vt=1;X.wireframe===!0&&(pt=Lt.getWireframeAttribute(q),vt=2),Rt.setup(B,X,xt,q,pt);let Et,Nt=J;pt!==null&&(Et=tt.get(pt),Nt=yt,Nt.setIndex(Et));const wt=pt!==null?pt.count:ft.count,Bt=q.drawRange.start*vt,kt=q.drawRange.count*vt,Gt=ut!==null?ut.start*vt:0,Ht=ut!==null?ut.count*vt:1/0,Xt=Math.max(Bt,Gt),Vt=Math.min(wt,Bt+kt,Gt+Ht)-1,de=Math.max(0,Vt-Xt+1);if(de!==0){if(B.isMesh)X.wireframe===!0?(nt.setLineWidth(X.wireframeLinewidth*R()),Nt.setMode(1)):Nt.setMode(4);else if(B.isLine){let jt=X.linewidth;jt===void 0&&(jt=1),nt.setLineWidth(jt*R()),B.isLineSegments?Nt.setMode(1):B.isLineLoop?Nt.setMode(2):Nt.setMode(3)}else B.isPoints?Nt.setMode(0):B.isSprite&&Nt.setMode(4);if(B.isInstancedMesh)Nt.renderInstances(Xt,de,B.count);else if(q.isInstancedBufferGeometry){const jt=Math.min(q.instanceCount,q._maxInstanceCount);Nt.renderInstances(Xt,de,jt)}else Nt.render(Xt,de)}},this.compile=function(S,O){d=E.get(S),d.init(),f.push(d),S.traverseVisible(function(q){q.isLight&&q.layers.test(O.layers)&&(d.pushLight(q),q.castShadow&&d.pushShadow(q))}),d.setupLights(g.physicallyCorrectLights),S.traverse(function(q){const X=q.material;if(X)if(Array.isArray(X))for(let B=0;B<X.length;B++){const ut=X[B];ue(ut,S,q)}else ue(X,S,q)}),f.pop(),d=null};let ae=null;function Pe(S){ae&&ae(S)}function We(){le.stop()}function Fe(){le.start()}const le=new Ca;le.setAnimationLoop(Pe),typeof window!="undefined"&&le.setContext(window),this.setAnimationLoop=function(S){ae=S,Ft.setAnimationLoop(S),S===null?le.stop():le.start()},Ft.addEventListener("sessionstart",We),Ft.addEventListener("sessionend",Fe),this.render=function(S,O){if(O!==void 0&&O.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;S.autoUpdate===!0&&S.updateMatrixWorld(),O.parent===null&&O.updateMatrixWorld(),Ft.enabled===!0&&Ft.isPresenting===!0&&(Ft.cameraAutoUpdate===!0&&Ft.updateCamera(O),O=Ft.getCamera()),S.isScene===!0&&S.onBeforeRender(g,S,O,_),d=E.get(S,f.length),d.init(),f.push(d),Z.multiplyMatrices(O.projectionMatrix,O.matrixWorldInverse),z.setFromProjectionMatrix(Z),W=this.localClippingEnabled,it=at.init(this.clippingPlanes,W,O),c=L.get(S,p.length),c.init(),p.push(c),rn(S,O,0,g.sortObjects),c.finish(),g.sortObjects===!0&&c.sort(U,V),it===!0&&at.beginShadows();const q=d.state.shadowsArray;if(ht.render(q,S,O),it===!0&&at.endShadows(),this.info.autoReset===!0&&this.info.reset(),bt.render(c,S),d.setupLights(g.physicallyCorrectLights),O.isArrayCamera){const X=O.cameras;for(let B=0,ut=X.length;B<ut;B++){const dt=X[B];sn(c,S,dt,dt.viewport)}}else sn(c,S,O);_!==null&&(rt.updateMultisampleRenderTarget(_),rt.updateRenderTargetMipmap(_)),S.isScene===!0&&S.onAfterRender(g,S,O),nt.buffers.depth.setTest(!0),nt.buffers.depth.setMask(!0),nt.buffers.color.setMask(!0),nt.setPolygonOffset(!1),Rt.resetDefaultState(),x=-1,w=null,f.pop(),f.length>0?d=f[f.length-1]:d=null,p.pop(),p.length>0?c=p[p.length-1]:c=null};function rn(S,O,q,X){if(S.visible===!1)return;if(S.layers.test(O.layers)){if(S.isGroup)q=S.renderOrder;else if(S.isLOD)S.autoUpdate===!0&&S.update(O);else if(S.isLight)d.pushLight(S),S.castShadow&&d.pushShadow(S);else if(S.isSprite){if(!S.frustumCulled||z.intersectsSprite(S)){X&&A.setFromMatrixPosition(S.matrixWorld).applyMatrix4(Z);const dt=St.update(S),xt=S.material;xt.visible&&c.push(S,dt,xt,q,A.z,null)}}else if((S.isMesh||S.isLine||S.isPoints)&&(S.isSkinnedMesh&&S.skeleton.frame!==lt.render.frame&&(S.skeleton.update(),S.skeleton.frame=lt.render.frame),!S.frustumCulled||z.intersectsObject(S))){X&&A.setFromMatrixPosition(S.matrixWorld).applyMatrix4(Z);const dt=St.update(S),xt=S.material;if(Array.isArray(xt)){const pt=dt.groups;for(let ft=0,vt=pt.length;ft<vt;ft++){const Et=pt[ft],Nt=xt[Et.materialIndex];Nt&&Nt.visible&&c.push(S,dt,Nt,q,A.z,Et)}}else xt.visible&&c.push(S,dt,xt,q,A.z,null)}}const ut=S.children;for(let dt=0,xt=ut.length;dt<xt;dt++)rn(ut[dt],O,q,X)}function sn(S,O,q,X){const B=S.opaque,ut=S.transmissive,dt=S.transparent;d.setupLightsView(q),ut.length>0&&un(B,O,q),X&&nt.viewport(C.copy(X)),B.length>0&&$e(B,O,q),ut.length>0&&$e(ut,O,q),dt.length>0&&$e(dt,O,q)}function un(S,O,q){if(T===null){const dt=s===!0&&k.isWebGL2===!0?Ts:je;T=new dt(1024,1024,{generateMipmaps:!0,type:gt.convert(ti)!==null?ti:Sn,minFilter:mr,magFilter:_e,wrapS:He,wrapT:He,useRenderToTexture:et.has("WEBGL_multisampled_render_to_texture")})}const X=g.getRenderTarget();g.setRenderTarget(T),g.clear();const B=g.toneMapping;g.toneMapping=Gn,$e(S,O,q),g.toneMapping=B,rt.updateMultisampleRenderTarget(T),rt.updateRenderTargetMipmap(T),g.setRenderTarget(X)}function $e(S,O,q){const X=O.isScene===!0?O.overrideMaterial:null;for(let B=0,ut=S.length;B<ut;B++){const dt=S[B],xt=dt.object,pt=dt.geometry,ft=X===null?dt.material:X,vt=dt.group;xt.layers.test(q.layers)&&Mn(xt,O,q,pt,ft,vt)}}function Mn(S,O,q,X,B,ut){S.onBeforeRender(g,O,q,X,B,ut),S.modelViewMatrix.multiplyMatrices(q.matrixWorldInverse,S.matrixWorld),S.normalMatrix.getNormalMatrix(S.modelViewMatrix),B.onBeforeRender(g,O,q,X,S,ut),B.transparent===!0&&B.side===$n?(B.side=ge,B.needsUpdate=!0,g.renderBufferDirect(q,O,X,B,S,ut),B.side=Vi,B.needsUpdate=!0,g.renderBufferDirect(q,O,X,B,S,ut),B.side=$n):g.renderBufferDirect(q,O,X,B,S,ut),S.onAfterRender(g,O,q,X,B,ut)}function ue(S,O,q){O.isScene!==!0&&(O=I);const X=$.get(S),B=d.state.lights,ut=d.state.shadowsArray,dt=B.state.version,xt=zt.getParameters(S,B.state,ut,O,q),pt=zt.getProgramCacheKey(xt);let ft=X.programs;X.environment=S.isMeshStandardMaterial?O.environment:null,X.fog=O.fog,X.envMap=(S.isMeshStandardMaterial?K:st).get(S.envMap||X.environment),ft===void 0&&(S.addEventListener("dispose",Jt),ft=new Map,X.programs=ft);let vt=ft.get(pt);if(vt!==void 0){if(X.currentProgram===vt&&X.lightsStateVersion===dt)return ct(S,xt),vt}else xt.uniforms=zt.getUniforms(S),S.onBuild(q,xt,g),S.onBeforeCompile(xt,g),vt=zt.acquireProgram(xt,pt),ft.set(pt,vt),X.uniforms=xt.uniforms;const Et=X.uniforms;(!S.isShaderMaterial&&!S.isRawShaderMaterial||S.clipping===!0)&&(Et.clippingPlanes=at.uniform),ct(S,xt),X.needsLights=Mt(S),X.lightsStateVersion=dt,X.needsLights&&(Et.ambientLightColor.value=B.state.ambient,Et.lightProbe.value=B.state.probe,Et.directionalLights.value=B.state.directional,Et.directionalLightShadows.value=B.state.directionalShadow,Et.spotLights.value=B.state.spot,Et.spotLightShadows.value=B.state.spotShadow,Et.rectAreaLights.value=B.state.rectArea,Et.ltc_1.value=B.state.rectAreaLTC1,Et.ltc_2.value=B.state.rectAreaLTC2,Et.pointLights.value=B.state.point,Et.pointLightShadows.value=B.state.pointShadow,Et.hemisphereLights.value=B.state.hemi,Et.directionalShadowMap.value=B.state.directionalShadowMap,Et.directionalShadowMatrix.value=B.state.directionalShadowMatrix,Et.spotShadowMap.value=B.state.spotShadowMap,Et.spotShadowMatrix.value=B.state.spotShadowMatrix,Et.pointShadowMap.value=B.state.pointShadowMap,Et.pointShadowMatrix.value=B.state.pointShadowMatrix);const Nt=vt.getUniforms(),wt=Fn.seqWithValue(Nt.seq,Et);return X.currentProgram=vt,X.uniformsList=wt,vt}function ct(S,O){const q=$.get(S);q.outputEncoding=O.outputEncoding,q.instancing=O.instancing,q.skinning=O.skinning,q.morphTargets=O.morphTargets,q.morphNormals=O.morphNormals,q.morphTargetsCount=O.morphTargetsCount,q.numClippingPlanes=O.numClippingPlanes,q.numIntersection=O.numClipIntersection,q.vertexAlphas=O.vertexAlphas,q.vertexTangents=O.vertexTangents}function mt(S,O,q,X,B){O.isScene!==!0&&(O=I),rt.resetTextureUnits();const ut=O.fog,dt=X.isMeshStandardMaterial?O.environment:null,xt=_===null?g.outputEncoding:_.texture.encoding,pt=(X.isMeshStandardMaterial?K:st).get(X.envMap||dt),ft=X.vertexColors===!0&&!!q.attributes.color&&q.attributes.color.itemSize===4,vt=!!X.normalMap&&!!q.attributes.tangent,Et=!!q.morphAttributes.position,Nt=!!q.morphAttributes.normal,wt=q.morphAttributes.position?q.morphAttributes.position.length:0,Bt=$.get(X),kt=d.state.lights;if(it===!0&&(W===!0||S!==w)){const pe=S===w&&X.id===x;at.setState(X,S,pe)}let Gt=!1;X.version===Bt.__version?(Bt.needsLights&&Bt.lightsStateVersion!==kt.state.version||Bt.outputEncoding!==xt||B.isInstancedMesh&&Bt.instancing===!1||!B.isInstancedMesh&&Bt.instancing===!0||B.isSkinnedMesh&&Bt.skinning===!1||!B.isSkinnedMesh&&Bt.skinning===!0||Bt.envMap!==pt||X.fog&&Bt.fog!==ut||Bt.numClippingPlanes!==void 0&&(Bt.numClippingPlanes!==at.numPlanes||Bt.numIntersection!==at.numIntersection)||Bt.vertexAlphas!==ft||Bt.vertexTangents!==vt||Bt.morphTargets!==Et||Bt.morphNormals!==Nt||k.isWebGL2===!0&&Bt.morphTargetsCount!==wt)&&(Gt=!0):(Gt=!0,Bt.__version=X.version);let Ht=Bt.currentProgram;Gt===!0&&(Ht=ue(X,O,B));let Xt=!1,Vt=!1,de=!1;const jt=Ht.getUniforms(),me=Bt.uniforms;if(nt.useProgram(Ht.program)&&(Xt=!0,Vt=!0,de=!0),X.id!==x&&(x=X.id,Vt=!0),Xt||w!==S){if(jt.setValue(F,"projectionMatrix",S.projectionMatrix),k.logarithmicDepthBuffer&&jt.setValue(F,"logDepthBufFC",2/(Math.log(S.far+1)/Math.LN2)),w!==S&&(w=S,Vt=!0,de=!0),X.isShaderMaterial||X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshStandardMaterial||X.envMap){const pe=jt.map.cameraPosition;pe!==void 0&&pe.setValue(F,A.setFromMatrixPosition(S.matrixWorld))}(X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshLambertMaterial||X.isMeshBasicMaterial||X.isMeshStandardMaterial||X.isShaderMaterial)&&jt.setValue(F,"isOrthographic",S.isOrthographicCamera===!0),(X.isMeshPhongMaterial||X.isMeshToonMaterial||X.isMeshLambertMaterial||X.isMeshBasicMaterial||X.isMeshStandardMaterial||X.isShaderMaterial||X.isShadowMaterial||B.isSkinnedMesh)&&jt.setValue(F,"viewMatrix",S.matrixWorldInverse)}if(B.isSkinnedMesh){jt.setOptional(F,B,"bindMatrix"),jt.setOptional(F,B,"bindMatrixInverse");const pe=B.skeleton;pe&&(k.floatVertexTextures?(pe.boneTexture===null&&pe.computeBoneTexture(),jt.setValue(F,"boneTexture",pe.boneTexture,rt),jt.setValue(F,"boneTextureSize",pe.boneTextureSize)):jt.setOptional(F,pe,"boneMatrices"))}return!!q&&(q.morphAttributes.position!==void 0||q.morphAttributes.normal!==void 0)&&Ct.update(B,q,X,Ht),(Vt||Bt.receiveShadow!==B.receiveShadow)&&(Bt.receiveShadow=B.receiveShadow,jt.setValue(F,"receiveShadow",B.receiveShadow)),Vt&&(jt.setValue(F,"toneMappingExposure",g.toneMappingExposure),Bt.needsLights&&_t(me,de),ut&&X.fog&&Pt.refreshFogUniforms(me,ut),Pt.refreshMaterialUniforms(me,X,b,N,T),Fn.upload(F,Bt.uniformsList,me,rt)),X.isShaderMaterial&&X.uniformsNeedUpdate===!0&&(Fn.upload(F,Bt.uniformsList,me,rt),X.uniformsNeedUpdate=!1),X.isSpriteMaterial&&jt.setValue(F,"center",B.center),jt.setValue(F,"modelViewMatrix",B.modelViewMatrix),jt.setValue(F,"normalMatrix",B.normalMatrix),jt.setValue(F,"modelMatrix",B.matrixWorld),Ht}function _t(S,O){S.ambientLightColor.needsUpdate=O,S.lightProbe.needsUpdate=O,S.directionalLights.needsUpdate=O,S.directionalLightShadows.needsUpdate=O,S.pointLights.needsUpdate=O,S.pointLightShadows.needsUpdate=O,S.spotLights.needsUpdate=O,S.spotLightShadows.needsUpdate=O,S.rectAreaLights.needsUpdate=O,S.hemisphereLights.needsUpdate=O}function Mt(S){return S.isMeshLambertMaterial||S.isMeshToonMaterial||S.isMeshPhongMaterial||S.isMeshStandardMaterial||S.isShadowMaterial||S.isShaderMaterial&&S.lights===!0}this.getActiveCubeFace=function(){return m},this.getActiveMipmapLevel=function(){return v},this.getRenderTarget=function(){return _},this.setRenderTargetTextures=function(S,O,q){$.get(S.texture).__webglTexture=O,$.get(S.depthTexture).__webglTexture=q;const X=$.get(S);X.__hasExternalTextures=!0,X.__hasExternalTextures&&(X.__autoAllocateDepthBuffer=q===void 0,X.__autoAllocateDepthBuffer||S.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),S.useRenderToTexture=!1,S.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(S,O){const q=$.get(S);q.__webglFramebuffer=O,q.__useDefaultFramebuffer=O===void 0},this.setRenderTarget=function(S,O=0,q=0){_=S,m=O,v=q;let X=!0;if(S){const pt=$.get(S);pt.__useDefaultFramebuffer!==void 0?(nt.bindFramebuffer(36160,null),X=!1):pt.__webglFramebuffer===void 0?rt.setupRenderTarget(S):pt.__hasExternalTextures&&rt.rebindTextures(S,$.get(S.texture).__webglTexture,$.get(S.depthTexture).__webglTexture)}let B=null,ut=!1,dt=!1;if(S){const pt=S.texture;(pt.isDataTexture3D||pt.isDataTexture2DArray)&&(dt=!0);const ft=$.get(S).__webglFramebuffer;S.isWebGLCubeRenderTarget?(B=ft[O],ut=!0):S.useRenderbuffer?B=$.get(S).__webglMultisampledFramebuffer:B=ft,C.copy(S.viewport),M.copy(S.scissor),D=S.scissorTest}else C.copy(H).multiplyScalar(b).floor(),M.copy(Y).multiplyScalar(b).floor(),D=Q;if(nt.bindFramebuffer(36160,B)&&k.drawBuffers&&X){let pt=!1;if(S)if(S.isWebGLMultipleRenderTargets){const ft=S.texture;if(P.length!==ft.length||P[0]!==36064){for(let vt=0,Et=ft.length;vt<Et;vt++)P[vt]=36064+vt;P.length=ft.length,pt=!0}}else(P.length!==1||P[0]!==36064)&&(P[0]=36064,P.length=1,pt=!0);else(P.length!==1||P[0]!==1029)&&(P[0]=1029,P.length=1,pt=!0);pt&&(k.isWebGL2?F.drawBuffers(P):et.get("WEBGL_draw_buffers").drawBuffersWEBGL(P))}if(nt.viewport(C),nt.scissor(M),nt.setScissorTest(D),ut){const pt=$.get(S.texture);F.framebufferTexture2D(36160,36064,34069+O,pt.__webglTexture,q)}else if(dt){const pt=$.get(S.texture),ft=O||0;F.framebufferTextureLayer(36160,36064,pt.__webglTexture,q||0,ft)}x=-1},this.readRenderTargetPixels=function(S,O,q,X,B,ut,dt){if(!(S&&S.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let xt=$.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget&&dt!==void 0&&(xt=xt[dt]),xt){nt.bindFramebuffer(36160,xt);try{const pt=S.texture,ft=pt.format,vt=pt.type;if(ft!==Ie&&gt.convert(ft)!==F.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Et=vt===ti&&(et.has("EXT_color_buffer_half_float")||k.isWebGL2&&et.has("EXT_color_buffer_float"));if(vt!==Sn&&gt.convert(vt)!==F.getParameter(35738)&&!(vt===En&&(k.isWebGL2||et.has("OES_texture_float")||et.has("WEBGL_color_buffer_float")))&&!Et){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}F.checkFramebufferStatus(36160)===36053?O>=0&&O<=S.width-X&&q>=0&&q<=S.height-B&&F.readPixels(O,q,X,B,gt.convert(ft),gt.convert(vt),ut):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const pt=_!==null?$.get(_).__webglFramebuffer:null;nt.bindFramebuffer(36160,pt)}}},this.copyFramebufferToTexture=function(S,O,q=0){const X=Math.pow(2,-q),B=Math.floor(O.image.width*X),ut=Math.floor(O.image.height*X);let dt=gt.convert(O.format);k.isWebGL2&&(dt===6407&&(dt=32849),dt===6408&&(dt=32856)),rt.setTexture2D(O,0),F.copyTexImage2D(3553,q,dt,S.x,S.y,B,ut,0),nt.unbindTexture()},this.copyTextureToTexture=function(S,O,q,X=0){const B=O.image.width,ut=O.image.height,dt=gt.convert(q.format),xt=gt.convert(q.type);rt.setTexture2D(q,0),F.pixelStorei(37440,q.flipY),F.pixelStorei(37441,q.premultiplyAlpha),F.pixelStorei(3317,q.unpackAlignment),O.isDataTexture?F.texSubImage2D(3553,X,S.x,S.y,B,ut,dt,xt,O.image.data):O.isCompressedTexture?F.compressedTexSubImage2D(3553,X,S.x,S.y,O.mipmaps[0].width,O.mipmaps[0].height,dt,O.mipmaps[0].data):F.texSubImage2D(3553,X,S.x,S.y,dt,xt,O.image),X===0&&q.generateMipmaps&&F.generateMipmap(3553),nt.unbindTexture()},this.copyTextureToTexture3D=function(S,O,q,X,B=0){if(g.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const ut=S.max.x-S.min.x+1,dt=S.max.y-S.min.y+1,xt=S.max.z-S.min.z+1,pt=gt.convert(X.format),ft=gt.convert(X.type);let vt;if(X.isDataTexture3D)rt.setTexture3D(X,0),vt=32879;else if(X.isDataTexture2DArray)rt.setTexture2DArray(X,0),vt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}F.pixelStorei(37440,X.flipY),F.pixelStorei(37441,X.premultiplyAlpha),F.pixelStorei(3317,X.unpackAlignment);const Et=F.getParameter(3314),Nt=F.getParameter(32878),wt=F.getParameter(3316),Bt=F.getParameter(3315),kt=F.getParameter(32877),Gt=q.isCompressedTexture?q.mipmaps[0]:q.image;F.pixelStorei(3314,Gt.width),F.pixelStorei(32878,Gt.height),F.pixelStorei(3316,S.min.x),F.pixelStorei(3315,S.min.y),F.pixelStorei(32877,S.min.z),q.isDataTexture||q.isDataTexture3D?F.texSubImage3D(vt,B,O.x,O.y,O.z,ut,dt,xt,pt,ft,Gt.data):q.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),F.compressedTexSubImage3D(vt,B,O.x,O.y,O.z,ut,dt,xt,pt,Gt.data)):F.texSubImage3D(vt,B,O.x,O.y,O.z,ut,dt,xt,pt,ft,Gt),F.pixelStorei(3314,Et),F.pixelStorei(32878,Nt),F.pixelStorei(3316,wt),F.pixelStorei(3315,Bt),F.pixelStorei(32877,kt),B===0&&X.generateMipmaps&&F.generateMipmap(vt),nt.unbindTexture()},this.initTexture=function(S){rt.setTexture2D(S,0),nt.unbindTexture()},this.resetState=function(){m=0,v=0,_=null,nt.reset(),Rt.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Kt.prototype.isWebGLRenderer=!0;class bm extends Kt{}bm.prototype.isWebGL1Renderer=!0;class dl extends Qt{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}dl.prototype.isScene=!0;class $i{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Hi,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=on()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=on()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=on()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}$i.prototype.isInterleavedBuffer=!0;const fe=new G;class Ki{constructor(t,e,n,i=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)fe.x=this.getX(e),fe.y=this.getY(e),fe.z=this.getZ(e),fe.applyMatrix4(t),this.setXYZ(e,fe.x,fe.y,fe.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)fe.x=this.getX(e),fe.y=this.getY(e),fe.z=this.getZ(e),fe.applyNormalMatrix(t),this.setXYZ(e,fe.x,fe.y,fe.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)fe.x=this.getX(e),fe.y=this.getY(e),fe.z=this.getZ(e),fe.transformDirection(t),this.setXYZ(e,fe.x,fe.y,fe.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return new ye(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Ki(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Ki.prototype.isInterleavedBufferAttribute=!0;class pl extends Ce{constructor(t){super();this.type="SpriteMaterial",this.color=new Ot(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}pl.prototype.isSpriteMaterial=!0;let Ci;const tr=new G,Ri=new G,Li=new G,Pi=new Tt,er=new Tt,fl=new Wt,Xr=new G,nr=new G,Yr=new G,ml=new Tt,co=new Tt,vl=new Tt;class Sm extends Qt{constructor(t){super();if(this.type="Sprite",Ci===void 0){Ci=new se;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new $i(e,5);Ci.setIndex([0,1,2,0,2,3]),Ci.setAttribute("position",new Ki(n,3,0,!1)),Ci.setAttribute("uv",new Ki(n,2,3,!1))}this.geometry=Ci,this.material=t!==void 0?t:new pl,this.center=new Tt(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ri.setFromMatrixScale(this.matrixWorld),fl.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Li.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Ri.multiplyScalar(-Li.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;Zr(Xr.set(-.5,-.5,0),Li,s,Ri,i,r),Zr(nr.set(.5,-.5,0),Li,s,Ri,i,r),Zr(Yr.set(.5,.5,0),Li,s,Ri,i,r),ml.set(0,0),co.set(1,0),vl.set(1,1);let o=t.ray.intersectTriangle(Xr,nr,Yr,!1,tr);if(o===null&&(Zr(nr.set(-.5,.5,0),Li,s,Ri,i,r),co.set(0,1),o=t.ray.intersectTriangle(Xr,Yr,nr,!1,tr),o===null))return;const l=t.ray.origin.distanceTo(tr);l<t.near||l>t.far||e.push({distance:l,point:tr.clone(),uv:ve.getUV(tr,Xr,nr,Yr,ml,co,vl,new Tt),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}Sm.prototype.isSprite=!0;function Zr(a,t,e,n,i,r){Pi.subVectors(a,e).addScalar(.5).multiply(n),i!==void 0?(er.x=r*Pi.x-i*Pi.y,er.y=i*Pi.x+r*Pi.y):er.copy(Pi),a.copy(t),a.x+=er.x,a.y+=er.y,a.applyMatrix4(fl)}const gl=new G,yl=new ee,xl=new ee,Em=new G,_l=new Wt;class wl extends Oe{constructor(t,e){super(t,e);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Wt,this.bindMatrixInverse=new Wt}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new ee,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,i=this.geometry;yl.fromBufferAttribute(i.attributes.skinIndex,t),xl.fromBufferAttribute(i.attributes.skinWeight,t),gl.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const s=xl.getComponent(r);if(s!==0){const o=yl.getComponent(r);_l.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),e.addScaledVector(Em.copy(gl).applyMatrix4(_l),s)}}return e.applyMatrix4(this.bindMatrixInverse)}}wl.prototype.isSkinnedMesh=!0;class Tm extends Qt{constructor(){super();this.type="Bone"}}Tm.prototype.isBone=!0;class Am extends Te{constructor(t=null,e=1,n=1,i,r,s,o,l,h=_e,u=_e,c,d){super(null,s,o,l,h,u,i,r,c,d);this.image={data:t,width:e,height:n},this.magFilter=h,this.minFilter=u,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Am.prototype.isDataTexture=!0;class ho extends ye{constructor(t,e,n,i=1){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(t,e,n);this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}ho.prototype.isInstancedBufferAttribute=!0;const Ml=new Wt,bl=new Wt,jr=[],ir=new Oe;class Cm extends Oe{constructor(t,e,n){super(t,e);this.instanceMatrix=new ho(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(ir.geometry=this.geometry,ir.material=this.material,ir.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,Ml),bl.multiplyMatrices(n,Ml),ir.matrixWorld=bl,ir.raycast(t,jr);for(let s=0,o=jr.length;s<o;s++){const l=jr[s];l.instanceId=r,l.object=this,e.push(l)}jr.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new ho(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Cm.prototype.isInstancedMesh=!0;class rr extends Ce{constructor(t){super();this.type="LineBasicMaterial",this.color=new Ot(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}rr.prototype.isLineBasicMaterial=!0;const Sl=new G,El=new G,Tl=new Wt,uo=new di,Jr=new ui;class po extends Qt{constructor(t=new se,e=new rr){super();this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let i=1,r=e.count;i<r;i++)Sl.fromBufferAttribute(e,i-1),El.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=Sl.distanceTo(El);t.setAttribute("lineDistance",new we(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,s=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Jr.copy(n.boundingSphere),Jr.applyMatrix4(i),Jr.radius+=r,t.ray.intersectsSphere(Jr)===!1)return;Tl.copy(i).invert(),uo.copy(t.ray).applyMatrix4(Tl);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,h=new G,u=new G,c=new G,d=new G,p=this.isLineSegments?2:1;if(n.isBufferGeometry){const f=n.index,y=n.attributes.position;if(f!==null){const m=Math.max(0,s.start),v=Math.min(f.count,s.start+s.count);for(let _=m,x=v-1;_<x;_+=p){const w=f.getX(_),C=f.getX(_+1);if(h.fromBufferAttribute(y,w),u.fromBufferAttribute(y,C),uo.distanceSqToSegment(h,u,d,c)>l)continue;d.applyMatrix4(this.matrixWorld);const D=t.ray.origin.distanceTo(d);D<t.near||D>t.far||e.push({distance:D,point:c.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}else{const m=Math.max(0,s.start),v=Math.min(y.count,s.start+s.count);for(let _=m,x=v-1;_<x;_+=p){if(h.fromBufferAttribute(y,_),u.fromBufferAttribute(y,_+1),uo.distanceSqToSegment(h,u,d,c)>l)continue;d.applyMatrix4(this.matrixWorld);const C=t.ray.origin.distanceTo(d);C<t.near||C>t.far||e.push({distance:C,point:c.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}po.prototype.isLine=!0;const Al=new G,Cl=new G;class fo extends po{constructor(t,e){super(t,e);this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let i=0,r=e.count;i<r;i+=2)Al.fromBufferAttribute(e,i),Cl.fromBufferAttribute(e,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Al.distanceTo(Cl);t.setAttribute("lineDistance",new we(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}fo.prototype.isLineSegments=!0;class Rm extends po{constructor(t,e){super(t,e);this.type="LineLoop"}}Rm.prototype.isLineLoop=!0;class Rl extends Ce{constructor(t){super();this.type="PointsMaterial",this.color=new Ot(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}Rl.prototype.isPointsMaterial=!0;const Ll=new Wt,mo=new di,Qr=new ui,$r=new G;class Lm extends Qt{constructor(t=new se,e=new Rl){super();this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Qr.copy(n.boundingSphere),Qr.applyMatrix4(i),Qr.radius+=r,t.ray.intersectsSphere(Qr)===!1)return;Ll.copy(i).invert(),mo.copy(t.ray).applyMatrix4(Ll);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o;if(n.isBufferGeometry){const h=n.index,c=n.attributes.position;if(h!==null){const d=Math.max(0,s.start),p=Math.min(h.count,s.start+s.count);for(let f=d,g=p;f<g;f++){const y=h.getX(f);$r.fromBufferAttribute(c,y),Pl($r,y,l,i,t,e,this)}}else{const d=Math.max(0,s.start),p=Math.min(c.count,s.start+s.count);for(let f=d,g=p;f<g;f++)$r.fromBufferAttribute(c,f),Pl($r,f,l,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Lm.prototype.isPoints=!0;function Pl(a,t,e,n,i,r,s){const o=mo.distanceSqToPoint(a);if(o<e){const l=new G;mo.closestPointToPoint(a,l),l.applyMatrix4(n);const h=i.ray.origin.distanceTo(l);if(h<i.near||h>i.far)return;r.push({distance:h,distanceToRay:Math.sqrt(o),point:l,index:t,face:null,object:s})}}class Pm extends Te{constructor(t,e,n,i,r,s,o,l,h){super(t,e,n,i,r,s,o,l,h);this.format=o!==void 0?o:Hn,this.minFilter=s!==void 0?s:Ze,this.magFilter=r!==void 0?r:Ze,this.generateMipmaps=!1;const u=this;function c(){u.needsUpdate=!0,t.requestVideoFrameCallback(c)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(c)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Pm.prototype.isVideoTexture=!0;class Im extends Te{constructor(t,e,n,i,r,s,o,l,h,u,c,d){super(null,s,o,l,h,u,i,r,c,d);this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}Im.prototype.isCompressedTexture=!0;class Bm extends Te{constructor(t,e,n,i,r,s,o,l,h){super(t,e,n,i,r,s,o,l,h);this.needsUpdate=!0}}Bm.prototype.isCanvasTexture=!0;new G;new G;new G;new ve;class Qe{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const r=n.length;let s;e?s=e:s=t*n[r-1];let o=0,l=r-1,h;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),h=n[i]-s,h<0)o=i+1;else if(h>0)l=i-1;else{l=i;break}if(i=l,n[i]===s)return i/(r-1);const u=n[i],d=n[i+1]-u,p=(s-u)/d;return(i+p)/(r-1)}getTangent(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),l=e||(s.isVector2?new Tt:new G);return l.copy(o).sub(s).normalize(),l}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new G,i=[],r=[],s=[],o=new G,l=new Wt;for(let p=0;p<=t;p++){const f=p/t;i[p]=this.getTangentAt(f,new G)}r[0]=new G,s[0]=new G;let h=Number.MAX_VALUE;const u=Math.abs(i[0].x),c=Math.abs(i[0].y),d=Math.abs(i[0].z);u<=h&&(h=u,n.set(1,0,0)),c<=h&&(h=c,n.set(0,1,0)),d<=h&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let p=1;p<=t;p++){if(r[p]=r[p-1].clone(),s[p]=s[p-1].clone(),o.crossVectors(i[p-1],i[p]),o.length()>Number.EPSILON){o.normalize();const f=Math.acos(ke(i[p-1].dot(i[p]),-1,1));r[p].applyMatrix4(l.makeRotationAxis(o,f))}s[p].crossVectors(i[p],r[p])}if(e===!0){let p=Math.acos(ke(r[0].dot(r[t]),-1,1));p/=t,i[0].dot(o.crossVectors(r[0],r[t]))>0&&(p=-p);for(let f=1;f<=t;f++)r[f].applyMatrix4(l.makeRotationAxis(i[f],p*f)),s[f].crossVectors(i[f],r[f])}return{tangents:i,normals:r,binormals:s}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Kr extends Qe{constructor(t=0,e=0,n=1,i=1,r=0,s=Math.PI*2,o=!1,l=0){super();this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=o,this.aRotation=l}getPoint(t,e){const n=e||new Tt,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(s?r=0:r=i),this.aClockwise===!0&&!s&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+t*r;let l=this.aX+this.xRadius*Math.cos(o),h=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const u=Math.cos(this.aRotation),c=Math.sin(this.aRotation),d=l-this.aX,p=h-this.aY;l=d*u-p*c+this.aX,h=d*c+p*u+this.aY}return n.set(l,h)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Kr.prototype.isEllipseCurve=!0;class Il extends Kr{constructor(t,e,n,i,r,s){super(t,e,n,n,i,r,s);this.type="ArcCurve"}}Il.prototype.isArcCurve=!0;function vo(){let a=0,t=0,e=0,n=0;function i(r,s,o,l){a=r,t=o,e=-3*r+3*s-2*o-l,n=2*r-2*s+o+l}return{initCatmullRom:function(r,s,o,l,h){i(s,o,h*(o-r),h*(l-s))},initNonuniformCatmullRom:function(r,s,o,l,h,u,c){let d=(s-r)/h-(o-r)/(h+u)+(o-s)/u,p=(o-s)/u-(l-s)/(u+c)+(l-o)/c;d*=u,p*=u,i(s,o,d,p)},calc:function(r){const s=r*r,o=s*r;return a+t*r+e*s+n*o}}}const ts=new G,go=new vo,yo=new vo,xo=new vo;class Bl extends Qe{constructor(t=[],e=!1,n="centripetal",i=.5){super();this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new G){const n=e,i=this.points,r=i.length,s=(r-(this.closed?0:1))*t;let o=Math.floor(s),l=s-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:l===0&&o===r-1&&(o=r-2,l=1);let h,u;this.closed||o>0?h=i[(o-1)%r]:(ts.subVectors(i[0],i[1]).add(i[0]),h=ts);const c=i[o%r],d=i[(o+1)%r];if(this.closed||o+2<r?u=i[(o+2)%r]:(ts.subVectors(i[r-1],i[r-2]).add(i[r-1]),u=ts),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(h.distanceToSquared(c),p),g=Math.pow(c.distanceToSquared(d),p),y=Math.pow(d.distanceToSquared(u),p);g<1e-4&&(g=1),f<1e-4&&(f=g),y<1e-4&&(y=g),go.initNonuniformCatmullRom(h.x,c.x,d.x,u.x,f,g,y),yo.initNonuniformCatmullRom(h.y,c.y,d.y,u.y,f,g,y),xo.initNonuniformCatmullRom(h.z,c.z,d.z,u.z,f,g,y)}else this.curveType==="catmullrom"&&(go.initCatmullRom(h.x,c.x,d.x,u.x,this.tension),yo.initCatmullRom(h.y,c.y,d.y,u.y,this.tension),xo.initCatmullRom(h.z,c.z,d.z,u.z,this.tension));return n.set(go.calc(l),yo.calc(l),xo.calc(l)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new G().fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}Bl.prototype.isCatmullRomCurve3=!0;function Fl(a,t,e,n,i){const r=(n-t)*.5,s=(i-e)*.5,o=a*a,l=a*o;return(2*e-2*n+r+s)*l+(-3*e+3*n-2*r-s)*o+r*a+e}function Fm(a,t){const e=1-a;return e*e*t}function Dm(a,t){return 2*(1-a)*a*t}function Nm(a,t){return a*a*t}function sr(a,t,e,n){return Fm(a,t)+Dm(a,e)+Nm(a,n)}function zm(a,t){const e=1-a;return e*e*e*t}function Vm(a,t){const e=1-a;return 3*e*e*a*t}function Om(a,t){return 3*(1-a)*a*a*t}function Um(a,t){return a*a*a*t}function or(a,t,e,n,i){return zm(a,t)+Vm(a,e)+Om(a,n)+Um(a,i)}class _o extends Qe{constructor(t=new Tt,e=new Tt,n=new Tt,i=new Tt){super();this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new Tt){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(or(t,i.x,r.x,s.x,o.x),or(t,i.y,r.y,s.y,o.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}_o.prototype.isCubicBezierCurve=!0;class Dl extends Qe{constructor(t=new G,e=new G,n=new G,i=new G){super();this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new G){const n=e,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(or(t,i.x,r.x,s.x,o.x),or(t,i.y,r.y,s.y,o.y),or(t,i.z,r.z,s.z,o.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Dl.prototype.isCubicBezierCurve3=!0;class es extends Qe{constructor(t=new Tt,e=new Tt){super();this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Tt){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new Tt;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}es.prototype.isLineCurve=!0;class Wm extends Qe{constructor(t=new G,e=new G){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new G){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class wo extends Qe{constructor(t=new Tt,e=new Tt,n=new Tt){super();this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Tt){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(sr(t,i.x,r.x,s.x),sr(t,i.y,r.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}wo.prototype.isQuadraticBezierCurve=!0;class Nl extends Qe{constructor(t=new G,e=new G,n=new G){super();this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new G){const n=e,i=this.v0,r=this.v1,s=this.v2;return n.set(sr(t,i.x,r.x,s.x),sr(t,i.y,r.y,s.y),sr(t,i.z,r.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Nl.prototype.isQuadraticBezierCurve3=!0;class Mo extends Qe{constructor(t=[]){super();this.type="SplineCurve",this.points=t}getPoint(t,e=new Tt){const n=e,i=this.points,r=(i.length-1)*t,s=Math.floor(r),o=r-s,l=i[s===0?s:s-1],h=i[s],u=i[s>i.length-2?i.length-1:s+1],c=i[s>i.length-3?i.length-1:s+2];return n.set(Fl(o,l.x,h.x,u.x,c.x),Fl(o,l.y,h.y,u.y,c.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const i=t.points[e];this.points.push(new Tt().fromArray(i))}return this}}Mo.prototype.isSplineCurve=!0;var zl=Object.freeze({__proto__:null,ArcCurve:Il,CatmullRomCurve3:Bl,CubicBezierCurve:_o,CubicBezierCurve3:Dl,EllipseCurve:Kr,LineCurve:es,LineCurve3:Wm,QuadraticBezierCurve:wo,QuadraticBezierCurve3:Nl,SplineCurve:Mo});class Gm extends Qe{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new es(e,t))}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const s=i[r]-n,o=this.curves[r],l=o.getLength(),h=l===0?0:1-s/l;return o.getPointAt(h,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s&&s.isEllipseCurve?t*2:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?t*s.points.length:t,l=s.getPoints(o);for(let h=0;h<l.length;h++){const u=l[h];n&&n.equals(u)||(e.push(u),n=u)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const i=t.curves[e];this.curves.push(new zl[i.type]().fromJSON(i))}return this}}class bo extends Gm{constructor(t){super();this.type="Path",this.currentPoint=new Tt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new es(this.currentPoint.clone(),new Tt(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new wo(this.currentPoint.clone(),new Tt(t,e),new Tt(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,s){const o=new _o(this.currentPoint.clone(),new Tt(t,e),new Tt(n,i),new Tt(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Mo(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,s){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+o,e+l,n,i,r,s),this}absarc(t,e,n,i,r,s){return this.absellipse(t,e,n,n,i,r,s),this}ellipse(t,e,n,i,r,s,o,l){const h=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(t+h,e+u,n,i,r,s,o,l),this}absellipse(t,e,n,i,r,s,o,l){const h=new Kr(t,e,n,i,r,s,o,l);if(this.curves.length>0){const c=h.getPoint(0);c.equals(this.currentPoint)||this.lineTo(c.x,c.y)}this.curves.push(h);const u=h.getPoint(1);return this.currentPoint.copy(u),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class ar extends bo{constructor(t){super(t);this.uuid=on(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const i=t.holes[e];this.holes.push(new bo().fromJSON(i))}return this}}const Hm={triangulate:function(a,t,e=2){const n=t&&t.length,i=n?t[0]*e:a.length;let r=Vl(a,0,i,e,!0);const s=[];if(!r||r.next===r.prev)return s;let o,l,h,u,c,d,p;if(n&&(r=Zm(a,t,r,e)),a.length>80*e){o=h=a[0],l=u=a[1];for(let f=e;f<i;f+=e)c=a[f],d=a[f+1],c<o&&(o=c),d<l&&(l=d),c>h&&(h=c),d>u&&(u=d);p=Math.max(h-o,u-l),p=p!==0?1/p:0}return lr(r,s,e,o,l,p),s}};function Vl(a,t,e,n,i){let r,s;if(i===sv(a,t,e,n)>0)for(r=t;r<e;r+=n)s=Wl(r,a[r],a[r+1],s);else for(r=e-n;r>=t;r-=n)s=Wl(r,a[r],a[r+1],s);return s&&ns(s,s.next)&&(hr(s),s=s.next),s}function Dn(a,t){if(!a)return a;t||(t=a);let e=a,n;do if(n=!1,!e.steiner&&(ns(e,e.next)||ce(e.prev,e,e.next)===0)){if(hr(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function lr(a,t,e,n,i,r,s){if(!a)return;!s&&r&&Km(a,n,i,r);let o=a,l,h;for(;a.prev!==a.next;){if(l=a.prev,h=a.next,r?qm(a,n,i,r):km(a)){t.push(l.i/e),t.push(a.i/e),t.push(h.i/e),hr(a),a=h.next,o=h.next;continue}if(a=h,a===o){s?s===1?(a=Xm(Dn(a),t,e),lr(a,t,e,n,i,r,2)):s===2&&Ym(a,t,e,n,i,r):lr(Dn(a),t,e,n,i,r,1);break}}}function km(a){const t=a.prev,e=a,n=a.next;if(ce(t,e,n)>=0)return!1;let i=a.next.next;for(;i!==a.prev;){if(Ii(t.x,t.y,e.x,e.y,n.x,n.y,i.x,i.y)&&ce(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function qm(a,t,e,n){const i=a.prev,r=a,s=a.next;if(ce(i,r,s)>=0)return!1;const o=i.x<r.x?i.x<s.x?i.x:s.x:r.x<s.x?r.x:s.x,l=i.y<r.y?i.y<s.y?i.y:s.y:r.y<s.y?r.y:s.y,h=i.x>r.x?i.x>s.x?i.x:s.x:r.x>s.x?r.x:s.x,u=i.y>r.y?i.y>s.y?i.y:s.y:r.y>s.y?r.y:s.y,c=So(o,l,t,e,n),d=So(h,u,t,e,n);let p=a.prevZ,f=a.nextZ;for(;p&&p.z>=c&&f&&f.z<=d;){if(p!==a.prev&&p!==a.next&&Ii(i.x,i.y,r.x,r.y,s.x,s.y,p.x,p.y)&&ce(p.prev,p,p.next)>=0||(p=p.prevZ,f!==a.prev&&f!==a.next&&Ii(i.x,i.y,r.x,r.y,s.x,s.y,f.x,f.y)&&ce(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;p&&p.z>=c;){if(p!==a.prev&&p!==a.next&&Ii(i.x,i.y,r.x,r.y,s.x,s.y,p.x,p.y)&&ce(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==a.prev&&f!==a.next&&Ii(i.x,i.y,r.x,r.y,s.x,s.y,f.x,f.y)&&ce(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function Xm(a,t,e){let n=a;do{const i=n.prev,r=n.next.next;!ns(i,r)&&Ol(i,n,n.next,r)&&cr(i,r)&&cr(r,i)&&(t.push(i.i/e),t.push(n.i/e),t.push(r.i/e),hr(n),hr(n.next),n=a=r),n=n.next}while(n!==a);return Dn(n)}function Ym(a,t,e,n,i,r){let s=a;do{let o=s.next.next;for(;o!==s.prev;){if(s.i!==o.i&&nv(s,o)){let l=Ul(s,o);s=Dn(s,s.next),l=Dn(l,l.next),lr(s,t,e,n,i,r),lr(l,t,e,n,i,r);return}o=o.next}s=s.next}while(s!==a)}function Zm(a,t,e,n){const i=[];let r,s,o,l,h;for(r=0,s=t.length;r<s;r++)o=t[r]*n,l=r<s-1?t[r+1]*n:a.length,h=Vl(a,o,l,n,!1),h===h.next&&(h.steiner=!0),i.push(ev(h));for(i.sort(jm),r=0;r<i.length;r++)Jm(i[r],e),e=Dn(e,e.next);return e}function jm(a,t){return a.x-t.x}function Jm(a,t){if(t=Qm(a,t),t){const e=Ul(t,a);Dn(t,t.next),Dn(e,e.next)}}function Qm(a,t){let e=t;const n=a.x,i=a.y;let r=-1/0,s;do{if(i<=e.y&&i>=e.next.y&&e.next.y!==e.y){const d=e.x+(i-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=n&&d>r){if(r=d,d===n){if(i===e.y)return e;if(i===e.next.y)return e.next}s=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!s)return null;if(n===r)return s;const o=s,l=s.x,h=s.y;let u=1/0,c;e=s;do n>=e.x&&e.x>=l&&n!==e.x&&Ii(i<h?n:r,i,l,h,i<h?r:n,i,e.x,e.y)&&(c=Math.abs(i-e.y)/(n-e.x),cr(e,a)&&(c<u||c===u&&(e.x>s.x||e.x===s.x&&$m(s,e)))&&(s=e,u=c)),e=e.next;while(e!==o);return s}function $m(a,t){return ce(a.prev,a,t.prev)<0&&ce(t.next,a,a.next)<0}function Km(a,t,e,n){let i=a;do i.z===null&&(i.z=So(i.x,i.y,t,e,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==a);i.prevZ.nextZ=null,i.prevZ=null,tv(i)}function tv(a){let t,e,n,i,r,s,o,l,h=1;do{for(e=a,a=null,r=null,s=0;e;){for(s++,n=e,o=0,t=0;t<h&&(o++,n=n.nextZ,!!n);t++);for(l=h;o>0||l>0&&n;)o!==0&&(l===0||!n||e.z<=n.z)?(i=e,e=e.nextZ,o--):(i=n,n=n.nextZ,l--),r?r.nextZ=i:a=i,i.prevZ=r,r=i;e=n}r.nextZ=null,h*=2}while(s>1);return a}function So(a,t,e,n,i){return a=32767*(a-e)*i,t=32767*(t-n)*i,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,a|t<<1}function ev(a){let t=a,e=a;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==a);return e}function Ii(a,t,e,n,i,r,s,o){return(i-s)*(t-o)-(a-s)*(r-o)>=0&&(a-s)*(n-o)-(e-s)*(t-o)>=0&&(e-s)*(r-o)-(i-s)*(n-o)>=0}function nv(a,t){return a.next.i!==t.i&&a.prev.i!==t.i&&!iv(a,t)&&(cr(a,t)&&cr(t,a)&&rv(a,t)&&(ce(a.prev,a,t.prev)||ce(a,t.prev,t))||ns(a,t)&&ce(a.prev,a,a.next)>0&&ce(t.prev,t,t.next)>0)}function ce(a,t,e){return(t.y-a.y)*(e.x-t.x)-(t.x-a.x)*(e.y-t.y)}function ns(a,t){return a.x===t.x&&a.y===t.y}function Ol(a,t,e,n){const i=rs(ce(a,t,e)),r=rs(ce(a,t,n)),s=rs(ce(e,n,a)),o=rs(ce(e,n,t));return!!(i!==r&&s!==o||i===0&&is(a,e,t)||r===0&&is(a,n,t)||s===0&&is(e,a,n)||o===0&&is(e,t,n))}function is(a,t,e){return t.x<=Math.max(a.x,e.x)&&t.x>=Math.min(a.x,e.x)&&t.y<=Math.max(a.y,e.y)&&t.y>=Math.min(a.y,e.y)}function rs(a){return a>0?1:a<0?-1:0}function iv(a,t){let e=a;do{if(e.i!==a.i&&e.next.i!==a.i&&e.i!==t.i&&e.next.i!==t.i&&Ol(e,e.next,a,t))return!0;e=e.next}while(e!==a);return!1}function cr(a,t){return ce(a.prev,a,a.next)<0?ce(a,t,a.next)>=0&&ce(a,a.prev,t)>=0:ce(a,t,a.prev)<0||ce(a,a.next,t)<0}function rv(a,t){let e=a,n=!1;const i=(a.x+t.x)/2,r=(a.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&i<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==a);return n}function Ul(a,t){const e=new Eo(a.i,a.x,a.y),n=new Eo(t.i,t.x,t.y),i=a.next,r=t.prev;return a.next=t,t.prev=a,e.next=i,i.prev=e,n.next=e,e.prev=n,r.next=n,n.prev=r,n}function Wl(a,t,e,n){const i=new Eo(a,t,e);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function hr(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function Eo(a,t,e){this.i=a,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function sv(a,t,e,n){let i=0;for(let r=t,s=e-n;r<e;r+=n)i+=(a[s]-a[r])*(a[r+1]+a[s+1]),s=r;return i}class Nn{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return n*.5}static isClockWise(t){return Nn.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];Gl(t),Hl(n,t);let s=t.length;e.forEach(Gl);for(let l=0;l<e.length;l++)i.push(s),s+=e[l].length,Hl(n,e[l]);const o=Hm.triangulate(n,i);for(let l=0;l<o.length;l+=3)r.push(o.slice(l,l+3));return r}}function Gl(a){const t=a.length;t>2&&a[t-1].equals(a[0])&&a.pop()}function Hl(a,t){for(let e=0;e<t.length;e++)a.push(t[e].x),a.push(t[e].y)}class Bi extends se{constructor(t=new ar([new Tt(.5,.5),new Tt(-.5,.5),new Tt(-.5,-.5),new Tt(.5,-.5)]),e={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let o=0,l=t.length;o<l;o++){const h=t[o];s(h)}this.setAttribute("position",new we(i,3)),this.setAttribute("uv",new we(r,2)),this.computeVertexNormals();function s(o){const l=[],h=e.curveSegments!==void 0?e.curveSegments:12,u=e.steps!==void 0?e.steps:1;let c=e.depth!==void 0?e.depth:1,d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,p=e.bevelThickness!==void 0?e.bevelThickness:.2,f=e.bevelSize!==void 0?e.bevelSize:p-.1,g=e.bevelOffset!==void 0?e.bevelOffset:0,y=e.bevelSegments!==void 0?e.bevelSegments:3;const m=e.extrudePath,v=e.UVGenerator!==void 0?e.UVGenerator:ov;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),c=e.amount);let _,x=!1,w,C,M,D;m&&(_=m.getSpacedPoints(u),x=!0,d=!1,w=m.computeFrenetFrames(u,!1),C=new G,M=new G,D=new G),d||(y=0,p=0,f=0,g=0);const j=o.extractPoints(h);let N=j.shape;const b=j.holes;if(!Nn.isClockWise(N)){N=N.reverse();for(let $=0,rt=b.length;$<rt;$++){const st=b[$];Nn.isClockWise(st)&&(b[$]=st.reverse())}}const V=Nn.triangulateShape(N,b),H=N;for(let $=0,rt=b.length;$<rt;$++){const st=b[$];N=N.concat(st)}function Y($,rt,st){return rt||console.error("THREE.ExtrudeGeometry: vec does not exist"),rt.clone().multiplyScalar(st).add($)}const Q=N.length,P=V.length;function z($,rt,st){let K,tt,Lt;const St=$.x-rt.x,zt=$.y-rt.y,Pt=st.x-$.x,L=st.y-$.y,E=St*St+zt*zt,at=St*L-zt*Pt;if(Math.abs(at)>Number.EPSILON){const ht=Math.sqrt(E),bt=Math.sqrt(Pt*Pt+L*L),Ct=rt.x-zt/ht,J=rt.y+St/ht,yt=st.x-L/bt,gt=st.y+Pt/bt,Rt=((yt-Ct)*L-(gt-J)*Pt)/(St*L-zt*Pt);K=Ct+St*Rt-$.x,tt=J+zt*Rt-$.y;const At=K*K+tt*tt;if(At<=2)return new Tt(K,tt);Lt=Math.sqrt(At/2)}else{let ht=!1;St>Number.EPSILON?Pt>Number.EPSILON&&(ht=!0):St<-Number.EPSILON?Pt<-Number.EPSILON&&(ht=!0):Math.sign(zt)===Math.sign(L)&&(ht=!0),ht?(K=-zt,tt=St,Lt=Math.sqrt(E)):(K=St,tt=zt,Lt=Math.sqrt(E/2))}return new Tt(K/Lt,tt/Lt)}const it=[];for(let $=0,rt=H.length,st=rt-1,K=$+1;$<rt;$++,st++,K++)st===rt&&(st=0),K===rt&&(K=0),it[$]=z(H[$],H[st],H[K]);const W=[];let T,Z=it.concat();for(let $=0,rt=b.length;$<rt;$++){const st=b[$];T=[];for(let K=0,tt=st.length,Lt=tt-1,St=K+1;K<tt;K++,Lt++,St++)Lt===tt&&(Lt=0),St===tt&&(St=0),T[K]=z(st[K],st[Lt],st[St]);W.push(T),Z=Z.concat(T)}for(let $=0;$<y;$++){const rt=$/y,st=p*Math.cos(rt*Math.PI/2),K=f*Math.sin(rt*Math.PI/2)+g;for(let tt=0,Lt=H.length;tt<Lt;tt++){const St=Y(H[tt],it[tt],K);ot(St.x,St.y,-st)}for(let tt=0,Lt=b.length;tt<Lt;tt++){const St=b[tt];T=W[tt];for(let zt=0,Pt=St.length;zt<Pt;zt++){const L=Y(St[zt],T[zt],K);ot(L.x,L.y,-st)}}}const A=f+g;for(let $=0;$<Q;$++){const rt=d?Y(N[$],Z[$],A):N[$];x?(M.copy(w.normals[0]).multiplyScalar(rt.x),C.copy(w.binormals[0]).multiplyScalar(rt.y),D.copy(_[0]).add(M).add(C),ot(D.x,D.y,D.z)):ot(rt.x,rt.y,0)}for(let $=1;$<=u;$++)for(let rt=0;rt<Q;rt++){const st=d?Y(N[rt],Z[rt],A):N[rt];x?(M.copy(w.normals[$]).multiplyScalar(st.x),C.copy(w.binormals[$]).multiplyScalar(st.y),D.copy(_[$]).add(M).add(C),ot(D.x,D.y,D.z)):ot(st.x,st.y,c/u*$)}for(let $=y-1;$>=0;$--){const rt=$/y,st=p*Math.cos(rt*Math.PI/2),K=f*Math.sin(rt*Math.PI/2)+g;for(let tt=0,Lt=H.length;tt<Lt;tt++){const St=Y(H[tt],it[tt],K);ot(St.x,St.y,c+st)}for(let tt=0,Lt=b.length;tt<Lt;tt++){const St=b[tt];T=W[tt];for(let zt=0,Pt=St.length;zt<Pt;zt++){const L=Y(St[zt],T[zt],K);x?ot(L.x,L.y+_[u-1].y,_[u-1].x+st):ot(L.x,L.y,c+st)}}}I(),R();function I(){const $=i.length/3;if(d){let rt=0,st=Q*rt;for(let K=0;K<P;K++){const tt=V[K];et(tt[2]+st,tt[1]+st,tt[0]+st)}rt=u+y*2,st=Q*rt;for(let K=0;K<P;K++){const tt=V[K];et(tt[0]+st,tt[1]+st,tt[2]+st)}}else{for(let rt=0;rt<P;rt++){const st=V[rt];et(st[2],st[1],st[0])}for(let rt=0;rt<P;rt++){const st=V[rt];et(st[0]+Q*u,st[1]+Q*u,st[2]+Q*u)}}n.addGroup($,i.length/3-$,0)}function R(){const $=i.length/3;let rt=0;F(H,rt),rt+=H.length;for(let st=0,K=b.length;st<K;st++){const tt=b[st];F(tt,rt),rt+=tt.length}n.addGroup($,i.length/3-$,1)}function F($,rt){let st=$.length;for(;--st>=0;){const K=st;let tt=st-1;tt<0&&(tt=$.length-1);for(let Lt=0,St=u+y*2;Lt<St;Lt++){const zt=Q*Lt,Pt=Q*(Lt+1),L=rt+K+zt,E=rt+tt+zt,at=rt+tt+Pt,ht=rt+K+Pt;k(L,E,at,ht)}}}function ot($,rt,st){l.push($),l.push(rt),l.push(st)}function et($,rt,st){nt($),nt(rt),nt(st);const K=i.length/3,tt=v.generateTopUV(n,i,K-3,K-2,K-1);lt(tt[0]),lt(tt[1]),lt(tt[2])}function k($,rt,st,K){nt($),nt(rt),nt(K),nt(rt),nt(st),nt(K);const tt=i.length/3,Lt=v.generateSideWallUV(n,i,tt-6,tt-3,tt-2,tt-1);lt(Lt[0]),lt(Lt[1]),lt(Lt[3]),lt(Lt[1]),lt(Lt[2]),lt(Lt[3])}function nt($){i.push(l[$*3+0]),i.push(l[$*3+1]),i.push(l[$*3+2])}function lt($){r.push($.x),r.push($.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return av(e,n,t)}static fromJSON(t,e){const n=[];for(let r=0,s=t.shapes.length;r<s;r++){const o=e[t.shapes[r]];n.push(o)}const i=t.options.extrudePath;return i!==void 0&&(t.options.extrudePath=new zl[i.type]().fromJSON(i)),new Bi(n,t.options)}}const ov={generateTopUV:function(a,t,e,n,i){const r=t[e*3],s=t[e*3+1],o=t[n*3],l=t[n*3+1],h=t[i*3],u=t[i*3+1];return[new Tt(r,s),new Tt(o,l),new Tt(h,u)]},generateSideWallUV:function(a,t,e,n,i,r){const s=t[e*3],o=t[e*3+1],l=t[e*3+2],h=t[n*3],u=t[n*3+1],c=t[n*3+2],d=t[i*3],p=t[i*3+1],f=t[i*3+2],g=t[r*3],y=t[r*3+1],m=t[r*3+2];return Math.abs(o-u)<Math.abs(s-h)?[new Tt(s,1-l),new Tt(h,1-c),new Tt(d,1-f),new Tt(g,1-m)]:[new Tt(o,1-l),new Tt(u,1-c),new Tt(p,1-f),new Tt(y,1-m)]}};function av(a,t,e){if(e.shapes=[],Array.isArray(a))for(let n=0,i=a.length;n<i;n++){const r=a[n];e.shapes.push(r.uuid)}else e.shapes.push(a.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class To extends se{constructor(t=new ar([new Tt(0,.5),new Tt(-.5,-.5),new Tt(.5,-.5)]),e=12){super();this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],s=[];let o=0,l=0;if(Array.isArray(t)===!1)h(t);else for(let u=0;u<t.length;u++)h(t[u]),this.addGroup(o,l,u),o+=l,l=0;this.setIndex(n),this.setAttribute("position",new we(i,3)),this.setAttribute("normal",new we(r,3)),this.setAttribute("uv",new we(s,2));function h(u){const c=i.length/3,d=u.extractPoints(e);let p=d.shape;const f=d.holes;Nn.isClockWise(p)===!1&&(p=p.reverse());for(let y=0,m=f.length;y<m;y++){const v=f[y];Nn.isClockWise(v)===!0&&(f[y]=v.reverse())}const g=Nn.triangulateShape(p,f);for(let y=0,m=f.length;y<m;y++){const v=f[y];p=p.concat(v)}for(let y=0,m=p.length;y<m;y++){const v=p[y];i.push(v.x,v.y,0),r.push(0,0,1),s.push(v.x,v.y)}for(let y=0,m=g.length;y<m;y++){const v=g[y],_=v[0]+c,x=v[1]+c,w=v[2]+c;n.push(_,x,w),l+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return lv(e,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const s=e[t.shapes[i]];n.push(s)}return new To(n,t.curveSegments)}}function lv(a,t){if(t.shapes=[],Array.isArray(a))for(let e=0,n=a.length;e<n;e++){const i=a[e];t.shapes.push(i.uuid)}else t.shapes.push(a.uuid);return t}class cv extends Ce{constructor(t){super();this.type="ShadowMaterial",this.color=new Ot(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}cv.prototype.isShadowMaterial=!0;class kl extends Ce{constructor(t){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ot(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=si,this.normalScale=new Tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}kl.prototype.isMeshStandardMaterial=!0;class hv extends kl{constructor(t){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Tt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ke(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenColor=new Ot(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Ot(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ot(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}hv.prototype.isMeshPhysicalMaterial=!0;class uv extends Ce{constructor(t){super();this.type="MeshPhongMaterial",this.color=new Ot(16777215),this.specular=new Ot(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=si,this.normalScale=new Tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=pr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}uv.prototype.isMeshPhongMaterial=!0;class dv extends Ce{constructor(t){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ot(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=si,this.normalScale=new Tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}dv.prototype.isMeshToonMaterial=!0;class pv extends Ce{constructor(t){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=si,this.normalScale=new Tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}pv.prototype.isMeshNormalMaterial=!0;class fv extends Ce{constructor(t){super();this.type="MeshLambertMaterial",this.color=new Ot(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ot(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=pr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}fv.prototype.isMeshLambertMaterial=!0;class mv extends Ce{constructor(t){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ot(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=si,this.normalScale=new Tt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}mv.prototype.isMeshMatcapMaterial=!0;class vv extends rr{constructor(t){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}vv.prototype.isLineDashedMaterial=!0;const oe={arraySlice:function(a,t,e){return oe.isTypedArray(a)?new a.constructor(a.subarray(t,e!==void 0?e:a.length)):a.slice(t,e)},convertArray:function(a,t,e){return!a||!e&&a.constructor===t?a:typeof t.BYTES_PER_ELEMENT=="number"?new t(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){function t(i,r){return a[i]-a[r]}const e=a.length,n=new Array(e);for(let i=0;i!==e;++i)n[i]=i;return n.sort(t),n},sortedArray:function(a,t,e){const n=a.length,i=new a.constructor(n);for(let r=0,s=0;s!==n;++r){const o=e[r]*t;for(let l=0;l!==t;++l)i[s++]=a[o+l]}return i},flattenJSON:function(a,t,e,n){let i=1,r=a[0];for(;r!==void 0&&r[n]===void 0;)r=a[i++];if(r===void 0)return;let s=r[n];if(s!==void 0)if(Array.isArray(s))do s=r[n],s!==void 0&&(t.push(r.time),e.push.apply(e,s)),r=a[i++];while(r!==void 0);else if(s.toArray!==void 0)do s=r[n],s!==void 0&&(t.push(r.time),s.toArray(e,e.length)),r=a[i++];while(r!==void 0);else do s=r[n],s!==void 0&&(t.push(r.time),e.push(s)),r=a[i++];while(r!==void 0)},subclip:function(a,t,e,n,i=30){const r=a.clone();r.name=t;const s=[];for(let l=0;l<r.tracks.length;++l){const h=r.tracks[l],u=h.getValueSize(),c=[],d=[];for(let p=0;p<h.times.length;++p){const f=h.times[p]*i;if(!(f<e||f>=n)){c.push(h.times[p]);for(let g=0;g<u;++g)d.push(h.values[p*u+g])}}c.length!==0&&(h.times=oe.convertArray(c,h.times.constructor),h.values=oe.convertArray(d,h.values.constructor),s.push(h))}r.tracks=s;let o=1/0;for(let l=0;l<r.tracks.length;++l)o>r.tracks[l].times[0]&&(o=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*o);return r.resetDuration(),r},makeClipAdditive:function(a,t=0,e=a,n=30){n<=0&&(n=30);const i=e.tracks.length,r=t/n;for(let s=0;s<i;++s){const o=e.tracks[s],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const h=a.tracks.find(function(m){return m.name===o.name&&m.ValueTypeName===l});if(h===void 0)continue;let u=0;const c=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=c/3);let d=0;const p=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const f=o.times.length-1;let g;if(r<=o.times[0]){const m=u,v=c-u;g=oe.arraySlice(o.values,m,v)}else if(r>=o.times[f]){const m=f*c+u,v=m+c-u;g=oe.arraySlice(o.values,m,v)}else{const m=o.createInterpolant(),v=u,_=c-u;m.evaluate(r),g=oe.arraySlice(m.resultBuffer,v,_)}l==="quaternion"&&new Ve().fromArray(g).normalize().conjugate().toArray(g);const y=h.times.length;for(let m=0;m<y;++m){const v=m*p+d;if(l==="quaternion")Ve.multiplyQuaternionsFlat(h.values,v,g,0,h.values,v);else{const _=p-d*2;for(let x=0;x<_;++x)h.values[v+x]-=g[x]}}}return a.blendMode=sa,a}};class zn{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let s;n:{i:if(!(t<i)){for(let o=n+2;;){if(i===void 0){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,r)}if(n===o)break;if(r=i,i=e[++n],t<i)break e}s=e.length;break n}if(!(t>=r)){const o=e[1];t<o&&(n=2,r=o);for(let l=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(n===l)break;if(i=r,r=e[--n-1],t>=r)break e}s=n,n=0;break n}break t}for(;n<s;){const o=n+s>>>1;t<e[o]?s=o:n=o+1}if(i=e[n],r=e[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,i);if(i===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,r,t)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let s=0;s!==i;++s)e[s]=n[r+s];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}zn.prototype.beforeStart_=zn.prototype.copySampleValue_;zn.prototype.afterEnd_=zn.prototype.copySampleValue_;class gv extends zn{constructor(t,e,n,i){super(t,e,n,i);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ii,endingEnd:ii}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,s=t+1,o=i[r],l=i[s];if(o===void 0)switch(this.getSettings_().endingStart){case ri:r=t,o=2*e-n;break;case xr:r=i.length-2,o=e+i[r]-i[r+1];break;default:r=t,o=n}if(l===void 0)switch(this.getSettings_().endingEnd){case ri:s=t,l=2*n-e;break;case xr:s=1,l=n+i[1]-i[0];break;default:s=t-1,l=e}const h=(n-e)*.5,u=this.valueSize;this._weightPrev=h/(e-o),this._weightNext=h/(l-n),this._offsetPrev=r*u,this._offsetNext=s*u}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,l=t*o,h=l-o,u=this._offsetPrev,c=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(n-e)/(i-e),g=f*f,y=g*f,m=-d*y+2*d*g-d*f,v=(1+d)*y+(-1.5-2*d)*g+(-.5+d)*f+1,_=(-1-p)*y+(1.5+p)*g+.5*f,x=p*y-p*g;for(let w=0;w!==o;++w)r[w]=m*s[u+w]+v*s[h+w]+_*s[l+w]+x*s[c+w];return r}}class ql extends zn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,l=t*o,h=l-o,u=(n-e)/(i-e),c=1-u;for(let d=0;d!==o;++d)r[d]=s[h+d]*c+s[l+d]*u;return r}}class yv extends zn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class cn{constructor(t,e,n,i){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=oe.convertArray(e,this.TimeBufferType),this.values=oe.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:oe.convertArray(t.times,Array),values:oe.convertArray(t.values,Array)};const i=t.getInterpolation();i!==t.DefaultInterpolation&&(n.interpolation=i)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new yv(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new ql(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new gv(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case gr:e=this.InterpolantFactoryMethodDiscrete;break;case yr:e=this.InterpolantFactoryMethodLinear;break;case gs:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return gr;case this.InterpolantFactoryMethodLinear:return yr;case this.InterpolantFactoryMethodSmooth:return gs}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<t;)++r;for(;s!==-1&&n[s]>e;)--s;if(++s,r!==0||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const o=this.getValueSize();this.times=oe.arraySlice(n,r,s),this.values=oe.arraySlice(this.values,r*o,s*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let o=0;o!==r;o++){const l=n[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),t=!1;break}if(s!==null&&s>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,s),t=!1;break}s=l}if(i!==void 0&&oe.isTypedArray(i))for(let o=0,l=i.length;o!==l;++o){const h=i[o];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,h),t=!1;break}}return t}optimize(){const t=oe.arraySlice(this.times),e=oe.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===gs,r=t.length-1;let s=1;for(let o=1;o<r;++o){let l=!1;const h=t[o],u=t[o+1];if(h!==u&&(o!==1||h!==t[0]))if(i)l=!0;else{const c=o*n,d=c-n,p=c+n;for(let f=0;f!==n;++f){const g=e[c+f];if(g!==e[d+f]||g!==e[p+f]){l=!0;break}}}if(l){if(o!==s){t[s]=t[o];const c=o*n,d=s*n;for(let p=0;p!==n;++p)e[d+p]=e[c+p]}++s}}if(r>0){t[s]=t[r];for(let o=r*n,l=s*n,h=0;h!==n;++h)e[l+h]=e[o+h];++s}return s!==t.length?(this.times=oe.arraySlice(t,0,s),this.values=oe.arraySlice(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=oe.arraySlice(this.times,0),e=oe.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}cn.prototype.TimeBufferType=Float32Array;cn.prototype.ValueBufferType=Float32Array;cn.prototype.DefaultInterpolation=yr;class Fi extends cn{}Fi.prototype.ValueTypeName="bool";Fi.prototype.ValueBufferType=Array;Fi.prototype.DefaultInterpolation=gr;Fi.prototype.InterpolantFactoryMethodLinear=void 0;Fi.prototype.InterpolantFactoryMethodSmooth=void 0;class Xl extends cn{}Xl.prototype.ValueTypeName="color";class ss extends cn{}ss.prototype.ValueTypeName="number";class xv extends zn{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,l=(n-e)/(i-e);let h=t*o;for(let u=h+o;h!==u;h+=4)Ve.slerpFlat(r,0,s,h-o,s,h,l);return r}}class ur extends cn{InterpolantFactoryMethodLinear(t){return new xv(this.times,this.values,this.getValueSize(),t)}}ur.prototype.ValueTypeName="quaternion";ur.prototype.DefaultInterpolation=yr;ur.prototype.InterpolantFactoryMethodSmooth=void 0;class Di extends cn{}Di.prototype.ValueTypeName="string";Di.prototype.ValueBufferType=Array;Di.prototype.DefaultInterpolation=gr;Di.prototype.InterpolantFactoryMethodLinear=void 0;Di.prototype.InterpolantFactoryMethodSmooth=void 0;class os extends cn{}os.prototype.ValueTypeName="vector";class Yl{constructor(t,e=-1,n,i=ys){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=on(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let s=0,o=n.length;s!==o;++s)e.push(wv(n[s]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,s=n.length;r!==s;++r)e.push(cn.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,s=[];for(let o=0;o<r;o++){let l=[],h=[];l.push((o+r-1)%r,o,(o+1)%r),h.push(0,1,0);const u=oe.getKeyframeOrder(l);l=oe.sortedArray(l,1,u),h=oe.sortedArray(h,1,u),!i&&l[0]===0&&(l.push(r),h.push(h[0])),s.push(new ss(".morphTargetInfluences["+e[o].name+"]",l,h).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const i=t;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===e)return n[i];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=t.length;o<l;o++){const h=t[o],u=h.name.match(r);if(u&&u.length>1){const c=u[1];let d=i[c];d||(i[c]=d=[]),d.push(h)}}const s=[];for(const o in i)s.push(this.CreateFromMorphTargetSequence(o,i[o],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(c,d,p,f,g){if(p.length!==0){const y=[],m=[];oe.flattenJSON(p,y,m,f),y.length!==0&&g.push(new c(d,y,m))}},i=[],r=t.name||"default",s=t.fps||30,o=t.blendMode;let l=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const d=h[c].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let g=0;g<d[f].morphTargets.length;g++)p[d[f].morphTargets[g]]=-1;for(const g in p){const y=[],m=[];for(let v=0;v!==d[f].morphTargets.length;++v){const _=d[f];y.push(_.time),m.push(_.morphTarget===g?1:0)}i.push(new ss(".morphTargetInfluence["+g+"]",y,m))}l=p.length*(s||1)}else{const p=".bones["+e[c].name+"]";n(os,p+".position",d,"pos",i),n(ur,p+".quaternion",d,"rot",i),n(os,p+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,o)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n!==i;++n){const r=this.tracks[n];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function _v(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ss;case"vector":case"vector2":case"vector3":case"vector4":return os;case"color":return Xl;case"quaternion":return ur;case"bool":case"boolean":return Fi;case"string":return Di}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}function wv(a){if(a.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=_v(a.type);if(a.times===void 0){const e=[],n=[];oe.flattenJSON(a.keys,e,n,"value"),a.times=e,a.values=n}return t.parse!==void 0?t.parse(a):new t(a.name,a.times,a.values,a.interpolation)}const Ni={enabled:!1,files:{},add:function(a,t){this.enabled!==!1&&(this.files[a]=t)},get:function(a){if(this.enabled!==!1)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};class Mv{constructor(t,e,n){const i=this;let r=!1,s=0,o=0,l;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(u){o++,r===!1&&i.onStart!==void 0&&i.onStart(u,s,o),r=!0},this.itemEnd=function(u){s++,i.onProgress!==void 0&&i.onProgress(u,s,o),s===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,c){return h.push(u,c),this},this.removeHandler=function(u){const c=h.indexOf(u);return c!==-1&&h.splice(c,2),this},this.getHandler=function(u){for(let c=0,d=h.length;c<d;c+=2){const p=h[c],f=h[c+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const bv=new Mv;class Vn{constructor(t){this.manager=t!==void 0?t:bv,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,r){n.load(t,i,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const wn={};class Sv extends Vn{constructor(t){super(t)}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=Ni.get(t);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(wn[t]!==void 0){wn[t].push({onLoad:e,onProgress:n,onError:i});return}wn[t]=[],wn[t].push({onLoad:e,onProgress:n,onError:i});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(s).then(o=>{if(o.status===200||o.status===0){o.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const l=wn[t],h=o.body.getReader(),u=o.headers.get("Content-Length"),c=u?parseInt(u):0,d=c!==0;let p=0;return new ReadableStream({start(f){g();function g(){h.read().then(({done:y,value:m})=>{if(y)f.close();else{p+=m.byteLength;const v=new ProgressEvent("progress",{lengthComputable:d,loaded:p,total:c});for(let _=0,x=l.length;_<x;_++){const w=l[_];w.onProgress&&w.onProgress(v)}f.enqueue(m),g()}})}}})}else throw Error(`fetch for "${o.url}" responded with ${o.status}: ${o.statusText}`)}).then(o=>{const l=new Response(o);switch(this.responseType){case"arraybuffer":return l.arrayBuffer();case"blob":return l.blob();case"document":return l.text().then(h=>new DOMParser().parseFromString(h,this.mimeType));case"json":return l.json();default:return l.text()}}).then(o=>{Ni.add(t,o);const l=wn[t];delete wn[t];for(let h=0,u=l.length;h<u;h++){const c=l[h];c.onLoad&&c.onLoad(o)}this.manager.itemEnd(t)}).catch(o=>{const l=wn[t];delete wn[t];for(let h=0,u=l.length;h<u;h++){const c=l[h];c.onError&&c.onError(o)}this.manager.itemError(t),this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Zl extends Vn{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Ni.get(t);if(s!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o=Mr("img");function l(){u(),Ni.add(t,this),e&&e(this),r.manager.itemEnd(t)}function h(c){u(),i&&i(c),r.manager.itemError(t),r.manager.itemEnd(t)}function u(){o.removeEventListener("load",l,!1),o.removeEventListener("error",h,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",h,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(t),o.src=t,o}}class Ev extends Vn{constructor(t){super(t)}load(t,e,n,i){const r=new Or,s=new Zl(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function l(h){s.load(t[h],function(u){r.images[h]=u,o++,o===6&&(r.needsUpdate=!0,e&&e(r))},void 0,i)}for(let h=0;h<t.length;++h)l(h);return r}}class Tv extends Vn{constructor(t){super(t)}load(t,e,n,i){const r=new Te,s=new Zl(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,function(o){r.image=o,r.needsUpdate=!0,e!==void 0&&e(r)},n,i),r}}class hn extends Qt{constructor(t,e=1){super();this.type="Light",this.color=new Ot(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}hn.prototype.isLight=!0;class Av extends hn{constructor(t,e,n){super(t,n);this.type="HemisphereLight",this.position.copy(Qt.DefaultUp),this.updateMatrix(),this.groundColor=new Ot(e)}copy(t){return hn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}Av.prototype.isHemisphereLight=!0;const jl=new Wt,Jl=new G,Ql=new G;class Ao{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Tt(512,512),this.map=null,this.mapPass=null,this.matrix=new Wt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Wr,this._frameExtents=new Tt(1,1),this._viewportCount=1,this._viewports=[new ee(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Jl.setFromMatrixPosition(t.matrixWorld),e.position.copy(Jl),Ql.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Ql),e.updateMatrixWorld(),jl.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(jl),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class $l extends Ao{constructor(){super(new Ue(50,1,.5,500));this.focus=1}updateMatrices(t){const e=this.camera,n=bs*2*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;(n!==e.fov||i!==e.aspect||r!==e.far)&&(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}$l.prototype.isSpotLightShadow=!0;class Cv extends hn{constructor(t,e,n=0,i=Math.PI/3,r=0,s=1){super(t,e);this.type="SpotLight",this.position.copy(Qt.DefaultUp),this.updateMatrix(),this.target=new Qt,this.distance=n,this.angle=i,this.penumbra=r,this.decay=s,this.shadow=new $l}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Cv.prototype.isSpotLight=!0;const Kl=new Wt,dr=new G,Co=new G;class tc extends Ao{constructor(){super(new Ue(90,1,.5,500));this._frameExtents=new Tt(4,2),this._viewportCount=6,this._viewports=[new ee(2,1,1,1),new ee(0,1,1,1),new ee(3,1,1,1),new ee(1,1,1,1),new ee(3,0,1,1),new ee(1,0,1,1)],this._cubeDirections=[new G(1,0,0),new G(-1,0,0),new G(0,0,1),new G(0,0,-1),new G(0,1,0),new G(0,-1,0)],this._cubeUps=[new G(0,1,0),new G(0,1,0),new G(0,1,0),new G(0,1,0),new G(0,0,1),new G(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),dr.setFromMatrixPosition(t.matrixWorld),n.position.copy(dr),Co.copy(n.position),Co.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Co),n.updateMatrixWorld(),i.makeTranslation(-dr.x,-dr.y,-dr.z),Kl.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Kl)}}tc.prototype.isPointLightShadow=!0;class Rv extends hn{constructor(t,e,n=0,i=1){super(t,e);this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new tc}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Rv.prototype.isPointLight=!0;class ec extends Ao{constructor(){super(new Ks(-5,5,5,-5,.5,500))}}ec.prototype.isDirectionalLightShadow=!0;class Lv extends hn{constructor(t,e){super(t,e);this.type="DirectionalLight",this.position.copy(Qt.DefaultUp),this.updateMatrix(),this.target=new Qt,this.shadow=new ec}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Lv.prototype.isDirectionalLight=!0;class Pv extends hn{constructor(t,e){super(t,e);this.type="AmbientLight"}}Pv.prototype.isAmbientLight=!0;class Iv extends hn{constructor(t,e,n=10,i=10){super(t,e);this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Iv.prototype.isRectAreaLight=!0;class nc{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new G)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],1.092548*(n*i)),e.addScaledVector(s[5],1.092548*(i*r)),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],1.092548*(n*r)),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],2*.511664*i),e.addScaledVector(s[2],2*.511664*r),e.addScaledVector(s[3],2*.511664*n),e.addScaledVector(s[4],2*.429043*n*i),e.addScaledVector(s[5],2*.429043*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],2*.429043*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+i*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+i*3);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}nc.prototype.isSphericalHarmonics3=!0;class Ro extends hn{constructor(t=new nc,e=1){super(void 0,e);this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Ro.prototype.isLightProbe=!0;class Bv{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Fv extends se{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}Fv.prototype.isInstancedBufferGeometry=!0;class Dv extends Vn{constructor(t){super(t);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=Ni.get(t);if(s!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(s),r.manager.itemEnd(t)},0),s;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(t,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){Ni.add(t,l),e&&e(l),r.manager.itemEnd(t)}).catch(function(l){i&&i(l),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}Dv.prototype.isImageBitmapLoader=!0;let as;const Nv={getContext:function(){return as===void 0&&(as=new(window.AudioContext||window.webkitAudioContext)),as},setContext:function(a){as=a}};class zv extends Vn{constructor(t){super(t)}load(t,e,n,i){const r=this,s=new Sv(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,function(o){try{const l=o.slice(0);Nv.getContext().decodeAudioData(l,function(u){e(u)})}catch(l){i?i(l):console.error(l),r.manager.itemError(t)}},n,i)}}class Vv extends Ro{constructor(t,e,n=1){super(void 0,n);const i=new Ot().set(t),r=new Ot().set(e),s=new G(i.r,i.g,i.b),o=new G(r.r,r.g,r.b),l=Math.sqrt(Math.PI),h=l*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(l),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(h)}}Vv.prototype.isHemisphereLightProbe=!0;class Ov extends Ro{constructor(t,e=1){super(void 0,e);const n=new Ot().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Ov.prototype.isAmbientLightProbe=!0;class Uv extends Qt{constructor(t){super();this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class Wv{constructor(t,e,n){this.binding=t,this.valueSize=n;let i,r,s;switch(e){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let s=this.cumulativeWeight;if(s===0){for(let o=0;o!==i;++o)n[r+o]=n[o];s=e}else{s+=e;const o=e/s;this._mixBufferRegion(n,r,0,o,i)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=e*this._origIndex;this._mixBufferRegion(n,i,l,1-r,e)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let l=e,h=e+e;l!==h;++l)if(n[l]!==n[l+e]){o.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let r=n,s=i;r!==s;++r)e[r]=e[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let s=0;s!==r;++s)t[e+s]=t[n+s]}_slerp(t,e,n,i){Ve.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const s=this._workIndex*r;Ve.multiplyQuaternionsFlat(t,s,t,e,t,n),Ve.slerpFlat(t,e,t,e,t,s,i)}_lerp(t,e,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const l=e+o;t[l]=t[l]*s+t[n+o]*i}}_lerpAdditive(t,e,n,i,r){for(let s=0;s!==r;++s){const o=e+s;t[o]=t[o]+t[n+s]*i}}}const Lo="\\[\\]\\.:\\/",Gv=new RegExp("["+Lo+"]","g"),Po="[^"+Lo+"]",Hv="[^"+Lo.replace("\\.","")+"]",kv=/((?:WC+[\/:])*)/.source.replace("WC",Po),qv=/(WCOD+)?/.source.replace("WCOD",Hv),Xv=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Po),Yv=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Po),Zv=new RegExp("^"+kv+qv+Xv+Yv+"$"),jv=["material","materials","bones"];class Jv{constructor(t,e,n){const i=n||$t.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class $t{constructor(t,e,n){this.path=e,this.parsedPath=n||$t.parseTrackName(e),this.node=$t.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new $t.Composite(t,e,n):new $t(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Gv,"")}static parseTrackName(t){const e=Zv.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);jv.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(r){for(let s=0;s<r.length;s++){const o=r[s];if(o.name===e||o.uuid===e)return o;const l=n(o.children);if(l)return l}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=$t.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let h=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let u=0;u<t.length;u++)if(t[u].name===h){h=u;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(h!==void 0){if(t[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[h]}}const s=t[i];if(s===void 0){const h=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+i+" but it wasn't found.",t);return}let o=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else s.fromArray!==void 0&&s.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(l=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}$t.Composite=Jv;$t.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};$t.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};$t.prototype.GetterByBindingType=[$t.prototype._getValue_direct,$t.prototype._getValue_array,$t.prototype._getValue_arrayElement,$t.prototype._getValue_toArray];$t.prototype.SetterByBindingTypeAndVersioning=[[$t.prototype._setValue_direct,$t.prototype._setValue_direct_setNeedsUpdate,$t.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[$t.prototype._setValue_array,$t.prototype._setValue_array_setNeedsUpdate,$t.prototype._setValue_array_setMatrixWorldNeedsUpdate],[$t.prototype._setValue_arrayElement,$t.prototype._setValue_arrayElement_setNeedsUpdate,$t.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[$t.prototype._setValue_fromArray,$t.prototype._setValue_fromArray_setNeedsUpdate,$t.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Qv{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,s=r.length,o=new Array(s),l={endingStart:ii,endingEnd:ii};for(let h=0;h!==s;++h){const u=r[h].createInterpolant(null);o[h]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Ih,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const i=this._clip.duration,r=t._clip.duration,s=r/i,o=i/r;t.warp(1,s,e),this.warp(o,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,s=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,h=o.sampleValues;return l[0]=r,l[1]=r+n,h[0]=t/s,h[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled){this._updateWeight(t);return}const r=this._startTime;if(r!==null){const l=(t-r)*n;if(l<0||n===0)return;this._startTime=null,e=n*l}e*=this._updateTimeScale(t);const s=this._updateTime(e),o=this._updateWeight(t);if(o>0){const l=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case sa:for(let u=0,c=l.length;u!==c;++u)l[u].evaluate(s),h[u].accumulateAdditive(o);break;case ys:default:for(let u=0,c=l.length;u!==c;++u)l[u].evaluate(s),h[u].accumulate(i,o)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const s=n===Bh;if(t===0)return r===-1?i:s&&(r&1)==1?e-i:i;if(n===Ph){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else if(i<0)i=0;else{this.time=i;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,s)):this._setEndings(this.repetitions===0,!0,s)),i>=e||i<0){const o=Math.floor(i/e);i-=e*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const h=t<0;this._setEndings(h,!h,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(s&&(r&1)==1)return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=ri,i.endingEnd=ri):(t?i.endingStart=this.zeroSlopeAtStart?ri:ii:i.endingStart=xr,e?i.endingEnd=this.zeroSlopeAtEnd?ri:ii:i.endingEnd=xr)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let s=this._weightInterpolant;s===null&&(s=i._lendControlInterpolant(),this._weightInterpolant=s);const o=s.parameterPositions,l=s.sampleValues;return o[0]=r,l[0]=e,o[1]=r+t,l[1]=n,this}}class $v extends qn{constructor(t){super();this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,s=t._propertyBindings,o=t._interpolants,l=n.uuid,h=this._bindingsByRootAndName;let u=h[l];u===void 0&&(u={},h[l]=u);for(let c=0;c!==r;++c){const d=i[c],p=d.name;let f=u[p];if(f!==void 0)s[c]=f;else{if(f=s[c],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const g=e&&e._propertyBindings[c].binding.parsedPath;f=new Wv($t.create(n,p,g),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),s[c]=f}o[c].resultBuffer=f.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,i=t._clip.uuid,r=this._actionsByClip[i];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,i,n)}const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];r.useCount++==0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];--r.useCount==0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let s=r[e];if(s===void 0)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=s;else{const o=s.knownActions;t._byClipCacheIndex=o.length,o.push(t)}t._cacheIndex=i.length,i.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,s=this._actionsByClip,o=s[r],l=o.knownActions,h=l[l.length-1],u=t._byClipCacheIndex;h._byClipCacheIndex=u,l[u]=h,l.pop(),t._byClipCacheIndex=null;const c=o.actionByRoot,d=(t._localRoot||this._root).uuid;delete c[d],l.length===0&&delete s[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,i=e.length;n!==i;++n){const r=e[n];--r.referenceCount==0&&this._removeInactiveBinding(r)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[e];s===void 0&&(s={},i[e]=s),s[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],l=e[e.length-1],h=t._cacheIndex;l._cacheIndex=h,e[h]=l,e.pop(),delete o[r],Object.keys(o).length===0&&delete s[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new ql(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let s=typeof t=="string"?Yl.findByName(i,t):t;const o=s!==null?s.uuid:t,l=this._actionsByClip[o];let h=null;if(n===void 0&&(s!==null?n=s.blendMode:n=ys),l!==void 0){const c=l.actionByRoot[r];if(c!==void 0&&c.blendMode===n)return c;h=l.knownActions[0],s===null&&(s=h._clip)}if(s===null)return null;const u=new Qv(this,s,e,n);return this._bindAction(u,h),this._addInactiveAction(u,o,r),u}existingAction(t,e){const n=e||this._root,i=n.uuid,r=typeof t=="string"?Yl.findByName(n,t):t,s=r?r.uuid:t,o=this._actionsByClip[s];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),s=this._accuIndex^=1;for(let h=0;h!==n;++h)e[h]._update(i,t,r,s);const o=this._bindings,l=this._nActiveBindings;for(let h=0;h!==l;++h)o[h].apply(s);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const s=r.knownActions;for(let o=0,l=s.length;o!==l;++o){const h=s[o];this._deactivateAction(h);const u=h._cacheIndex,c=e[e.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,c._cacheIndex=u,e[u]=c,e.pop(),this._removeInactiveBindingsForAction(h)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const s in n){const o=n[s].actionByRoot,l=o[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[e];if(r!==void 0)for(const s in r){const o=r[s];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}$v.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Kv extends $i{constructor(t,e,n=1){super(t,e);this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}Kv.prototype.isInstancedInterleavedBuffer=!0;const On=new G,ls=new Wt,Io=new Wt;class tg extends fo{constructor(t){const e=ic(t),n=new se,i=[],r=[],s=new Ot(0,0,1),o=new Ot(0,1,0);for(let h=0;h<e.length;h++){const u=e[h];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(s.r,s.g,s.b),r.push(o.r,o.g,o.b))}n.setAttribute("position",new we(i,3)),n.setAttribute("color",new we(r,3));const l=new rr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");Io.copy(this.root.matrixWorld).invert();for(let r=0,s=0;r<e.length;r++){const o=e[r];o.parent&&o.parent.isBone&&(ls.multiplyMatrices(Io,o.matrixWorld),On.setFromMatrixPosition(ls),i.setXYZ(s,On.x,On.y,On.z),ls.multiplyMatrices(Io,o.parent.matrixWorld),On.setFromMatrixPosition(ls),i.setXYZ(s+1,On.x,On.y,On.z),s+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function ic(a){const t=[];a&&a.isBone&&t.push(a);for(let e=0;e<a.children.length;e++)t.push.apply(t,ic(a.children[e]));return t}class eg extends fo{constructor(t=10,e=10,n=4473924,i=8947848){n=new Ot(n),i=new Ot(i);const r=e/2,s=t/e,o=t/2,l=[],h=[];for(let d=0,p=0,f=-o;d<=e;d++,f+=s){l.push(-o,0,f,o,0,f),l.push(f,0,-o,f,0,o);const g=d===r?n:i;g.toArray(h,p),p+=3,g.toArray(h,p),p+=3,g.toArray(h,p),p+=3,g.toArray(h,p),p+=3}const u=new se;u.setAttribute("position",new we(l,3)),u.setAttribute("color",new we(h,3));const c=new rr({vertexColors:!0,toneMapped:!1});super(u,c);this.type="GridHelper"}}const ng=new Float32Array(1);new Int32Array(ng.buffer);Qe.create=function(a,t){return console.log("THREE.Curve.create() has been deprecated"),a.prototype=Object.create(Qe.prototype),a.prototype.constructor=a,a.prototype.getPoint=t,a};bo.prototype.fromPoints=function(a){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(a)};eg.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};tg.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Vn.prototype.extractUrlBase=function(a){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Bv.extractUrlBase(a)};Vn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Ke.prototype.center=function(a){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(a)};Ke.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Ke.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)};Ke.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)};Ke.prototype.size=function(a){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(a)};ui.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Wr.prototype.setFromMatrix=function(a){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(a)};Ee.prototype.flattenToArrayOffset=function(a,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,t)};Ee.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)};Ee.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Ee.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)};Ee.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Ee.prototype.getInverse=function(a){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()};Wt.prototype.extractPosition=function(a){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(a)};Wt.prototype.flattenToArrayOffset=function(a,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,t)};Wt.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new G().setFromMatrixColumn(this,3)};Wt.prototype.setRotationFromQuaternion=function(a){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(a)};Wt.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Wt.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};Wt.prototype.multiplyVector4=function(a){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};Wt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Wt.prototype.rotateAxis=function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),a.transformDirection(this)};Wt.prototype.crossVector=function(a){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};Wt.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Wt.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Wt.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Wt.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Wt.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Wt.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)};Wt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Wt.prototype.makeFrustum=function(a,t,e,n,i,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(a,t,n,e,i,r)};Wt.prototype.getInverse=function(a){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()};_n.prototype.isIntersectionLine=function(a){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(a)};Ve.prototype.multiplyVector3=function(a){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),a.applyQuaternion(this)};Ve.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};di.prototype.isIntersectionBox=function(a){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)};di.prototype.isIntersectionPlane=function(a){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(a)};di.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)};ve.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};ve.prototype.barycoordFromPoint=function(a,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(a,t)};ve.prototype.midpoint=function(a){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(a)};ve.prototypenormal=function(a){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(a)};ve.prototype.plane=function(a){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(a)};ve.barycoordFromPoint=function(a,t,e,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),ve.getBarycoord(a,t,e,n,i)};ve.normal=function(a,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),ve.getNormal(a,t,e,n)};ar.prototype.extractAllPoints=function(a){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(a)};ar.prototype.extrude=function(a){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Bi(this,a)};ar.prototype.makeGeometry=function(a){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new To(this,a)};Tt.prototype.fromAttribute=function(a,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,t,e)};Tt.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)};Tt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};G.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};G.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};G.prototype.getPositionFromMatrix=function(a){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(a)};G.prototype.getScaleFromMatrix=function(a){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(a)};G.prototype.getColumnFromMatrix=function(a,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,a)};G.prototype.applyProjection=function(a){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(a)};G.prototype.fromAttribute=function(a,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,t,e)};G.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)};G.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};ee.prototype.fromAttribute=function(a,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,t,e)};ee.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Qt.prototype.getChildByName=function(a){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(a)};Qt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Qt.prototype.translate=function(a,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,a)};Qt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Qt.prototype.applyMatrix=function(a){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)};Object.defineProperties(Qt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Oe.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Oe.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Fh},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});wl.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Ue.prototype.setLens=function(a,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(a)};Object.defineProperties(hn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=a}}});Object.defineProperties(ye.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===wr},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(wr)}}});ye.prototype.setDynamic=function(a){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(a===!0?wr:Hi),this};ye.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ye.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};se.prototype.addIndex=function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(a)};se.prototype.addAttribute=function(a,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(a,new ye(arguments[1],arguments[2]))):a==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(a,t)};se.prototype.addDrawCall=function(a,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(a,t)};se.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};se.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};se.prototype.removeAttribute=function(a){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(a)};se.prototype.applyMatrix=function(a){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)};Object.defineProperties(se.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});$i.prototype.setDynamic=function(a){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(a===!0?wr:Hi),this};$i.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Bi.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Bi.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Bi.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};dl.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Ce.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ot}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=a===Vo}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(a){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=a}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Zn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=a}}});Kt.prototype.clearTarget=function(a,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(a),this.clear(t,e,n)};Kt.prototype.animate=function(a){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(a)};Kt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Kt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Kt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Kt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Kt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Kt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Kt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Kt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Kt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Kt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Kt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Kt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Kt.prototype.enableScissorTest=function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(a)};Kt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Kt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Kt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Kt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Kt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Kt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Kt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Kt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Kt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Kt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Kt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(a){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=a===!0?_r:ze}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(hl.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(je.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=a}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=a}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=a}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=a}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=a}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=a}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=a}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=a}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=a}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=a}}});Uv.prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new zv().load(a,function(n){t.setBuffer(n)}),this};Js.prototype.updateCubeMap=function(a,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(a,t)};Js.prototype.clear=function(a,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(a,t,e,n)};ai.crossOrigin=void 0;ai.loadTexture=function(a,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new Tv;i.setCrossOrigin(this.crossOrigin);const r=i.load(a,e,void 0,n);return t&&(r.mapping=t),r};ai.loadTextureCube=function(a,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new Ev;i.setCrossOrigin(this.crossOrigin);const r=i.load(a,e,void 0,n);return t&&(r.mapping=t),r};ai.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};ai.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:hs}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=hs);function cs(a){throw new Error('Could not dynamically require "'+a+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var ig={exports:{}};(function(a,t){(function(e){a.exports=e()})(function(){return function e(n,i,r){function s(h,u){if(!i[h]){if(!n[h]){var c=typeof cs=="function"&&cs;if(!u&&c)return c(h,!0);if(o)return o(h,!0);throw new Error("Cannot find module '"+h+"'")}var d=i[h]={exports:{}};n[h][0].call(d.exports,function(p){var f=n[h][1][p];return s(f||p)},d,d.exports,e,n,i,r)}return i[h].exports}for(var o=typeof cs=="function"&&cs,l=0;l<r.length;l++)s(r[l]);return s}({1:[function(e,n,i){n.exports={name:"cannon",version:"0.6.2",description:"A lightweight 3D physics engine written in JavaScript.",homepage:"https://github.com/schteppe/cannon.js",author:"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",keywords:["cannon.js","cannon","physics","engine","3d"],main:"./build/cannon.js",engines:{node:"*"},repository:{type:"git",url:"https://github.com/schteppe/cannon.js.git"},bugs:{url:"https://github.com/schteppe/cannon.js/issues"},licenses:[{type:"MIT"}],devDependencies:{jshint:"latest","uglify-js":"latest",nodeunit:"^0.9.0",grunt:"~0.4.0","grunt-contrib-jshint":"~0.1.1","grunt-contrib-nodeunit":"^0.4.1","grunt-contrib-concat":"~0.1.3","grunt-contrib-uglify":"^0.5.1","grunt-browserify":"^2.1.4","grunt-contrib-yuidoc":"^0.5.2",browserify:"*"},dependencies:{}}},{}],2:[function(e,n,i){n.exports={version:e("../package.json").version,AABB:e("./collision/AABB"),ArrayCollisionMatrix:e("./collision/ArrayCollisionMatrix"),Body:e("./objects/Body"),Box:e("./shapes/Box"),Broadphase:e("./collision/Broadphase"),Constraint:e("./constraints/Constraint"),ContactEquation:e("./equations/ContactEquation"),Narrowphase:e("./world/Narrowphase"),ConeTwistConstraint:e("./constraints/ConeTwistConstraint"),ContactMaterial:e("./material/ContactMaterial"),ConvexPolyhedron:e("./shapes/ConvexPolyhedron"),Cylinder:e("./shapes/Cylinder"),DistanceConstraint:e("./constraints/DistanceConstraint"),Equation:e("./equations/Equation"),EventTarget:e("./utils/EventTarget"),FrictionEquation:e("./equations/FrictionEquation"),GSSolver:e("./solver/GSSolver"),GridBroadphase:e("./collision/GridBroadphase"),Heightfield:e("./shapes/Heightfield"),HingeConstraint:e("./constraints/HingeConstraint"),LockConstraint:e("./constraints/LockConstraint"),Mat3:e("./math/Mat3"),Material:e("./material/Material"),NaiveBroadphase:e("./collision/NaiveBroadphase"),ObjectCollisionMatrix:e("./collision/ObjectCollisionMatrix"),Pool:e("./utils/Pool"),Particle:e("./shapes/Particle"),Plane:e("./shapes/Plane"),PointToPointConstraint:e("./constraints/PointToPointConstraint"),Quaternion:e("./math/Quaternion"),Ray:e("./collision/Ray"),RaycastVehicle:e("./objects/RaycastVehicle"),RaycastResult:e("./collision/RaycastResult"),RigidVehicle:e("./objects/RigidVehicle"),RotationalEquation:e("./equations/RotationalEquation"),RotationalMotorEquation:e("./equations/RotationalMotorEquation"),SAPBroadphase:e("./collision/SAPBroadphase"),SPHSystem:e("./objects/SPHSystem"),Shape:e("./shapes/Shape"),Solver:e("./solver/Solver"),Sphere:e("./shapes/Sphere"),SplitSolver:e("./solver/SplitSolver"),Spring:e("./objects/Spring"),Trimesh:e("./shapes/Trimesh"),Vec3:e("./math/Vec3"),Vec3Pool:e("./utils/Vec3Pool"),World:e("./world/World")}},{"../package.json":1,"./collision/AABB":3,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":9,"./collision/RaycastResult":10,"./collision/SAPBroadphase":11,"./constraints/ConeTwistConstraint":12,"./constraints/Constraint":13,"./constraints/DistanceConstraint":14,"./constraints/HingeConstraint":15,"./constraints/LockConstraint":16,"./constraints/PointToPointConstraint":17,"./equations/ContactEquation":19,"./equations/Equation":20,"./equations/FrictionEquation":21,"./equations/RotationalEquation":22,"./equations/RotationalMotorEquation":23,"./material/ContactMaterial":24,"./material/Material":25,"./math/Mat3":27,"./math/Quaternion":28,"./math/Vec3":30,"./objects/Body":31,"./objects/RaycastVehicle":32,"./objects/RigidVehicle":33,"./objects/SPHSystem":34,"./objects/Spring":35,"./shapes/Box":37,"./shapes/ConvexPolyhedron":38,"./shapes/Cylinder":39,"./shapes/Heightfield":40,"./shapes/Particle":41,"./shapes/Plane":42,"./shapes/Shape":43,"./shapes/Sphere":44,"./shapes/Trimesh":45,"./solver/GSSolver":46,"./solver/Solver":47,"./solver/SplitSolver":48,"./utils/EventTarget":49,"./utils/Pool":51,"./utils/Vec3Pool":54,"./world/Narrowphase":55,"./world/World":56}],3:[function(e,n,i){var r=e("../math/Vec3");e("../utils/Utils"),n.exports=s;function s(h){h=h||{},this.lowerBound=new r,h.lowerBound&&this.lowerBound.copy(h.lowerBound),this.upperBound=new r,h.upperBound&&this.upperBound.copy(h.upperBound)}var o=new r;s.prototype.setFromPoints=function(h,u,c,d){var p=this.lowerBound,f=this.upperBound,g=c;p.copy(h[0]),g&&g.vmult(p,p),f.copy(p);for(var y=1;y<h.length;y++){var m=h[y];g&&(g.vmult(m,o),m=o),m.x>f.x&&(f.x=m.x),m.x<p.x&&(p.x=m.x),m.y>f.y&&(f.y=m.y),m.y<p.y&&(p.y=m.y),m.z>f.z&&(f.z=m.z),m.z<p.z&&(p.z=m.z)}return u&&(u.vadd(p,p),u.vadd(f,f)),d&&(p.x-=d,p.y-=d,p.z-=d,f.x+=d,f.y+=d,f.z+=d),this},s.prototype.copy=function(h){return this.lowerBound.copy(h.lowerBound),this.upperBound.copy(h.upperBound),this},s.prototype.clone=function(){return new s().copy(this)},s.prototype.extend=function(h){var u=h.lowerBound.x;this.lowerBound.x>u&&(this.lowerBound.x=u);var c=h.upperBound.x;this.upperBound.x<c&&(this.upperBound.x=c);var u=h.lowerBound.y;this.lowerBound.y>u&&(this.lowerBound.y=u);var c=h.upperBound.y;this.upperBound.y<c&&(this.upperBound.y=c);var u=h.lowerBound.z;this.lowerBound.z>u&&(this.lowerBound.z=u);var c=h.upperBound.z;this.upperBound.z<c&&(this.upperBound.z=c)},s.prototype.overlaps=function(h){var u=this.lowerBound,c=this.upperBound,d=h.lowerBound,p=h.upperBound;return(d.x<=c.x&&c.x<=p.x||u.x<=p.x&&p.x<=c.x)&&(d.y<=c.y&&c.y<=p.y||u.y<=p.y&&p.y<=c.y)&&(d.z<=c.z&&c.z<=p.z||u.z<=p.z&&p.z<=c.z)},s.prototype.contains=function(h){var u=this.lowerBound,c=this.upperBound,d=h.lowerBound,p=h.upperBound;return u.x<=d.x&&c.x>=p.x&&u.y<=d.y&&c.y>=p.y&&u.z<=d.z&&c.z>=p.z},s.prototype.getCorners=function(h,u,c,d,p,f,g,y){var m=this.lowerBound,v=this.upperBound;h.copy(m),u.set(v.x,m.y,m.z),c.set(v.x,v.y,m.z),d.set(m.x,v.y,v.z),p.set(v.x,m.y,m.z),f.set(m.x,v.y,m.z),g.set(m.x,m.y,v.z),y.copy(v)};var l=[new r,new r,new r,new r,new r,new r,new r,new r];s.prototype.toLocalFrame=function(h,u){var c=l,d=c[0],p=c[1],f=c[2],g=c[3],y=c[4],m=c[5],v=c[6],_=c[7];this.getCorners(d,p,f,g,y,m,v,_);for(var x=0;x!==8;x++){var w=c[x];h.pointToLocal(w,w)}return u.setFromPoints(c)},s.prototype.toWorldFrame=function(h,u){var c=l,d=c[0],p=c[1],f=c[2],g=c[3],y=c[4],m=c[5],v=c[6],_=c[7];this.getCorners(d,p,f,g,y,m,v,_);for(var x=0;x!==8;x++){var w=c[x];h.pointToWorld(w,w)}return u.setFromPoints(c)}},{"../math/Vec3":30,"../utils/Utils":53}],4:[function(e,n,i){n.exports=r;function r(){this.matrix=[]}r.prototype.get=function(s,o){if(s=s.index,o=o.index,o>s){var l=o;o=s,s=l}return this.matrix[(s*(s+1)>>1)+o-1]},r.prototype.set=function(s,o,l){if(s=s.index,o=o.index,o>s){var h=o;o=s,s=h}this.matrix[(s*(s+1)>>1)+o-1]=l?1:0},r.prototype.reset=function(){for(var s=0,o=this.matrix.length;s!==o;s++)this.matrix[s]=0},r.prototype.setNumObjects=function(s){this.matrix.length=s*(s-1)>>1}},{}],5:[function(e,n,i){var r=e("../objects/Body"),s=e("../math/Vec3"),o=e("../math/Quaternion");e("../shapes/Shape"),e("../shapes/Plane"),n.exports=l;function l(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}l.prototype.collisionPairs=function(g,y,m){throw new Error("collisionPairs not implemented for this BroadPhase class!")};var h=r.STATIC|r.KINEMATIC;l.prototype.needBroadphaseCollision=function(g,y){return!((g.collisionFilterGroup&y.collisionFilterMask)==0||(y.collisionFilterGroup&g.collisionFilterMask)==0||((g.type&h)!=0||g.sleepState===r.SLEEPING)&&((y.type&h)!=0||y.sleepState===r.SLEEPING))},l.prototype.intersectionTest=function(g,y,m,v){this.useBoundingBoxes?this.doBoundingBoxBroadphase(g,y,m,v):this.doBoundingSphereBroadphase(g,y,m,v)};var u=new s;new s,new o,new s,l.prototype.doBoundingSphereBroadphase=function(g,y,m,v){var _=u;y.position.vsub(g.position,_);var x=Math.pow(g.boundingRadius+y.boundingRadius,2),w=_.norm2();w<x&&(m.push(g),v.push(y))},l.prototype.doBoundingBoxBroadphase=function(g,y,m,v){g.aabbNeedsUpdate&&g.computeAABB(),y.aabbNeedsUpdate&&y.computeAABB(),g.aabb.overlaps(y.aabb)&&(m.push(g),v.push(y))};var c={keys:[]},d=[],p=[];l.prototype.makePairsUnique=function(g,y){for(var m=c,v=d,_=p,x=g.length,w=0;w!==x;w++)v[w]=g[w],_[w]=y[w];g.length=0,y.length=0;for(var w=0;w!==x;w++){var C=v[w].id,M=_[w].id,D=C<M?C+","+M:M+","+C;m[D]=w,m.keys.push(D)}for(var w=0;w!==m.keys.length;w++){var D=m.keys.pop(),j=m[D];g.push(v[j]),y.push(_[j]),delete m[D]}},l.prototype.setWorld=function(g){};var f=new s;l.boundingSphereCheck=function(g,y){var m=f;return g.position.vsub(y.position,m),Math.pow(g.shape.boundingSphereRadius+y.shape.boundingSphereRadius,2)>m.norm2()},l.prototype.aabbQuery=function(g,y,m){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Plane":42,"../shapes/Shape":43}],6:[function(e,n,i){n.exports=l;var r=e("./Broadphase"),s=e("../math/Vec3"),o=e("../shapes/Shape");function l(u,c,d,p,f){r.apply(this),this.nx=d||10,this.ny=p||10,this.nz=f||10,this.aabbMin=u||new s(100,100,100),this.aabbMax=c||new s(-100,-100,-100);var g=this.nx*this.ny*this.nz;if(g<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=g,this.binLengths.length=g;for(var y=0;y<g;y++)this.bins[y]=[],this.binLengths[y]=0}l.prototype=new r,l.prototype.constructor=l;var h=new s;new s,l.prototype.collisionPairs=function(u,c,d){var p=u.numObjects(),f=u.bodies,g=this.aabbMax,y=this.aabbMin,m=this.nx,v=this.ny,_=this.nz,x=v*_,w=_,C=1,M=g.x,D=g.y,j=g.z,N=y.x,b=y.y,U=y.z,V=m/(M-N),H=v/(D-b),Y=_/(j-U),Q=(M-N)/m,P=(D-b)/v,z=(j-U)/_,it=Math.sqrt(Q*Q+P*P+z*z)*.5,W=o.types,T=W.SPHERE,Z=W.PLANE;W.BOX,W.COMPOUND,W.CONVEXPOLYHEDRON;for(var A=this.bins,I=this.binLengths,R=this.bins.length,F=0;F!==R;F++)I[F]=0;var ot=Math.ceil,y=Math.min,g=Math.max;function et(Rt,At,Ft,Dt,Ut,Jt,Yt){var he=(Rt-N)*V|0,ae=(At-b)*H|0,Pe=(Ft-U)*Y|0,We=ot((Dt-N)*V),Fe=ot((Ut-b)*H),le=ot((Jt-U)*Y);he<0?he=0:he>=m&&(he=m-1),ae<0?ae=0:ae>=v&&(ae=v-1),Pe<0?Pe=0:Pe>=_&&(Pe=_-1),We<0?We=0:We>=m&&(We=m-1),Fe<0?Fe=0:Fe>=v&&(Fe=v-1),le<0?le=0:le>=_&&(le=_-1),he*=x,ae*=w,Pe*=C,We*=x,Fe*=w,le*=C;for(var rn=he;rn<=We;rn+=x)for(var sn=ae;sn<=Fe;sn+=w)for(var un=Pe;un<=le;un+=C){var $e=rn+sn+un;A[$e][I[$e]++]=Yt}}for(var F=0;F!==p;F++){var k=f[F],nt=k.shape;switch(nt.type){case T:var lt=k.position.x,$=k.position.y,rt=k.position.z,st=nt.radius;et(lt-st,$-st,rt-st,lt+st,$+st,rt+st,k);break;case Z:nt.worldNormalNeedsUpdate&&nt.computeWorldNormal(k.quaternion);var K=nt.worldNormal,tt=N+Q*.5-k.position.x,Lt=b+P*.5-k.position.y,St=U+z*.5-k.position.z,zt=h;zt.set(tt,Lt,St);for(var Pt=0,L=0;Pt!==m;Pt++,L+=x,zt.y=Lt,zt.x+=Q)for(var E=0,at=0;E!==v;E++,at+=w,zt.z=St,zt.y+=P)for(var ht=0,bt=0;ht!==_;ht++,bt+=C,zt.z+=z)if(zt.dot(K)<it){var Ct=L+at+bt;A[Ct][I[Ct]++]=k}break;default:k.aabbNeedsUpdate&&k.computeAABB(),et(k.aabb.lowerBound.x,k.aabb.lowerBound.y,k.aabb.lowerBound.z,k.aabb.upperBound.x,k.aabb.upperBound.y,k.aabb.upperBound.z,k);break}}for(var F=0;F!==R;F++){var J=I[F];if(J>1)for(var yt=A[F],Pt=0;Pt!==J;Pt++)for(var k=yt[Pt],E=0;E!==Pt;E++){var gt=yt[E];this.needBroadphaseCollision(k,gt)&&this.intersectionTest(k,gt,c,d)}}this.makePairsUnique(c,d)}},{"../math/Vec3":30,"../shapes/Shape":43,"./Broadphase":5}],7:[function(e,n,i){n.exports=o;var r=e("./Broadphase"),s=e("./AABB");function o(){r.apply(this)}o.prototype=new r,o.prototype.constructor=o,o.prototype.collisionPairs=function(l,h,u){var c=l.bodies,d=c.length,p,f,g,y;for(p=0;p!==d;p++)for(f=0;f!==p;f++)g=c[p],y=c[f],!!this.needBroadphaseCollision(g,y)&&this.intersectionTest(g,y,h,u)},new s,o.prototype.aabbQuery=function(l,h,u){u=u||[];for(var c=0;c<l.bodies.length;c++){var d=l.bodies[c];d.aabbNeedsUpdate&&d.computeAABB(),d.aabb.overlaps(h)&&u.push(d)}return u}},{"./AABB":3,"./Broadphase":5}],8:[function(e,n,i){n.exports=r;function r(){this.matrix={}}r.prototype.get=function(s,o){if(s=s.id,o=o.id,o>s){var l=o;o=s,s=l}return s+"-"+o in this.matrix},r.prototype.set=function(s,o,l){if(s=s.id,o=o.id,o>s){var h=o;o=s,s=h}l?this.matrix[s+"-"+o]=!0:delete this.matrix[s+"-"+o]},r.prototype.reset=function(){this.matrix={}},r.prototype.setNumObjects=function(s){}},{}],9:[function(e,n,i){n.exports=c;var r=e("../math/Vec3"),s=e("../math/Quaternion"),o=e("../math/Transform");e("../shapes/ConvexPolyhedron"),e("../shapes/Box");var l=e("../collision/RaycastResult"),h=e("../shapes/Shape"),u=e("../collision/AABB");function c(A,I){this.from=A?A.clone():new r,this.to=I?I.clone():new r,this._direction=new r,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=c.ANY,this.result=new l,this.hasHit=!1,this.callback=function(R){}}c.prototype.constructor=c,c.CLOSEST=1,c.ANY=2,c.ALL=4;var d=new u,p=[];c.prototype.intersectWorld=function(A,I){return this.mode=I.mode||c.ANY,this.result=I.result||new l,this.skipBackfaces=!!I.skipBackfaces,this.collisionFilterMask=typeof I.collisionFilterMask!="undefined"?I.collisionFilterMask:-1,this.collisionFilterGroup=typeof I.collisionFilterGroup!="undefined"?I.collisionFilterGroup:-1,I.from&&this.from.copy(I.from),I.to&&this.to.copy(I.to),this.callback=I.callback||function(){},this.hasHit=!1,this.result.reset(),this._updateDirection(),this.getAABB(d),p.length=0,A.broadphase.aabbQuery(A,d,p),this.intersectBodies(p),this.hasHit};var f=new r,g=new r;c.pointInTriangle=y;function y(A,I,R,F){F.vsub(I,W),R.vsub(I,f),A.vsub(I,g);var ot=W.dot(W),et=W.dot(f),k=W.dot(g),nt=f.dot(f),lt=f.dot(g),$,rt;return($=nt*k-et*lt)>=0&&(rt=ot*lt-et*k)>=0&&$+rt<ot*nt-et*et}var m=new r,v=new s;c.prototype.intersectBody=function(A,I){I&&(this.result=I,this._updateDirection());var R=this.checkCollisionResponse;if(!(R&&!A.collisionResponse)&&!((this.collisionFilterGroup&A.collisionFilterMask)==0||(A.collisionFilterGroup&this.collisionFilterMask)==0))for(var F=m,ot=v,et=0,k=A.shapes.length;et<k;et++){var nt=A.shapes[et];if(!(R&&!nt.collisionResponse)&&(A.quaternion.mult(A.shapeOrientations[et],ot),A.quaternion.vmult(A.shapeOffsets[et],F),F.vadd(A.position,F),this.intersectShape(nt,ot,F,A),this.result._shouldStop))break}},c.prototype.intersectBodies=function(A,I){I&&(this.result=I,this._updateDirection());for(var R=0,F=A.length;!this.result._shouldStop&&R<F;R++)this.intersectBody(A[R])},c.prototype._updateDirection=function(){this.to.vsub(this.from,this._direction),this._direction.normalize()},c.prototype.intersectShape=function(A,I,R,F){var ot=this.from,et=Z(ot,this._direction,R);if(!(et>A.boundingSphereRadius)){var k=this[A.type];k&&k.call(this,A,I,R,F)}},new r,new r;var _=new r,x=new r,w=new r,C=new r;new r,new l,c.prototype.intersectBox=function(A,I,R,F){return this.intersectConvex(A.convexPolyhedronRepresentation,I,R,F)},c.prototype[h.types.BOX]=c.prototype.intersectBox,c.prototype.intersectPlane=function(A,I,R,F){var ot=this.from,et=this.to,k=this._direction,nt=new r(0,0,1);I.vmult(nt,nt);var lt=new r;ot.vsub(R,lt);var $=lt.dot(nt);et.vsub(R,lt);var rt=lt.dot(nt);if(!($*rt>0)&&!(ot.distanceTo(et)<$)){var st=nt.dot(k);if(!(Math.abs(st)<this.precision)){var K=new r,tt=new r,Lt=new r;ot.vsub(R,K);var St=-nt.dot(K)/st;k.scale(St,tt),ot.vadd(tt,Lt),this.reportIntersection(nt,Lt,A,F,-1)}}},c.prototype[h.types.PLANE]=c.prototype.intersectPlane,c.prototype.getAABB=function(A){var I=this.to,R=this.from;A.lowerBound.x=Math.min(I.x,R.x),A.lowerBound.y=Math.min(I.y,R.y),A.lowerBound.z=Math.min(I.z,R.z),A.upperBound.x=Math.max(I.x,R.x),A.upperBound.y=Math.max(I.y,R.y),A.upperBound.z=Math.max(I.z,R.z)};var M={faceList:[0]};c.prototype.intersectHeightfield=function(A,I,R,F){A.data,A.elementSize;var ot=new r,et=new c(this.from,this.to);o.pointToLocalFrame(R,I,et.from,et.from),o.pointToLocalFrame(R,I,et.to,et.to);var k=[],nt=null,lt=null,$=null,rt=null,st=A.getIndexOfPosition(et.from.x,et.from.y,k,!1);if(st&&(nt=k[0],lt=k[1],$=k[0],rt=k[1]),st=A.getIndexOfPosition(et.to.x,et.to.y,k,!1),st&&((nt===null||k[0]<nt)&&(nt=k[0]),($===null||k[0]>$)&&($=k[0]),(lt===null||k[1]<lt)&&(lt=k[1]),(rt===null||k[1]>rt)&&(rt=k[1])),nt!==null){var K=[];A.getRectMinMax(nt,lt,$,rt,K),K[0],K[1];for(var tt=nt;tt<=$;tt++)for(var Lt=lt;Lt<=rt;Lt++){if(this.result._shouldStop||(A.getConvexTrianglePillar(tt,Lt,!1),o.pointToWorldFrame(R,I,A.pillarOffset,ot),this.intersectConvex(A.pillarConvex,I,ot,F,M),this.result._shouldStop))return;A.getConvexTrianglePillar(tt,Lt,!0),o.pointToWorldFrame(R,I,A.pillarOffset,ot),this.intersectConvex(A.pillarConvex,I,ot,F,M)}}},c.prototype[h.types.HEIGHTFIELD]=c.prototype.intersectHeightfield;var D=new r,j=new r;c.prototype.intersectSphere=function(A,I,R,F){var ot=this.from,et=this.to,k=A.radius,nt=Math.pow(et.x-ot.x,2)+Math.pow(et.y-ot.y,2)+Math.pow(et.z-ot.z,2),lt=2*((et.x-ot.x)*(ot.x-R.x)+(et.y-ot.y)*(ot.y-R.y)+(et.z-ot.z)*(ot.z-R.z)),$=Math.pow(ot.x-R.x,2)+Math.pow(ot.y-R.y,2)+Math.pow(ot.z-R.z,2)-Math.pow(k,2),rt=Math.pow(lt,2)-4*nt*$,st=D,K=j;if(!(rt<0))if(rt===0)ot.lerp(et,rt,st),st.vsub(R,K),K.normalize(),this.reportIntersection(K,st,A,F,-1);else{var tt=(-lt-Math.sqrt(rt))/(2*nt),Lt=(-lt+Math.sqrt(rt))/(2*nt);if(tt>=0&&tt<=1&&(ot.lerp(et,tt,st),st.vsub(R,K),K.normalize(),this.reportIntersection(K,st,A,F,-1)),this.result._shouldStop)return;Lt>=0&&Lt<=1&&(ot.lerp(et,Lt,st),st.vsub(R,K),K.normalize(),this.reportIntersection(K,st,A,F,-1))}},c.prototype[h.types.SPHERE]=c.prototype.intersectSphere;var N=new r;new r,new r;var b=new r;c.prototype.intersectConvex=function(I,R,F,ot,et){for(var k=N,nt=b,lt=et&&et.faceList||null,$=I.faces,rt=I.vertices,st=I.faceNormals,K=this._direction,tt=this.from,Lt=this.to,St=tt.distanceTo(Lt),zt=lt?lt.length:$.length,Pt=this.result,L=0;!Pt._shouldStop&&L<zt;L++){var E=lt?lt[L]:L,at=$[E],ht=st[E],bt=R,Ct=F;nt.copy(rt[at[0]]),bt.vmult(nt,nt),nt.vadd(Ct,nt),nt.vsub(tt,nt),bt.vmult(ht,k);var J=K.dot(k);if(!(Math.abs(J)<this.precision)){var yt=k.dot(nt)/J;if(!(yt<0)){K.mult(yt,_),_.vadd(tt,_),x.copy(rt[at[0]]),bt.vmult(x,x),Ct.vadd(x,x);for(var gt=1;!Pt._shouldStop&&gt<at.length-1;gt++){w.copy(rt[at[gt]]),C.copy(rt[at[gt+1]]),bt.vmult(w,w),bt.vmult(C,C),Ct.vadd(w,w),Ct.vadd(C,C);var Rt=_.distanceTo(tt);!(y(_,x,w,C)||y(_,w,x,C))||Rt>St||this.reportIntersection(k,_,I,ot,E)}}}}},c.prototype[h.types.CONVEXPOLYHEDRON]=c.prototype.intersectConvex;var U=new r,V=new r,H=new r,Y=new r,Q=new r,P=new r;new u;var z=[],it=new o;c.prototype.intersectTrimesh=function(I,R,F,ot,et){var k=U,nt=z,lt=it,$=b,rt=V,st=H,K=Y,tt=P,Lt=Q;et&&et.faceList;var St=I.indices;I.vertices,I.faceNormals;var zt=this.from,Pt=this.to,L=this._direction;lt.position.copy(F),lt.quaternion.copy(R),o.vectorToLocalFrame(F,R,L,rt),o.pointToLocalFrame(F,R,zt,st),o.pointToLocalFrame(F,R,Pt,K);var E=st.distanceSquared(K);I.tree.rayQuery(this,lt,nt);for(var at=0,ht=nt.length;!this.result._shouldStop&&at!==ht;at++){var bt=nt[at];I.getNormal(bt,k),I.getVertex(St[bt*3],x),x.vsub(st,$);var Ct=rt.dot(k),J=k.dot($)/Ct;if(!(J<0)){rt.scale(J,_),_.vadd(st,_),I.getVertex(St[bt*3+1],w),I.getVertex(St[bt*3+2],C);var yt=_.distanceSquared(st);!(y(_,w,x,C)||y(_,x,w,C))||yt>E||(o.vectorToWorldFrame(R,k,Lt),o.pointToWorldFrame(F,R,_,tt),this.reportIntersection(Lt,tt,I,ot,bt))}}nt.length=0},c.prototype[h.types.TRIMESH]=c.prototype.intersectTrimesh,c.prototype.reportIntersection=function(A,I,R,F,ot){var et=this.from,k=this.to,nt=et.distanceTo(I),lt=this.result;if(!(this.skipBackfaces&&A.dot(this._direction)>0))switch(lt.hitFaceIndex=typeof ot!="undefined"?ot:-1,this.mode){case c.ALL:this.hasHit=!0,lt.set(et,k,A,I,R,F,nt),lt.hasHit=!0,this.callback(lt);break;case c.CLOSEST:(nt<lt.distance||!lt.hasHit)&&(this.hasHit=!0,lt.hasHit=!0,lt.set(et,k,A,I,R,F,nt));break;case c.ANY:this.hasHit=!0,lt.hasHit=!0,lt.set(et,k,A,I,R,F,nt),lt._shouldStop=!0;break}};var W=new r,T=new r;function Z(A,I,R){R.vsub(A,W);var F=W.dot(I);I.mult(F,T),T.vadd(A,T);var ot=R.distanceTo(T);return ot}},{"../collision/AABB":3,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/Box":37,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43}],10:[function(e,n,i){var r=e("../math/Vec3");n.exports=s;function s(){this.rayFromWorld=new r,this.rayToWorld=new r,this.hitNormalWorld=new r,this.hitPointWorld=new r,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this._shouldStop=!1}s.prototype.reset=function(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this._shouldStop=!1},s.prototype.abort=function(){this._shouldStop=!0},s.prototype.set=function(o,l,h,u,c,d,p){this.rayFromWorld.copy(o),this.rayToWorld.copy(l),this.hitNormalWorld.copy(h),this.hitPointWorld.copy(u),this.shape=c,this.body=d,this.distance=p}},{"../math/Vec3":30}],11:[function(e,n,i){e("../shapes/Shape");var r=e("../collision/Broadphase");n.exports=s;function s(o){r.apply(this),this.axisList=[],this.world=null,this.axisIndex=0;var l=this.axisList;this._addBodyHandler=function(h){l.push(h.body)},this._removeBodyHandler=function(h){var u=l.indexOf(h.body);u!==-1&&l.splice(u,1)},o&&this.setWorld(o)}s.prototype=new r,s.prototype.setWorld=function(o){this.axisList.length=0;for(var l=0;l<o.bodies.length;l++)this.axisList.push(o.bodies[l]);o.removeEventListener("addBody",this._addBodyHandler),o.removeEventListener("removeBody",this._removeBodyHandler),o.addEventListener("addBody",this._addBodyHandler),o.addEventListener("removeBody",this._removeBodyHandler),this.world=o,this.dirty=!0},s.insertionSortX=function(o){for(var l=1,h=o.length;l<h;l++){for(var u=o[l],c=l-1;c>=0&&!(o[c].aabb.lowerBound.x<=u.aabb.lowerBound.x);c--)o[c+1]=o[c];o[c+1]=u}return o},s.insertionSortY=function(o){for(var l=1,h=o.length;l<h;l++){for(var u=o[l],c=l-1;c>=0&&!(o[c].aabb.lowerBound.y<=u.aabb.lowerBound.y);c--)o[c+1]=o[c];o[c+1]=u}return o},s.insertionSortZ=function(o){for(var l=1,h=o.length;l<h;l++){for(var u=o[l],c=l-1;c>=0&&!(o[c].aabb.lowerBound.z<=u.aabb.lowerBound.z);c--)o[c+1]=o[c];o[c+1]=u}return o},s.prototype.collisionPairs=function(o,l,h){var u=this.axisList,c=u.length,d=this.axisIndex,p,f;for(this.dirty&&(this.sortList(),this.dirty=!1),p=0;p!==c;p++){var g=u[p];for(f=p+1;f<c;f++){var y=u[f];if(!!this.needBroadphaseCollision(g,y)){if(!s.checkBounds(g,y,d))break;this.intersectionTest(g,y,l,h)}}}},s.prototype.sortList=function(){for(var o=this.axisList,l=this.axisIndex,h=o.length,u=0;u!==h;u++){var c=o[u];c.aabbNeedsUpdate&&c.computeAABB()}l===0?s.insertionSortX(o):l===1?s.insertionSortY(o):l===2&&s.insertionSortZ(o)},s.checkBounds=function(o,l,h){var u,c;h===0?(u=o.position.x,c=l.position.x):h===1?(u=o.position.y,c=l.position.y):h===2&&(u=o.position.z,c=l.position.z);var d=o.boundingRadius,p=l.boundingRadius,f=u+d,g=c-p;return g<f},s.prototype.autoDetectAxis=function(){for(var o=0,l=0,h=0,u=0,c=0,d=0,p=this.axisList,f=p.length,g=1/f,y=0;y!==f;y++){var m=p[y],v=m.position.x;o+=v,l+=v*v;var _=m.position.y;h+=_,u+=_*_;var x=m.position.z;c+=x,d+=x*x}var w=l-o*o*g,C=u-h*h*g,M=d-c*c*g;w>C?w>M?this.axisIndex=0:this.axisIndex=2:C>M?this.axisIndex=1:this.axisIndex=2},s.prototype.aabbQuery=function(o,l,h){h=h||[],this.dirty&&(this.sortList(),this.dirty=!1);var u=this.axisIndex,c="x";u===1&&(c="y"),u===2&&(c="z");var d=this.axisList;l.lowerBound[c],l.upperBound[c];for(var p=0;p<d.length;p++){var f=d[p];f.aabbNeedsUpdate&&f.computeAABB(),f.aabb.overlaps(l)&&h.push(f)}return h}},{"../collision/Broadphase":5,"../shapes/Shape":43}],12:[function(e,n,i){n.exports=h,e("./Constraint");var r=e("./PointToPointConstraint"),s=e("../equations/ConeEquation"),o=e("../equations/RotationalEquation");e("../equations/ContactEquation");var l=e("../math/Vec3");function h(u,c,d){d=d||{};var p=typeof d.maxForce!="undefined"?d.maxForce:1e6,f=d.pivotA?d.pivotA.clone():new l,g=d.pivotB?d.pivotB.clone():new l;this.axisA=d.axisA?d.axisA.clone():new l,this.axisB=d.axisB?d.axisB.clone():new l,r.call(this,u,f,c,g,p),this.collideConnected=!!d.collideConnected,this.angle=typeof d.angle!="undefined"?d.angle:0;var y=this.coneEquation=new s(u,c,d),m=this.twistEquation=new o(u,c,d);this.twistAngle=typeof d.twistAngle!="undefined"?d.twistAngle:0,y.maxForce=0,y.minForce=-p,m.maxForce=0,m.minForce=-p,this.equations.push(y,m)}h.prototype=new r,h.constructor=h,new l,new l,h.prototype.update=function(){var u=this.bodyA,c=this.bodyB,d=this.coneEquation,p=this.twistEquation;r.prototype.update.call(this),u.vectorToWorldFrame(this.axisA,d.axisA),c.vectorToWorldFrame(this.axisB,d.axisB),this.axisA.tangents(p.axisA,p.axisA),u.vectorToWorldFrame(p.axisA,p.axisA),this.axisB.tangents(p.axisB,p.axisB),c.vectorToWorldFrame(p.axisB,p.axisB),d.angle=this.angle,p.maxAngle=this.twistAngle}},{"../equations/ConeEquation":18,"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],13:[function(e,n,i){n.exports=s;var r=e("../utils/Utils");function s(o,l,h){h=r.defaults(h,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=o,this.bodyB=l,this.id=s.idCounter++,this.collideConnected=h.collideConnected,h.wakeUpBodies&&(o&&o.wakeUp(),l&&l.wakeUp())}s.prototype.update=function(){throw new Error("method update() not implmemented in this Constraint subclass!")},s.prototype.enable=function(){for(var o=this.equations,l=0;l<o.length;l++)o[l].enabled=!0},s.prototype.disable=function(){for(var o=this.equations,l=0;l<o.length;l++)o[l].enabled=!1},s.idCounter=0},{"../utils/Utils":53}],14:[function(e,n,i){n.exports=o;var r=e("./Constraint"),s=e("../equations/ContactEquation");function o(l,h,u,c){r.call(this,l,h),typeof u=="undefined"&&(u=l.position.distanceTo(h.position)),typeof c=="undefined"&&(c=1e6),this.distance=u;var d=this.distanceEquation=new s(l,h);this.equations.push(d),d.minForce=-c,d.maxForce=c}o.prototype=new r,o.prototype.update=function(){var l=this.bodyA,h=this.bodyB,u=this.distanceEquation,c=this.distance*.5,d=u.ni;h.position.vsub(l.position,d),d.normalize(),d.mult(c,u.ri),d.mult(-c,u.rj)}},{"../equations/ContactEquation":19,"./Constraint":13}],15:[function(e,n,i){n.exports=h,e("./Constraint");var r=e("./PointToPointConstraint"),s=e("../equations/RotationalEquation"),o=e("../equations/RotationalMotorEquation");e("../equations/ContactEquation");var l=e("../math/Vec3");function h(d,p,f){f=f||{};var g=typeof f.maxForce!="undefined"?f.maxForce:1e6,y=f.pivotA?f.pivotA.clone():new l,m=f.pivotB?f.pivotB.clone():new l;r.call(this,d,y,p,m,g);var v=this.axisA=f.axisA?f.axisA.clone():new l(1,0,0);v.normalize();var _=this.axisB=f.axisB?f.axisB.clone():new l(1,0,0);_.normalize();var x=this.rotationalEquation1=new s(d,p,f),w=this.rotationalEquation2=new s(d,p,f),C=this.motorEquation=new o(d,p,g);C.enabled=!1,this.equations.push(x,w,C)}h.prototype=new r,h.constructor=h,h.prototype.enableMotor=function(){this.motorEquation.enabled=!0},h.prototype.disableMotor=function(){this.motorEquation.enabled=!1},h.prototype.setMotorSpeed=function(d){this.motorEquation.targetVelocity=d},h.prototype.setMotorMaxForce=function(d){this.motorEquation.maxForce=d,this.motorEquation.minForce=-d};var u=new l,c=new l;h.prototype.update=function(){var d=this.bodyA,p=this.bodyB,f=this.motorEquation,g=this.rotationalEquation1,y=this.rotationalEquation2,m=u,v=c,_=this.axisA,x=this.axisB;r.prototype.update.call(this),d.quaternion.vmult(_,m),p.quaternion.vmult(x,v),m.tangents(g.axisA,y.axisA),g.axisB.copy(v),y.axisB.copy(v),this.motorEquation.enabled&&(d.quaternion.vmult(this.axisA,f.axisA),p.quaternion.vmult(this.axisB,f.axisB))}},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],16:[function(e,n,i){n.exports=l,e("./Constraint");var r=e("./PointToPointConstraint"),s=e("../equations/RotationalEquation");e("../equations/RotationalMotorEquation"),e("../equations/ContactEquation");var o=e("../math/Vec3");function l(h,u,c){c=c||{};var d=typeof c.maxForce!="undefined"?c.maxForce:1e6,p=new o,f=new o,g=new o;h.position.vadd(u.position,g),g.scale(.5,g),u.pointToLocalFrame(g,f),h.pointToLocalFrame(g,p),r.call(this,h,p,u,f,d);var y=this.rotationalEquation1=new s(h,u,c),m=this.rotationalEquation2=new s(h,u,c),v=this.rotationalEquation3=new s(h,u,c);this.equations.push(y,m,v)}l.prototype=new r,l.constructor=l,new o,new o,l.prototype.update=function(){var h=this.bodyA,u=this.bodyB;this.motorEquation;var c=this.rotationalEquation1,d=this.rotationalEquation2,p=this.rotationalEquation3;r.prototype.update.call(this),h.vectorToWorldFrame(o.UNIT_X,c.axisA),u.vectorToWorldFrame(o.UNIT_Y,c.axisB),h.vectorToWorldFrame(o.UNIT_Y,d.axisA),u.vectorToWorldFrame(o.UNIT_Z,d.axisB),h.vectorToWorldFrame(o.UNIT_Z,p.axisA),u.vectorToWorldFrame(o.UNIT_X,p.axisB)}},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],17:[function(e,n,i){n.exports=l;var r=e("./Constraint"),s=e("../equations/ContactEquation"),o=e("../math/Vec3");function l(h,u,c,d,p){r.call(this,h,c),p=typeof p!="undefined"?p:1e6,this.pivotA=u?u.clone():new o,this.pivotB=d?d.clone():new o;var f=this.equationX=new s(h,c),g=this.equationY=new s(h,c),y=this.equationZ=new s(h,c);this.equations.push(f,g,y),f.minForce=g.minForce=y.minForce=-p,f.maxForce=g.maxForce=y.maxForce=p,f.ni.set(1,0,0),g.ni.set(0,1,0),y.ni.set(0,0,1)}l.prototype=new r,l.prototype.update=function(){var h=this.bodyA,u=this.bodyB,c=this.equationX,d=this.equationY,p=this.equationZ;h.quaternion.vmult(this.pivotA,c.ri),u.quaternion.vmult(this.pivotB,c.rj),d.ri.copy(c.ri),d.rj.copy(c.rj),p.ri.copy(c.ri),p.rj.copy(c.rj)}},{"../equations/ContactEquation":19,"../math/Vec3":30,"./Constraint":13}],18:[function(e,n,i){n.exports=o;var r=e("../math/Vec3");e("../math/Mat3");var s=e("./Equation");function o(u,c,d){d=d||{};var p=typeof d.maxForce!="undefined"?d.maxForce:1e6;s.call(this,u,c,-p,p),this.axisA=d.axisA?d.axisA.clone():new r(1,0,0),this.axisB=d.axisB?d.axisB.clone():new r(0,1,0),this.angle=typeof d.angle!="undefined"?d.angle:0}o.prototype=new s,o.prototype.constructor=o;var l=new r,h=new r;o.prototype.computeB=function(u){var c=this.a,d=this.b,p=this.axisA,f=this.axisB,g=l,y=h,m=this.jacobianElementA,v=this.jacobianElementB;p.cross(f,g),f.cross(p,y),m.rotational.copy(y),v.rotational.copy(g);var _=Math.cos(this.angle)-p.dot(f),x=this.computeGW(),w=this.computeGiMf(),C=-_*c-x*d-u*w;return C}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],19:[function(e,n,i){n.exports=o;var r=e("./Equation"),s=e("../math/Vec3");e("../math/Mat3");function o(y,m,v){v=typeof v!="undefined"?v:1e6,r.call(this,y,m,0,v),this.restitution=0,this.ri=new s,this.rj=new s,this.ni=new s}o.prototype=new r,o.prototype.constructor=o;var l=new s,h=new s,u=new s;o.prototype.computeB=function(y){var m=this.a,v=this.b,_=this.bi,x=this.bj,w=this.ri,C=this.rj,M=l,D=h,j=_.velocity,N=_.angularVelocity;_.force,_.torque;var b=x.velocity,U=x.angularVelocity;x.force,x.torque;var V=u,H=this.jacobianElementA,Y=this.jacobianElementB,Q=this.ni;w.cross(Q,M),C.cross(Q,D),Q.negate(H.spatial),M.negate(H.rotational),Y.spatial.copy(Q),Y.rotational.copy(D),V.copy(x.position),V.vadd(C,V),V.vsub(_.position,V),V.vsub(w,V);var P=Q.dot(V),z=this.restitution+1,it=z*b.dot(Q)-z*j.dot(Q)+U.dot(D)-N.dot(M),W=this.computeGiMf(),T=-P*m-it*v-y*W;return T};var c=new s,d=new s,p=new s,f=new s,g=new s;o.prototype.getImpactVelocityAlongNormal=function(){var y=c,m=d,v=p,_=f,x=g;return this.bi.position.vadd(this.ri,v),this.bj.position.vadd(this.rj,_),this.bi.getVelocityAtWorldPoint(v,y),this.bj.getVelocityAtWorldPoint(_,m),y.vsub(m,x),this.ni.dot(x)}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],20:[function(e,n,i){n.exports=o;var r=e("../math/JacobianElement"),s=e("../math/Vec3");function o(g,y,m,v){this.id=o.id++,this.minForce=typeof m=="undefined"?-1e6:m,this.maxForce=typeof v=="undefined"?1e6:v,this.bi=g,this.bj=y,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new r,this.jacobianElementB=new r,this.enabled=!0,this.setSpookParams(1e7,4,1/60)}o.prototype.constructor=o,o.id=0,o.prototype.setSpookParams=function(g,y,m){var v=y,_=g,x=m;this.a=4/(x*(1+4*v)),this.b=4*v/(1+4*v),this.eps=4/(x*x*_*(1+4*v))},o.prototype.computeB=function(g,y,m){var v=this.computeGW(),_=this.computeGq(),x=this.computeGiMf();return-_*g-v*y-x*m},o.prototype.computeGq=function(){var g=this.jacobianElementA,y=this.jacobianElementB,m=this.bi,v=this.bj,_=m.position,x=v.position;return g.spatial.dot(_)+y.spatial.dot(x)};var l=new s;o.prototype.computeGW=function(){var g=this.jacobianElementA,y=this.jacobianElementB,m=this.bi,v=this.bj,_=m.velocity,x=v.velocity,w=m.angularVelocity||l,C=v.angularVelocity||l;return g.multiplyVectors(_,w)+y.multiplyVectors(x,C)},o.prototype.computeGWlambda=function(){var g=this.jacobianElementA,y=this.jacobianElementB,m=this.bi,v=this.bj,_=m.vlambda,x=v.vlambda,w=m.wlambda||l,C=v.wlambda||l;return g.multiplyVectors(_,w)+y.multiplyVectors(x,C)};var h=new s,u=new s,c=new s,d=new s;o.prototype.computeGiMf=function(){var g=this.jacobianElementA,y=this.jacobianElementB,m=this.bi,v=this.bj,_=m.force,x=m.torque,w=v.force,C=v.torque,M=m.invMassSolve,D=v.invMassSolve;return m.invInertiaWorldSolve?m.invInertiaWorldSolve.vmult(x,c):c.set(0,0,0),v.invInertiaWorldSolve?v.invInertiaWorldSolve.vmult(C,d):d.set(0,0,0),_.mult(M,h),w.mult(D,u),g.multiplyVectors(h,c)+y.multiplyVectors(u,d)};var p=new s;o.prototype.computeGiMGt=function(){var g=this.jacobianElementA,y=this.jacobianElementB,m=this.bi,v=this.bj,_=m.invMassSolve,x=v.invMassSolve,w=m.invInertiaWorldSolve,C=v.invInertiaWorldSolve,M=_+x;return w&&(w.vmult(g.rotational,p),M+=p.dot(g.rotational)),C&&(C.vmult(y.rotational,p),M+=p.dot(y.rotational)),M};var f=new s;new s,new s,new s,new s,new s,o.prototype.addToWlambda=function(g){var y=this.jacobianElementA,m=this.jacobianElementB,v=this.bi,_=this.bj,x=f;y.spatial.mult(v.invMassSolve*g,x),v.vlambda.vadd(x,v.vlambda),m.spatial.mult(_.invMassSolve*g,x),_.vlambda.vadd(x,_.vlambda),v.invInertiaWorldSolve&&(v.invInertiaWorldSolve.vmult(y.rotational,x),x.mult(g,x),v.wlambda.vadd(x,v.wlambda)),_.invInertiaWorldSolve&&(_.invInertiaWorldSolve.vmult(m.rotational,x),x.mult(g,x),_.wlambda.vadd(x,_.wlambda))},o.prototype.computeC=function(){return this.computeGiMGt()+this.eps}},{"../math/JacobianElement":26,"../math/Vec3":30}],21:[function(e,n,i){n.exports=o;var r=e("./Equation"),s=e("../math/Vec3");e("../math/Mat3");function o(u,c,d){r.call(this,u,c,-d,d),this.ri=new s,this.rj=new s,this.t=new s}o.prototype=new r,o.prototype.constructor=o;var l=new s,h=new s;o.prototype.computeB=function(u){this.a;var c=this.b;this.bi,this.bj;var d=this.ri,p=this.rj,f=l,g=h,y=this.t;d.cross(y,f),p.cross(y,g);var m=this.jacobianElementA,v=this.jacobianElementB;y.negate(m.spatial),f.negate(m.rotational),v.spatial.copy(y),v.rotational.copy(g);var _=this.computeGW(),x=this.computeGiMf(),w=-_*c-u*x;return w}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],22:[function(e,n,i){n.exports=o;var r=e("../math/Vec3");e("../math/Mat3");var s=e("./Equation");function o(u,c,d){d=d||{};var p=typeof d.maxForce!="undefined"?d.maxForce:1e6;s.call(this,u,c,-p,p),this.axisA=d.axisA?d.axisA.clone():new r(1,0,0),this.axisB=d.axisB?d.axisB.clone():new r(0,1,0),this.maxAngle=Math.PI/2}o.prototype=new s,o.prototype.constructor=o;var l=new r,h=new r;o.prototype.computeB=function(u){var c=this.a,d=this.b,p=this.axisA,f=this.axisB,g=l,y=h,m=this.jacobianElementA,v=this.jacobianElementB;p.cross(f,g),f.cross(p,y),m.rotational.copy(y),v.rotational.copy(g);var _=Math.cos(this.maxAngle)-p.dot(f),x=this.computeGW(),w=this.computeGiMf(),C=-_*c-x*d-u*w;return C}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],23:[function(e,n,i){n.exports=o;var r=e("../math/Vec3");e("../math/Mat3");var s=e("./Equation");function o(l,h,u){u=typeof u!="undefined"?u:1e6,s.call(this,l,h,-u,u),this.axisA=new r,this.axisB=new r,this.targetVelocity=0}o.prototype=new s,o.prototype.constructor=o,o.prototype.computeB=function(l){this.a;var h=this.b;this.bi,this.bj;var u=this.axisA,c=this.axisB,d=this.jacobianElementA,p=this.jacobianElementB;d.rotational.copy(u),c.negate(p.rotational);var f=this.computeGW()-this.targetVelocity,g=this.computeGiMf(),y=-f*h-l*g;return y}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],24:[function(e,n,i){var r=e("../utils/Utils");n.exports=s;function s(o,l,h){h=r.defaults(h,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=s.idCounter++,this.materials=[o,l],this.friction=h.friction,this.restitution=h.restitution,this.contactEquationStiffness=h.contactEquationStiffness,this.contactEquationRelaxation=h.contactEquationRelaxation,this.frictionEquationStiffness=h.frictionEquationStiffness,this.frictionEquationRelaxation=h.frictionEquationRelaxation}s.idCounter=0},{"../utils/Utils":53}],25:[function(e,n,i){n.exports=r;function r(s){var o="";s=s||{},typeof s=="string"?(o=s,s={}):typeof s=="object"&&(o=""),this.name=o,this.id=r.idCounter++,this.friction=typeof s.friction!="undefined"?s.friction:-1,this.restitution=typeof s.restitution!="undefined"?s.restitution:-1}r.idCounter=0},{}],26:[function(e,n,i){n.exports=s;var r=e("./Vec3");function s(){this.spatial=new r,this.rotational=new r}s.prototype.multiplyElement=function(o){return o.spatial.dot(this.spatial)+o.rotational.dot(this.rotational)},s.prototype.multiplyVectors=function(o,l){return o.dot(this.spatial)+l.dot(this.rotational)}},{"./Vec3":30}],27:[function(e,n,i){n.exports=s;var r=e("./Vec3");function s(o){o?this.elements=o:this.elements=[0,0,0,0,0,0,0,0,0]}s.prototype.identity=function(){var o=this.elements;o[0]=1,o[1]=0,o[2]=0,o[3]=0,o[4]=1,o[5]=0,o[6]=0,o[7]=0,o[8]=1},s.prototype.setZero=function(){var o=this.elements;o[0]=0,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=0,o[6]=0,o[7]=0,o[8]=0},s.prototype.setTrace=function(o){var l=this.elements;l[0]=o.x,l[4]=o.y,l[8]=o.z},s.prototype.getTrace=function(o){var o=o||new r,l=this.elements;o.x=l[0],o.y=l[4],o.z=l[8]},s.prototype.vmult=function(o,l){l=l||new r;var h=this.elements,u=o.x,c=o.y,d=o.z;return l.x=h[0]*u+h[1]*c+h[2]*d,l.y=h[3]*u+h[4]*c+h[5]*d,l.z=h[6]*u+h[7]*c+h[8]*d,l},s.prototype.smult=function(o){for(var l=0;l<this.elements.length;l++)this.elements[l]*=o},s.prototype.mmult=function(o,l){for(var h=l||new s,u=0;u<3;u++)for(var c=0;c<3;c++){for(var d=0,p=0;p<3;p++)d+=o.elements[u+p*3]*this.elements[p+c*3];h.elements[u+c*3]=d}return h},s.prototype.scale=function(o,l){l=l||new s;for(var h=this.elements,u=l.elements,c=0;c!==3;c++)u[3*c+0]=o.x*h[3*c+0],u[3*c+1]=o.y*h[3*c+1],u[3*c+2]=o.z*h[3*c+2];return l},s.prototype.solve=function(o,l){l=l||new r;for(var h=3,u=4,c=[],d=0;d<h*u;d++)c.push(0);var d,p;for(d=0;d<3;d++)for(p=0;p<3;p++)c[d+u*p]=this.elements[d+3*p];c[3+4*0]=o.x,c[3+4*1]=o.y,c[3+4*2]=o.z;var f=3,g=f,y,m=4,v;do{if(d=g-f,c[d+u*d]===0){for(p=d+1;p<g;p++)if(c[d+u*p]!==0){y=m;do v=m-y,c[v+u*d]+=c[v+u*p];while(--y);break}}if(c[d+u*d]!==0)for(p=d+1;p<g;p++){var _=c[d+u*p]/c[d+u*d];y=m;do v=m-y,c[v+u*p]=v<=d?0:c[v+u*p]-c[v+u*d]*_;while(--y)}}while(--f);if(l.z=c[2*u+3]/c[2*u+2],l.y=(c[1*u+3]-c[1*u+2]*l.z)/c[1*u+1],l.x=(c[0*u+3]-c[0*u+2]*l.z-c[0*u+1]*l.y)/c[0*u+0],isNaN(l.x)||isNaN(l.y)||isNaN(l.z)||l.x===1/0||l.y===1/0||l.z===1/0)throw"Could not solve equation! Got x=["+l.toString()+"], b=["+o.toString()+"], A=["+this.toString()+"]";return l},s.prototype.e=function(o,l,h){if(h===void 0)return this.elements[l+3*o];this.elements[l+3*o]=h},s.prototype.copy=function(o){for(var l=0;l<o.elements.length;l++)this.elements[l]=o.elements[l];return this},s.prototype.toString=function(){for(var o="",l=",",h=0;h<9;h++)o+=this.elements[h]+l;return o},s.prototype.reverse=function(o){o=o||new s;for(var l=3,h=6,u=[],c=0;c<l*h;c++)u.push(0);var c,d;for(c=0;c<3;c++)for(d=0;d<3;d++)u[c+h*d]=this.elements[c+3*d];u[3+6*0]=1,u[3+6*1]=0,u[3+6*2]=0,u[4+6*0]=0,u[4+6*1]=1,u[4+6*2]=0,u[5+6*0]=0,u[5+6*1]=0,u[5+6*2]=1;var p=3,f=p,g,y=h,m;do{if(c=f-p,u[c+h*c]===0){for(d=c+1;d<f;d++)if(u[c+h*d]!==0){g=y;do m=y-g,u[m+h*c]+=u[m+h*d];while(--g);break}}if(u[c+h*c]!==0)for(d=c+1;d<f;d++){var v=u[c+h*d]/u[c+h*c];g=y;do m=y-g,u[m+h*d]=m<=c?0:u[m+h*d]-u[m+h*c]*v;while(--g)}}while(--p);c=2;do{d=c-1;do{var v=u[c+h*d]/u[c+h*c];g=h;do m=h-g,u[m+h*d]=u[m+h*d]-u[m+h*c]*v;while(--g)}while(d--)}while(--c);c=2;do{var v=1/u[c+h*c];g=h;do m=h-g,u[m+h*c]=u[m+h*c]*v;while(--g)}while(c--);c=2;do{d=2;do{if(m=u[l+d+h*c],isNaN(m)||m===1/0)throw"Could not reverse! A=["+this.toString()+"]";o.e(c,d,m)}while(d--)}while(c--);return o},s.prototype.setRotationFromQuaternion=function(o){var l=o.x,h=o.y,u=o.z,c=o.w,d=l+l,p=h+h,f=u+u,g=l*d,y=l*p,m=l*f,v=h*p,_=h*f,x=u*f,w=c*d,C=c*p,M=c*f,D=this.elements;return D[3*0+0]=1-(v+x),D[3*0+1]=y-M,D[3*0+2]=m+C,D[3*1+0]=y+M,D[3*1+1]=1-(g+x),D[3*1+2]=_-w,D[3*2+0]=m-C,D[3*2+1]=_+w,D[3*2+2]=1-(g+v),this},s.prototype.transpose=function(o){o=o||new s;for(var l=o.elements,h=this.elements,u=0;u!==3;u++)for(var c=0;c!==3;c++)l[3*u+c]=h[3*c+u];return o}},{"./Vec3":30}],28:[function(e,n,i){n.exports=s;var r=e("./Vec3");function s(d,p,f,g){this.x=d!==void 0?d:0,this.y=p!==void 0?p:0,this.z=f!==void 0?f:0,this.w=g!==void 0?g:1}s.prototype.set=function(d,p,f,g){this.x=d,this.y=p,this.z=f,this.w=g},s.prototype.toString=function(){return this.x+","+this.y+","+this.z+","+this.w},s.prototype.toArray=function(){return[this.x,this.y,this.z,this.w]},s.prototype.setFromAxisAngle=function(d,p){var f=Math.sin(p*.5);this.x=d.x*f,this.y=d.y*f,this.z=d.z*f,this.w=Math.cos(p*.5)},s.prototype.toAxisAngle=function(d){d=d||new r,this.normalize();var p=2*Math.acos(this.w),f=Math.sqrt(1-this.w*this.w);return f<.001?(d.x=this.x,d.y=this.y,d.z=this.z):(d.x=this.x/f,d.y=this.y/f,d.z=this.z/f),[d,p]};var o=new r,l=new r;s.prototype.setFromVectors=function(d,p){if(d.isAntiparallelTo(p)){var f=o,g=l;d.tangents(f,g),this.setFromAxisAngle(f,Math.PI)}else{var y=d.cross(p);this.x=y.x,this.y=y.y,this.z=y.z,this.w=Math.sqrt(Math.pow(d.norm(),2)*Math.pow(p.norm(),2))+d.dot(p),this.normalize()}};var h=new r,u=new r,c=new r;s.prototype.mult=function(d,p){p=p||new s;var f=this.w,g=h,y=u,m=c;return g.set(this.x,this.y,this.z),y.set(d.x,d.y,d.z),p.w=f*d.w-g.dot(y),g.cross(y,m),p.x=f*y.x+d.w*g.x+m.x,p.y=f*y.y+d.w*g.y+m.y,p.z=f*y.z+d.w*g.z+m.z,p},s.prototype.inverse=function(d){var p=this.x,f=this.y,g=this.z,y=this.w;d=d||new s,this.conjugate(d);var m=1/(p*p+f*f+g*g+y*y);return d.x*=m,d.y*=m,d.z*=m,d.w*=m,d},s.prototype.conjugate=function(d){return d=d||new s,d.x=-this.x,d.y=-this.y,d.z=-this.z,d.w=this.w,d},s.prototype.normalize=function(){var d=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);d===0?(this.x=0,this.y=0,this.z=0,this.w=0):(d=1/d,this.x*=d,this.y*=d,this.z*=d,this.w*=d)},s.prototype.normalizeFast=function(){var d=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;d===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=d,this.y*=d,this.z*=d,this.w*=d)},s.prototype.vmult=function(d,p){p=p||new r;var f=d.x,g=d.y,y=d.z,m=this.x,v=this.y,_=this.z,x=this.w,w=x*f+v*y-_*g,C=x*g+_*f-m*y,M=x*y+m*g-v*f,D=-m*f-v*g-_*y;return p.x=w*x+D*-m+C*-_-M*-v,p.y=C*x+D*-v+M*-m-w*-_,p.z=M*x+D*-_+w*-v-C*-m,p},s.prototype.copy=function(d){return this.x=d.x,this.y=d.y,this.z=d.z,this.w=d.w,this},s.prototype.toEuler=function(d,p){p=p||"YZX";var f,g,y,m=this.x,v=this.y,_=this.z,x=this.w;switch(p){case"YZX":var w=m*v+_*x;if(w>.499&&(f=2*Math.atan2(m,x),g=Math.PI/2,y=0),w<-.499&&(f=-2*Math.atan2(m,x),g=-Math.PI/2,y=0),isNaN(f)){var C=m*m,M=v*v,D=_*_;f=Math.atan2(2*v*x-2*m*_,1-2*M-2*D),g=Math.asin(2*w),y=Math.atan2(2*m*x-2*v*_,1-2*C-2*D)}break;default:throw new Error("Euler order "+p+" not supported yet.")}d.y=f,d.z=g,d.x=y},s.prototype.setFromEuler=function(d,p,f,g){g=g||"XYZ";var y=Math.cos(d/2),m=Math.cos(p/2),v=Math.cos(f/2),_=Math.sin(d/2),x=Math.sin(p/2),w=Math.sin(f/2);return g==="XYZ"?(this.x=_*m*v+y*x*w,this.y=y*x*v-_*m*w,this.z=y*m*w+_*x*v,this.w=y*m*v-_*x*w):g==="YXZ"?(this.x=_*m*v+y*x*w,this.y=y*x*v-_*m*w,this.z=y*m*w-_*x*v,this.w=y*m*v+_*x*w):g==="ZXY"?(this.x=_*m*v-y*x*w,this.y=y*x*v+_*m*w,this.z=y*m*w+_*x*v,this.w=y*m*v-_*x*w):g==="ZYX"?(this.x=_*m*v-y*x*w,this.y=y*x*v+_*m*w,this.z=y*m*w-_*x*v,this.w=y*m*v+_*x*w):g==="YZX"?(this.x=_*m*v+y*x*w,this.y=y*x*v+_*m*w,this.z=y*m*w-_*x*v,this.w=y*m*v-_*x*w):g==="XZY"&&(this.x=_*m*v-y*x*w,this.y=y*x*v-_*m*w,this.z=y*m*w+_*x*v,this.w=y*m*v+_*x*w),this},s.prototype.clone=function(){return new s(this.x,this.y,this.z,this.w)}},{"./Vec3":30}],29:[function(e,n,i){var r=e("./Vec3"),s=e("./Quaternion");n.exports=o;function o(h){h=h||{},this.position=new r,h.position&&this.position.copy(h.position),this.quaternion=new s,h.quaternion&&this.quaternion.copy(h.quaternion)}var l=new s;o.pointToLocalFrame=function(h,u,c,d){var d=d||new r;return c.vsub(h,d),u.conjugate(l),l.vmult(d,d),d},o.prototype.pointToLocal=function(h,u){return o.pointToLocalFrame(this.position,this.quaternion,h,u)},o.pointToWorldFrame=function(h,u,c,d){var d=d||new r;return u.vmult(c,d),d.vadd(h,d),d},o.prototype.pointToWorld=function(h,u){return o.pointToWorldFrame(this.position,this.quaternion,h,u)},o.prototype.vectorToWorldFrame=function(h,u){var u=u||new r;return this.quaternion.vmult(h,u),u},o.vectorToWorldFrame=function(h,u,c){return h.vmult(u,c),c},o.vectorToLocalFrame=function(h,u,c,d){var d=d||new r;return u.w*=-1,u.vmult(c,d),u.w*=-1,d}},{"./Quaternion":28,"./Vec3":30}],30:[function(e,n,i){n.exports=s;var r=e("./Mat3");function s(u,c,d){this.x=u||0,this.y=c||0,this.z=d||0}s.ZERO=new s(0,0,0),s.UNIT_X=new s(1,0,0),s.UNIT_Y=new s(0,1,0),s.UNIT_Z=new s(0,0,1),s.prototype.cross=function(u,c){var d=u.x,p=u.y,f=u.z,g=this.x,y=this.y,m=this.z;return c=c||new s,c.x=y*f-m*p,c.y=m*d-g*f,c.z=g*p-y*d,c},s.prototype.set=function(u,c,d){return this.x=u,this.y=c,this.z=d,this},s.prototype.setZero=function(){this.x=this.y=this.z=0},s.prototype.vadd=function(u,c){if(c)c.x=u.x+this.x,c.y=u.y+this.y,c.z=u.z+this.z;else return new s(this.x+u.x,this.y+u.y,this.z+u.z)},s.prototype.vsub=function(u,c){if(c)c.x=this.x-u.x,c.y=this.y-u.y,c.z=this.z-u.z;else return new s(this.x-u.x,this.y-u.y,this.z-u.z)},s.prototype.crossmat=function(){return new r([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])},s.prototype.normalize=function(){var u=this.x,c=this.y,d=this.z,p=Math.sqrt(u*u+c*c+d*d);if(p>0){var f=1/p;this.x*=f,this.y*=f,this.z*=f}else this.x=0,this.y=0,this.z=0;return p},s.prototype.unit=function(u){u=u||new s;var c=this.x,d=this.y,p=this.z,f=Math.sqrt(c*c+d*d+p*p);return f>0?(f=1/f,u.x=c*f,u.y=d*f,u.z=p*f):(u.x=1,u.y=0,u.z=0),u},s.prototype.norm=function(){var u=this.x,c=this.y,d=this.z;return Math.sqrt(u*u+c*c+d*d)},s.prototype.length=s.prototype.norm,s.prototype.norm2=function(){return this.dot(this)},s.prototype.lengthSquared=s.prototype.norm2,s.prototype.distanceTo=function(u){var c=this.x,d=this.y,p=this.z,f=u.x,g=u.y,y=u.z;return Math.sqrt((f-c)*(f-c)+(g-d)*(g-d)+(y-p)*(y-p))},s.prototype.distanceSquared=function(u){var c=this.x,d=this.y,p=this.z,f=u.x,g=u.y,y=u.z;return(f-c)*(f-c)+(g-d)*(g-d)+(y-p)*(y-p)},s.prototype.mult=function(u,c){c=c||new s;var d=this.x,p=this.y,f=this.z;return c.x=u*d,c.y=u*p,c.z=u*f,c},s.prototype.scale=s.prototype.mult,s.prototype.dot=function(u){return this.x*u.x+this.y*u.y+this.z*u.z},s.prototype.isZero=function(){return this.x===0&&this.y===0&&this.z===0},s.prototype.negate=function(u){return u=u||new s,u.x=-this.x,u.y=-this.y,u.z=-this.z,u};var o=new s,l=new s;s.prototype.tangents=function(u,c){var d=this.norm();if(d>0){var p=o,f=1/d;p.set(this.x*f,this.y*f,this.z*f);var g=l;Math.abs(p.x)<.9?(g.set(1,0,0),p.cross(g,u)):(g.set(0,1,0),p.cross(g,u)),p.cross(u,c)}else u.set(1,0,0),c.set(0,1,0)},s.prototype.toString=function(){return this.x+","+this.y+","+this.z},s.prototype.toArray=function(){return[this.x,this.y,this.z]},s.prototype.copy=function(u){return this.x=u.x,this.y=u.y,this.z=u.z,this},s.prototype.lerp=function(u,c,d){var p=this.x,f=this.y,g=this.z;d.x=p+(u.x-p)*c,d.y=f+(u.y-f)*c,d.z=g+(u.z-g)*c},s.prototype.almostEquals=function(u,c){return c===void 0&&(c=1e-6),!(Math.abs(this.x-u.x)>c||Math.abs(this.y-u.y)>c||Math.abs(this.z-u.z)>c)},s.prototype.almostZero=function(u){return u===void 0&&(u=1e-6),!(Math.abs(this.x)>u||Math.abs(this.y)>u||Math.abs(this.z)>u)};var h=new s;s.prototype.isAntiparallelTo=function(u,c){return this.negate(h),h.almostEquals(u,c)},s.prototype.clone=function(){return new s(this.x,this.y,this.z)}},{"./Mat3":27}],31:[function(e,n,i){n.exports=c;var r=e("../utils/EventTarget");e("../shapes/Shape");var s=e("../math/Vec3"),o=e("../math/Mat3"),l=e("../math/Quaternion");e("../material/Material");var h=e("../collision/AABB"),u=e("../shapes/Box");function c(b){b=b||{},r.apply(this),this.id=c.idCounter++,this.world=null,this.preStep=null,this.postStep=null,this.vlambda=new s,this.collisionFilterGroup=typeof b.collisionFilterGroup=="number"?b.collisionFilterGroup:1,this.collisionFilterMask=typeof b.collisionFilterMask=="number"?b.collisionFilterMask:1,this.collisionResponse=!0,this.position=new s,b.position&&this.position.copy(b.position),this.previousPosition=new s,this.initPosition=new s,this.velocity=new s,b.velocity&&this.velocity.copy(b.velocity),this.initVelocity=new s,this.force=new s;var U=typeof b.mass=="number"?b.mass:0;this.mass=U,this.invMass=U>0?1/U:0,this.material=b.material||null,this.linearDamping=typeof b.linearDamping=="number"?b.linearDamping:.01,this.type=U<=0?c.STATIC:c.DYNAMIC,typeof b.type==typeof c.STATIC&&(this.type=b.type),this.allowSleep=typeof b.allowSleep!="undefined"?b.allowSleep:!0,this.sleepState=0,this.sleepSpeedLimit=typeof b.sleepSpeedLimit!="undefined"?b.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof b.sleepTimeLimit!="undefined"?b.sleepTimeLimit:1,this.timeLastSleepy=0,this._wakeUpAfterNarrowphase=!1,this.torque=new s,this.quaternion=new l,b.quaternion&&this.quaternion.copy(b.quaternion),this.initQuaternion=new l,this.angularVelocity=new s,b.angularVelocity&&this.angularVelocity.copy(b.angularVelocity),this.initAngularVelocity=new s,this.interpolatedPosition=new s,this.interpolatedQuaternion=new l,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new s,this.invInertia=new s,this.invInertiaWorld=new o,this.invMassSolve=0,this.invInertiaSolve=new s,this.invInertiaWorldSolve=new o,this.fixedRotation=typeof b.fixedRotation!="undefined"?b.fixedRotation:!1,this.angularDamping=typeof b.angularDamping!="undefined"?b.angularDamping:.01,this.aabb=new h,this.aabbNeedsUpdate=!0,this.wlambda=new s,b.shape&&this.addShape(b.shape),this.updateMassProperties()}c.prototype=new r,c.prototype.constructor=c,c.DYNAMIC=1,c.STATIC=2,c.KINEMATIC=4,c.AWAKE=0,c.SLEEPY=1,c.SLEEPING=2,c.idCounter=0,c.prototype.wakeUp=function(){var b=this.sleepState;this.sleepState=0,b===c.SLEEPING&&this.dispatchEvent({type:"wakeup"})},c.prototype.sleep=function(){this.sleepState=c.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0)},c.sleepyEvent={type:"sleepy"},c.sleepEvent={type:"sleep"},c.prototype.sleepTick=function(b){if(this.allowSleep){var U=this.sleepState,V=this.velocity.norm2()+this.angularVelocity.norm2(),H=Math.pow(this.sleepSpeedLimit,2);U===c.AWAKE&&V<H?(this.sleepState=c.SLEEPY,this.timeLastSleepy=b,this.dispatchEvent(c.sleepyEvent)):U===c.SLEEPY&&V>H?this.wakeUp():U===c.SLEEPY&&b-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(c.sleepEvent))}},c.prototype.updateSolveMassProperties=function(){this.sleepState===c.SLEEPING||this.type===c.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))},c.prototype.pointToLocalFrame=function(b,U){var U=U||new s;return b.vsub(this.position,U),this.quaternion.conjugate().vmult(U,U),U},c.prototype.vectorToLocalFrame=function(b,U){var U=U||new s;return this.quaternion.conjugate().vmult(b,U),U},c.prototype.pointToWorldFrame=function(b,U){var U=U||new s;return this.quaternion.vmult(b,U),U.vadd(this.position,U),U},c.prototype.vectorToWorldFrame=function(b,U){var U=U||new s;return this.quaternion.vmult(b,U),U};var d=new s,p=new l;c.prototype.addShape=function(b,U,V){var H=new s,Y=new l;return U&&H.copy(U),V&&Y.copy(V),this.shapes.push(b),this.shapeOffsets.push(H),this.shapeOrientations.push(Y),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,this},c.prototype.updateBoundingRadius=function(){for(var b=this.shapes,U=this.shapeOffsets,V=b.length,H=0,Y=0;Y!==V;Y++){var Q=b[Y];Q.updateBoundingSphereRadius();var P=U[Y].norm(),z=Q.boundingSphereRadius;P+z>H&&(H=P+z)}this.boundingRadius=H};var f=new h;c.prototype.computeAABB=function(){for(var b=this.shapes,U=this.shapeOffsets,V=this.shapeOrientations,H=b.length,Y=d,Q=p,P=this.quaternion,z=this.aabb,it=f,W=0;W!==H;W++){var T=b[W];V[W].mult(P,Q),Q.vmult(U[W],Y),Y.vadd(this.position,Y),T.calculateWorldAABB(Y,Q,it.lowerBound,it.upperBound),W===0?z.copy(it):z.extend(it)}this.aabbNeedsUpdate=!1};var g=new o,y=new o;new o,c.prototype.updateInertiaWorld=function(b){var U=this.invInertia;if(!(U.x===U.y&&U.y===U.z&&!b)){var V=g,H=y;V.setRotationFromQuaternion(this.quaternion),V.transpose(H),V.scale(U,V),V.mmult(H,this.invInertiaWorld)}};var m=new s,v=new s;c.prototype.applyForce=function(b,U){if(this.type===c.DYNAMIC){var V=m;U.vsub(this.position,V);var H=v;V.cross(b,H),this.force.vadd(b,this.force),this.torque.vadd(H,this.torque)}};var _=new s,x=new s;c.prototype.applyLocalForce=function(b,U){if(this.type===c.DYNAMIC){var V=_,H=x;this.vectorToWorldFrame(b,V),this.pointToWorldFrame(U,H),this.applyForce(V,H)}};var w=new s,C=new s,M=new s;c.prototype.applyImpulse=function(b,U){if(this.type===c.DYNAMIC){var V=w;U.vsub(this.position,V);var H=C;H.copy(b),H.mult(this.invMass,H),this.velocity.vadd(H,this.velocity);var Y=M;V.cross(b,Y),this.invInertiaWorld.vmult(Y,Y),this.angularVelocity.vadd(Y,this.angularVelocity)}};var D=new s,j=new s;c.prototype.applyLocalImpulse=function(b,U){if(this.type===c.DYNAMIC){var V=D,H=j;this.vectorToWorldFrame(b,V),this.pointToWorldFrame(U,H),this.applyImpulse(V,H)}};var N=new s;c.prototype.updateMassProperties=function(){var b=N;this.invMass=this.mass>0?1/this.mass:0;var U=this.inertia,V=this.fixedRotation;this.computeAABB(),b.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),u.calculateInertia(b,this.mass,U),this.invInertia.set(U.x>0&&!V?1/U.x:0,U.y>0&&!V?1/U.y:0,U.z>0&&!V?1/U.z:0),this.updateInertiaWorld(!0)},c.prototype.getVelocityAtWorldPoint=function(b,U){var V=new s;return b.vsub(this.position,V),this.angularVelocity.cross(V,U),this.velocity.vadd(U,U),U}},{"../collision/AABB":3,"../material/Material":25,"../math/Mat3":27,"../math/Quaternion":28,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Shape":43,"../utils/EventTarget":49}],32:[function(e,n,i){e("./Body");var r=e("../math/Vec3"),s=e("../math/Quaternion");e("../collision/RaycastResult");var o=e("../collision/Ray"),l=e("../objects/WheelInfo");n.exports=h;function h(P){this.chassisBody=P.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=typeof P.indexRightAxis!="undefined"?P.indexRightAxis:1,this.indexForwardAxis=typeof P.indexForwardAxis!="undefined"?P.indexForwardAxis:0,this.indexUpAxis=typeof P.indexUpAxis!="undefined"?P.indexUpAxis:2}new r,new r,new r;var u=new r,c=new r,d=new r;new o,h.prototype.addWheel=function(P){P=P||{};var z=new l(P),it=this.wheelInfos.length;return this.wheelInfos.push(z),it},h.prototype.setSteeringValue=function(P,z){var it=this.wheelInfos[z];it.steering=P},new r,h.prototype.applyEngineForce=function(P,z){this.wheelInfos[z].engineForce=P},h.prototype.setBrake=function(P,z){this.wheelInfos[z].brake=P},h.prototype.addToWorld=function(P){this.constraints,P.add(this.chassisBody);var z=this;this.preStepCallback=function(){z.updateVehicle(P.dt)},P.addEventListener("preStep",this.preStepCallback),this.world=P},h.prototype.getVehicleAxisWorld=function(P,z){z.set(P===0?1:0,P===1?1:0,P===2?1:0),this.chassisBody.vectorToWorldFrame(z,z)},h.prototype.updateVehicle=function(P){for(var z=this.wheelInfos,it=z.length,W=this.chassisBody,T=0;T<it;T++)this.updateWheelTransform(T);this.currentVehicleSpeedKmHour=3.6*W.velocity.norm();var Z=new r;this.getVehicleAxisWorld(this.indexForwardAxis,Z),Z.dot(W.velocity)<0&&(this.currentVehicleSpeedKmHour*=-1);for(var T=0;T<it;T++)this.castRay(z[T]);this.updateSuspension(P);for(var A=new r,I=new r,T=0;T<it;T++){var R=z[T],F=R.suspensionForce;F>R.maxSuspensionForce&&(F=R.maxSuspensionForce),R.raycastResult.hitNormalWorld.scale(F*P,A),R.raycastResult.hitPointWorld.vsub(W.position,I),W.applyImpulse(A,R.raycastResult.hitPointWorld)}this.updateFriction(P);var ot=new r,et=new r,k=new r;for(T=0;T<it;T++){var R=z[T];W.getVelocityAtWorldPoint(R.chassisConnectionPointWorld,k);var nt=1;switch(this.indexUpAxis){case 1:nt=-1;break}if(R.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,et);var lt=et.dot(R.raycastResult.hitNormalWorld);R.raycastResult.hitNormalWorld.scale(lt,ot),et.vsub(ot,et);var $=et.dot(k);R.deltaRotation=nt*$*P/R.radius}(R.sliding||!R.isInContact)&&R.engineForce!==0&&R.useCustomSlidingRotationalSpeed&&(R.deltaRotation=(R.engineForce>0?1:-1)*R.customSlidingRotationalSpeed*P),Math.abs(R.brake)>Math.abs(R.engineForce)&&(R.deltaRotation=0),R.rotation+=R.deltaRotation,R.deltaRotation*=.99}},h.prototype.updateSuspension=function(P){for(var z=this.chassisBody,it=z.mass,W=this.wheelInfos,T=W.length,Z=0;Z<T;Z++){var A=W[Z];if(A.isInContact){var I,R=A.suspensionRestLength,F=A.suspensionLength,ot=R-F;I=A.suspensionStiffness*ot*A.clippedInvContactDotSuspension;var et=A.suspensionRelativeVelocity,k;et<0?k=A.dampingCompression:k=A.dampingRelaxation,I-=k*et,A.suspensionForce=I*it,A.suspensionForce<0&&(A.suspensionForce=0)}else A.suspensionForce=0}},h.prototype.removeFromWorld=function(P){this.constraints,P.remove(this.chassisBody),P.removeEventListener("preStep",this.preStepCallback),this.world=null};var p=new r,f=new r;h.prototype.castRay=function(P){var z=p,it=f;this.updateWheelTransformWorld(P);var W=this.chassisBody,T=-1,Z=P.suspensionRestLength+P.radius;P.directionWorld.scale(Z,z);var A=P.chassisConnectionPointWorld;A.vadd(z,it);var I=P.raycastResult;I.reset();var R=W.collisionResponse;W.collisionResponse=!1,this.world.rayTest(A,it,I),W.collisionResponse=R;var F=I.body;if(P.raycastResult.groundObject=0,F){T=I.distance,P.raycastResult.hitNormalWorld=I.hitNormalWorld,P.isInContact=!0;var ot=I.distance;P.suspensionLength=ot-P.radius;var et=P.suspensionRestLength-P.maxSuspensionTravel,k=P.suspensionRestLength+P.maxSuspensionTravel;P.suspensionLength<et&&(P.suspensionLength=et),P.suspensionLength>k&&(P.suspensionLength=k,P.raycastResult.reset());var nt=P.raycastResult.hitNormalWorld.dot(P.directionWorld),lt=new r;W.getVelocityAtWorldPoint(P.raycastResult.hitPointWorld,lt);var $=P.raycastResult.hitNormalWorld.dot(lt);if(nt>=-.1)P.suspensionRelativeVelocity=0,P.clippedInvContactDotSuspension=1/.1;else{var rt=-1/nt;P.suspensionRelativeVelocity=$*rt,P.clippedInvContactDotSuspension=rt}}else P.suspensionLength=P.suspensionRestLength+0*P.maxSuspensionTravel,P.suspensionRelativeVelocity=0,P.directionWorld.scale(-1,P.raycastResult.hitNormalWorld),P.clippedInvContactDotSuspension=1;return T},h.prototype.updateWheelTransformWorld=function(P){P.isInContact=!1;var z=this.chassisBody;z.pointToWorldFrame(P.chassisConnectionPointLocal,P.chassisConnectionPointWorld),z.vectorToWorldFrame(P.directionLocal,P.directionWorld),z.vectorToWorldFrame(P.axleLocal,P.axleWorld)},h.prototype.updateWheelTransform=function(P){var z=u,it=c,W=d,T=this.wheelInfos[P];this.updateWheelTransformWorld(T),T.directionLocal.scale(-1,z),it.copy(T.axleLocal),z.cross(it,W),W.normalize(),it.normalize();var Z=T.steering,A=new s;A.setFromAxisAngle(z,Z);var I=new s;I.setFromAxisAngle(it,T.rotation);var R=T.worldTransform.quaternion;this.chassisBody.quaternion.mult(A,R),R.mult(I,R),R.normalize();var F=T.worldTransform.position;F.copy(T.directionWorld),F.scale(T.suspensionLength,F),F.vadd(T.chassisConnectionPointWorld,F)};var g=[new r(1,0,0),new r(0,1,0),new r(0,0,1)];h.prototype.getWheelTransformWorld=function(P){return this.wheelInfos[P].worldTransform};var y=new r,m=[],v=[],_=1;h.prototype.updateFriction=function(P){for(var z=y,it=this.wheelInfos,W=it.length,T=this.chassisBody,Z=v,A=m,I=0;I<W;I++){var R=it[I],F=R.raycastResult.body;R.sideImpulse=0,R.forwardImpulse=0,Z[I]||(Z[I]=new r),A[I]||(A[I]=new r)}for(var I=0;I<W;I++){var R=it[I],F=R.raycastResult.body;if(F){var ot=A[I],et=this.getWheelTransformWorld(I);et.vectorToWorldFrame(g[this.indexRightAxis],ot);var k=R.raycastResult.hitNormalWorld,nt=ot.dot(k);k.scale(nt,z),ot.vsub(z,ot),ot.normalize(),k.cross(ot,Z[I]),Z[I].normalize(),R.sideImpulse=Q(T,R.raycastResult.hitPointWorld,F,R.raycastResult.hitPointWorld,ot),R.sideImpulse*=_}}var lt=1,$=.5;this.sliding=!1;for(var I=0;I<W;I++){var R=it[I],F=R.raycastResult.body,rt=0;if(R.slipInfo=1,F){var st=0,K=R.brake?R.brake:st;rt=M(T,F,R.raycastResult.hitPointWorld,Z[I],K),rt+=R.engineForce*P;var tt=K/rt;R.slipInfo*=tt}if(R.forwardImpulse=0,R.skidInfo=1,F){R.skidInfo=1;var Lt=R.suspensionForce*P*R.frictionSlip,St=Lt,zt=Lt*St;R.forwardImpulse=rt;var Pt=R.forwardImpulse*$,L=R.sideImpulse*lt,E=Pt*Pt+L*L;if(R.sliding=!1,E>zt){this.sliding=!0,R.sliding=!0;var tt=Lt/Math.sqrt(E);R.skidInfo*=tt}}}if(this.sliding)for(var I=0;I<W;I++){var R=it[I];R.sideImpulse!==0&&R.skidInfo<1&&(R.forwardImpulse*=R.skidInfo,R.sideImpulse*=R.skidInfo)}for(var I=0;I<W;I++){var R=it[I],at=new r;if(at.copy(R.raycastResult.hitPointWorld),R.forwardImpulse!==0){var ht=new r;Z[I].scale(R.forwardImpulse,ht),T.applyImpulse(ht,at)}if(R.sideImpulse!==0){var F=R.raycastResult.body,bt=new r;bt.copy(R.raycastResult.hitPointWorld);var Ct=new r;A[I].scale(R.sideImpulse,Ct),T.pointToLocalFrame(at,at),at["xyz"[this.indexUpAxis]]*=R.rollInfluence,T.pointToWorldFrame(at,at),T.applyImpulse(Ct,at),Ct.scale(-1,Ct),F.applyImpulse(Ct,bt)}}};var x=new r,w=new r,C=new r;function M(P,z,it,W,T){var Z=0,A=it,I=x,R=w,F=C;P.getVelocityAtWorldPoint(A,I),z.getVelocityAtWorldPoint(A,R),I.vsub(R,F);var ot=W.dot(F),et=U(P,it,W),k=U(z,it,W),nt=1,lt=nt/(et+k);return Z=-ot*lt,T<Z&&(Z=T),Z<-T&&(Z=-T),Z}var D=new r,j=new r,N=new r,b=new r;function U(P,z,it){var W=D,T=j,Z=N,A=b;return z.vsub(P.position,W),W.cross(it,T),P.invInertiaWorld.vmult(T,A),A.cross(W,Z),P.invMass+it.dot(Z)}var V=new r,H=new r,Y=new r;function Q(P,z,it,W,T,Z){var A=T.norm2();if(A>1.1)return 0;var I=V,R=H,F=Y;P.getVelocityAtWorldPoint(z,I),it.getVelocityAtWorldPoint(W,R),I.vsub(R,F);var ot=T.dot(F),et=.2,k=1/(P.invMass+it.invMass),Z=-et*ot*k;return Z}},{"../collision/Ray":9,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Vec3":30,"../objects/WheelInfo":36,"./Body":31}],33:[function(e,n,i){var r=e("./Body"),s=e("../shapes/Sphere"),o=e("../shapes/Box"),l=e("../math/Vec3"),h=e("../constraints/HingeConstraint");n.exports=u;function u(p){if(this.wheelBodies=[],this.coordinateSystem=typeof p.coordinateSystem=="undefined"?new l(1,2,3):p.coordinateSystem.clone(),this.chassisBody=p.chassisBody,!this.chassisBody){var f=new o(new l(5,2,.5));this.chassisBody=new r(1,f)}this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}u.prototype.addWheel=function(p){p=p||{};var f=p.body;f||(f=new r(1,new s(1.2))),this.wheelBodies.push(f),this.wheelForces.push(0),new l;var g=typeof p.position!="undefined"?p.position.clone():new l,y=new l;this.chassisBody.pointToWorldFrame(g,y),f.position.set(y.x,y.y,y.z);var m=typeof p.axis!="undefined"?p.axis.clone():new l(0,1,0);this.wheelAxes.push(m);var v=new h(this.chassisBody,f,{pivotA:g,axisA:m,pivotB:l.ZERO,axisB:m,collideConnected:!1});return this.constraints.push(v),this.wheelBodies.length-1},u.prototype.setSteeringValue=function(p,f){var g=this.wheelAxes[f],y=Math.cos(p),m=Math.sin(p),v=g.x,_=g.y;this.constraints[f].axisA.set(y*v-m*_,m*v+y*_,0)},u.prototype.setMotorSpeed=function(p,f){var g=this.constraints[f];g.enableMotor(),g.motorTargetVelocity=p},u.prototype.disableMotor=function(p){var f=this.constraints[p];f.disableMotor()};var c=new l;u.prototype.setWheelForce=function(p,f){this.wheelForces[f]=p},u.prototype.applyWheelForce=function(p,f){var g=this.wheelAxes[f],y=this.wheelBodies[f],m=y.torque;g.scale(p,c),y.vectorToWorldFrame(c,c),m.vadd(c,m)},u.prototype.addToWorld=function(p){for(var f=this.constraints,g=this.wheelBodies.concat([this.chassisBody]),y=0;y<g.length;y++)p.add(g[y]);for(var y=0;y<f.length;y++)p.addConstraint(f[y]);p.addEventListener("preStep",this._update.bind(this))},u.prototype._update=function(){for(var p=this.wheelForces,f=0;f<p.length;f++)this.applyWheelForce(p[f],f)},u.prototype.removeFromWorld=function(p){for(var f=this.constraints,g=this.wheelBodies.concat([this.chassisBody]),y=0;y<g.length;y++)p.remove(g[y]);for(var y=0;y<f.length;y++)p.removeConstraint(f[y])};var d=new l;u.prototype.getWheelSpeed=function(p){var f=this.wheelAxes[p],g=this.wheelBodies[p],y=g.angularVelocity;return this.chassisBody.vectorToWorldFrame(f,d),y.dot(d)}},{"../constraints/HingeConstraint":15,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Sphere":44,"./Body":31}],34:[function(e,n,i){n.exports=s,e("../shapes/Shape");var r=e("../math/Vec3");e("../math/Quaternion"),e("../shapes/Particle"),e("../objects/Body"),e("../material/Material");function s(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}s.prototype.add=function(f){this.particles.push(f),this.neighbors.length<this.particles.length&&this.neighbors.push([])},s.prototype.remove=function(f){var g=this.particles.indexOf(f);g!==-1&&(this.particles.splice(g,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())};var o=new r;s.prototype.getNeighbors=function(f,g){for(var y=this.particles.length,m=f.id,v=this.smoothingRadius*this.smoothingRadius,_=o,x=0;x!==y;x++){var w=this.particles[x];w.position.vsub(f.position,_),m!==w.id&&_.norm2()<v&&g.push(w)}};var l=new r,h=new r,u=new r,c=new r,d=new r,p=new r;s.prototype.update=function(){for(var f=this.particles.length,g=l,y=this.speedOfSound,m=this.eps,v=0;v!==f;v++){var _=this.particles[v],x=this.neighbors[v];x.length=0,this.getNeighbors(_,x),x.push(this.particles[v]);for(var w=x.length,C=0,M=0;M!==w;M++){_.position.vsub(x[M].position,g);var D=g.norm(),j=this.w(D);C+=x[M].mass*j}this.densities[v]=C,this.pressures[v]=y*y*(this.densities[v]-this.density)}for(var N=h,b=u,U=c,V=d,H=p,v=0;v!==f;v++){var Y=this.particles[v];N.set(0,0,0),b.set(0,0,0);for(var Q,P,x=this.neighbors[v],w=x.length,M=0;M!==w;M++){var z=x[M];Y.position.vsub(z.position,V);var it=V.norm();Q=-z.mass*(this.pressures[v]/(this.densities[v]*this.densities[v]+m)+this.pressures[M]/(this.densities[M]*this.densities[M]+m)),this.gradw(V,U),U.mult(Q,U),N.vadd(U,N),z.velocity.vsub(Y.velocity,H),H.mult(1/(1e-4+this.densities[v]*this.densities[M])*this.viscosity*z.mass,H),P=this.nablaw(it),H.mult(P,H),b.vadd(H,b)}b.mult(Y.mass,b),N.mult(Y.mass,N),Y.force.vadd(b,Y.force),Y.force.vadd(N,Y.force)}},s.prototype.w=function(f){var g=this.smoothingRadius;return 315/(64*Math.PI*Math.pow(g,9))*Math.pow(g*g-f*f,3)},s.prototype.gradw=function(f,g){var y=f.norm(),m=this.smoothingRadius;f.mult(945/(32*Math.PI*Math.pow(m,9))*Math.pow(m*m-y*y,2),g)},s.prototype.nablaw=function(f){var g=this.smoothingRadius,y=945/(32*Math.PI*Math.pow(g,9))*(g*g-f*f)*(7*f*f-3*g*g);return y}},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Particle":41,"../shapes/Shape":43}],35:[function(e,n,i){var r=e("../math/Vec3");n.exports=s;function s(v,_,x){x=x||{},this.restLength=typeof x.restLength=="number"?x.restLength:1,this.stiffness=x.stiffness||100,this.damping=x.damping||1,this.bodyA=v,this.bodyB=_,this.localAnchorA=new r,this.localAnchorB=new r,x.localAnchorA&&this.localAnchorA.copy(x.localAnchorA),x.localAnchorB&&this.localAnchorB.copy(x.localAnchorB),x.worldAnchorA&&this.setWorldAnchorA(x.worldAnchorA),x.worldAnchorB&&this.setWorldAnchorB(x.worldAnchorB)}s.prototype.setWorldAnchorA=function(v){this.bodyA.pointToLocalFrame(v,this.localAnchorA)},s.prototype.setWorldAnchorB=function(v){this.bodyB.pointToLocalFrame(v,this.localAnchorB)},s.prototype.getWorldAnchorA=function(v){this.bodyA.pointToWorldFrame(this.localAnchorA,v)},s.prototype.getWorldAnchorB=function(v){this.bodyB.pointToWorldFrame(this.localAnchorB,v)};var o=new r,l=new r,h=new r,u=new r,c=new r,d=new r,p=new r,f=new r,g=new r,y=new r,m=new r;s.prototype.applyForce=function(){var v=this.stiffness,_=this.damping,x=this.restLength,w=this.bodyA,C=this.bodyB,M=o,D=l,j=h,N=u,b=m,U=c,V=d,H=p,Y=f,Q=g,P=y;this.getWorldAnchorA(U),this.getWorldAnchorB(V),U.vsub(w.position,H),V.vsub(C.position,Y),V.vsub(U,M);var z=M.norm();D.copy(M),D.normalize(),C.velocity.vsub(w.velocity,j),C.angularVelocity.cross(Y,b),j.vadd(b,j),w.angularVelocity.cross(H,b),j.vsub(b,j),D.mult(-v*(z-x)-_*j.dot(D),N),w.force.vsub(N,w.force),C.force.vadd(N,C.force),H.cross(N,Q),Y.cross(N,P),w.torque.vsub(Q,w.torque),C.torque.vadd(P,C.torque)}},{"../math/Vec3":30}],36:[function(e,n,i){var r=e("../math/Vec3"),s=e("../math/Transform"),o=e("../collision/RaycastResult"),l=e("../utils/Utils");n.exports=h;function h(d){d=l.defaults(d,{chassisConnectionPointLocal:new r,chassisConnectionPointWorld:new r,directionLocal:new r,directionWorld:new r,axleLocal:new r,axleWorld:new r,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:1e4,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=d.maxSuspensionTravel,this.customSlidingRotationalSpeed=d.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=d.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=d.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=d.chassisConnectionPointWorld.clone(),this.directionLocal=d.directionLocal.clone(),this.directionWorld=d.directionWorld.clone(),this.axleLocal=d.axleLocal.clone(),this.axleWorld=d.axleWorld.clone(),this.suspensionRestLength=d.suspensionRestLength,this.suspensionMaxLength=d.suspensionMaxLength,this.radius=d.radius,this.suspensionStiffness=d.suspensionStiffness,this.dampingCompression=d.dampingCompression,this.dampingRelaxation=d.dampingRelaxation,this.frictionSlip=d.frictionSlip,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=d.rollInfluence,this.maxSuspensionForce=d.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=d.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new o,this.worldTransform=new s,this.isInContact=!1}var u=new r,c=new r,u=new r;h.prototype.updateWheel=function(d){var p=this.raycastResult;if(this.isInContact){var f=p.hitNormalWorld.dot(p.directionWorld);p.hitPointWorld.vsub(d.position,c),d.getVelocityAtWorldPoint(c,u);var g=p.hitNormalWorld.dot(u);if(f>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=1/.1;else{var y=-1/f;this.suspensionRelativeVelocity=g*y,this.clippedInvContactDotSuspension=y}}else p.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,p.directionWorld.scale(-1,p.hitNormalWorld),this.clippedInvContactDotSuspension=1}},{"../collision/RaycastResult":10,"../math/Transform":29,"../math/Vec3":30,"../utils/Utils":53}],37:[function(e,n,i){n.exports=l;var r=e("./Shape"),s=e("../math/Vec3"),o=e("./ConvexPolyhedron");function l(c){r.call(this),this.type=r.types.BOX,this.halfExtents=c,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}l.prototype=new r,l.prototype.constructor=l,l.prototype.updateConvexPolyhedronRepresentation=function(){var c=this.halfExtents.x,d=this.halfExtents.y,p=this.halfExtents.z,f=s,g=[new f(-c,-d,-p),new f(c,-d,-p),new f(c,d,-p),new f(-c,d,-p),new f(-c,-d,p),new f(c,-d,p),new f(c,d,p),new f(-c,d,p)],y=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]];new f(0,0,1),new f(0,1,0),new f(1,0,0);var m=new o(g,y);this.convexPolyhedronRepresentation=m,m.material=this.material},l.prototype.calculateLocalInertia=function(c,d){return d=d||new s,l.calculateInertia(this.halfExtents,c,d),d},l.calculateInertia=function(c,d,p){var f=c;p.x=1/12*d*(2*f.y*2*f.y+2*f.z*2*f.z),p.y=1/12*d*(2*f.x*2*f.x+2*f.z*2*f.z),p.z=1/12*d*(2*f.y*2*f.y+2*f.x*2*f.x)},l.prototype.getSideNormals=function(c,d){var p=c,f=this.halfExtents;if(p[0].set(f.x,0,0),p[1].set(0,f.y,0),p[2].set(0,0,f.z),p[3].set(-f.x,0,0),p[4].set(0,-f.y,0),p[5].set(0,0,-f.z),d!==void 0)for(var g=0;g!==p.length;g++)d.vmult(p[g],p[g]);return p},l.prototype.volume=function(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z},l.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=this.halfExtents.norm()};var h=new s;new s,l.prototype.forEachWorldCorner=function(c,d,p){for(var f=this.halfExtents,g=[[f.x,f.y,f.z],[-f.x,f.y,f.z],[-f.x,-f.y,f.z],[-f.x,-f.y,-f.z],[f.x,-f.y,-f.z],[f.x,f.y,-f.z],[-f.x,f.y,-f.z],[f.x,-f.y,f.z]],y=0;y<g.length;y++)h.set(g[y][0],g[y][1],g[y][2]),d.vmult(h,h),c.vadd(h,h),p(h.x,h.y,h.z)};var u=[new s,new s,new s,new s,new s,new s,new s,new s];l.prototype.calculateWorldAABB=function(c,d,p,f){var g=this.halfExtents;u[0].set(g.x,g.y,g.z),u[1].set(-g.x,g.y,g.z),u[2].set(-g.x,-g.y,g.z),u[3].set(-g.x,-g.y,-g.z),u[4].set(g.x,-g.y,-g.z),u[5].set(g.x,g.y,-g.z),u[6].set(-g.x,g.y,-g.z),u[7].set(g.x,-g.y,g.z);var y=u[0];d.vmult(y,y),c.vadd(y,y),f.copy(y),p.copy(y);for(var m=1;m<8;m++){var y=u[m];d.vmult(y,y),c.vadd(y,y);var v=y.x,_=y.y,x=y.z;v>f.x&&(f.x=v),_>f.y&&(f.y=_),x>f.z&&(f.z=x),v<p.x&&(p.x=v),_<p.y&&(p.y=_),x<p.z&&(p.z=x)}}},{"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],38:[function(e,n,i){n.exports=l;var r=e("./Shape"),s=e("../math/Vec3");e("../math/Quaternion");var o=e("../math/Transform");function l(T,Z,A){r.call(this),this.type=r.types.CONVEXPOLYHEDRON,this.vertices=T||[],this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.faces=Z||[],this.faceNormals=[],this.computeNormals(),this.worldFaceNormalsNeedsUpdate=!0,this.worldFaceNormals=[],this.uniqueEdges=[],this.uniqueAxes=A?A.slice():null,this.computeEdges(),this.updateBoundingSphereRadius()}l.prototype=new r,l.prototype.constructor=l;var h=new s;l.prototype.computeEdges=function(){var T=this.faces,Z=this.vertices;Z.length;var A=this.uniqueEdges;A.length=0;for(var I=h,R=0;R!==T.length;R++)for(var F=T[R],ot=F.length,et=0;et!==ot;et++){var k=(et+1)%ot;Z[F[et]].vsub(Z[F[k]],I),I.normalize();for(var nt=!1,lt=0;lt!==A.length;lt++)if(A[lt].almostEquals(I)||A[lt].almostEquals(I)){nt=!0;break}nt||A.push(I.clone())}},l.prototype.computeNormals=function(){this.faceNormals.length=this.faces.length;for(var T=0;T<this.faces.length;T++){for(var Z=0;Z<this.faces[T].length;Z++)if(!this.vertices[this.faces[T][Z]])throw new Error("Vertex "+this.faces[T][Z]+" not found!");var A=this.faceNormals[T]||new s;this.getFaceNormal(T,A),A.negate(A),this.faceNormals[T]=A;var I=this.vertices[this.faces[T][0]];if(A.dot(I)<0){console.error(".faceNormals["+T+"] = Vec3("+A.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");for(var Z=0;Z<this.faces[T].length;Z++)console.warn(".vertices["+this.faces[T][Z]+"] = Vec3("+this.vertices[this.faces[T][Z]].toString()+")")}}};var u=new s,c=new s;l.computeNormal=function(T,Z,A,I){Z.vsub(T,c),A.vsub(Z,u),u.cross(c,I),I.isZero()||I.normalize()},l.prototype.getFaceNormal=function(T,Z){var A=this.faces[T],I=this.vertices[A[0]],R=this.vertices[A[1]],F=this.vertices[A[2]];return l.computeNormal(I,R,F,Z)};var d=new s;l.prototype.clipAgainstHull=function(T,Z,A,I,R,F,ot,et,k){for(var nt=d,lt=-1,$=-Number.MAX_VALUE,rt=0;rt<A.faces.length;rt++){nt.copy(A.faceNormals[rt]),R.vmult(nt,nt);var st=nt.dot(F);st>$&&($=st,lt=rt)}for(var K=[],tt=A.faces[lt],Lt=tt.length,St=0;St<Lt;St++){var zt=A.vertices[tt[St]],Pt=new s;Pt.copy(zt),R.vmult(Pt,Pt),I.vadd(Pt,Pt),K.push(Pt)}lt>=0&&this.clipFaceAgainstHull(F,T,Z,K,ot,et,k)};var p=new s,f=new s,g=new s,y=new s,m=new s,v=new s;l.prototype.findSeparatingAxis=function(T,Z,A,I,R,F,ot,et){var k=p,nt=f,lt=g,$=y,rt=m,st=v,K=Number.MAX_VALUE,tt=this;if(tt.uniqueAxes)for(var St=0;St!==tt.uniqueAxes.length;St++){A.vmult(tt.uniqueAxes[St],k);var Pt=tt.testSepAxis(k,T,Z,A,I,R);if(Pt===!1)return!1;Pt<K&&(K=Pt,F.copy(k))}else for(var Lt=ot?ot.length:tt.faces.length,St=0;St<Lt;St++){var zt=ot?ot[St]:St;k.copy(tt.faceNormals[zt]),A.vmult(k,k);var Pt=tt.testSepAxis(k,T,Z,A,I,R);if(Pt===!1)return!1;Pt<K&&(K=Pt,F.copy(k))}if(T.uniqueAxes)for(var St=0;St!==T.uniqueAxes.length;St++){R.vmult(T.uniqueAxes[St],nt);var Pt=tt.testSepAxis(nt,T,Z,A,I,R);if(Pt===!1)return!1;Pt<K&&(K=Pt,F.copy(nt))}else for(var L=et?et.length:T.faces.length,St=0;St<L;St++){var zt=et?et[St]:St;nt.copy(T.faceNormals[zt]),R.vmult(nt,nt);var Pt=tt.testSepAxis(nt,T,Z,A,I,R);if(Pt===!1)return!1;Pt<K&&(K=Pt,F.copy(nt))}for(var E=0;E!==tt.uniqueEdges.length;E++){A.vmult(tt.uniqueEdges[E],$);for(var at=0;at!==T.uniqueEdges.length;at++)if(R.vmult(T.uniqueEdges[at],rt),$.cross(rt,st),!st.almostZero()){st.normalize();var ht=tt.testSepAxis(st,T,Z,A,I,R);if(ht===!1)return!1;ht<K&&(K=ht,F.copy(st))}}return I.vsub(Z,lt),lt.dot(F)>0&&F.negate(F),!0};var _=[],x=[];l.prototype.testSepAxis=function(T,Z,A,I,R,F){var ot=this;l.project(ot,T,A,I,_),l.project(Z,T,R,F,x);var et=_[0],k=_[1],nt=x[0],lt=x[1];if(et<lt||nt<k)return!1;var $=et-lt,rt=nt-k,st=$<rt?$:rt;return st};var w=new s,C=new s;l.prototype.calculateLocalInertia=function(T,Z){this.computeLocalAABB(w,C);var A=C.x-w.x,I=C.y-w.y,R=C.z-w.z;Z.x=1/12*T*(2*I*2*I+2*R*2*R),Z.y=1/12*T*(2*A*2*A+2*R*2*R),Z.z=1/12*T*(2*I*2*I+2*A*2*A)},l.prototype.getPlaneConstantOfFace=function(T){var Z=this.faces[T],A=this.faceNormals[T],I=this.vertices[Z[0]],R=-A.dot(I);return R};var M=new s,D=new s,j=new s,N=new s,b=new s,U=new s,V=new s,H=new s;l.prototype.clipFaceAgainstHull=function(T,Z,A,I,R,F,ot){for(var et=M,k=D,nt=j,lt=N,$=b,rt=U,st=V,K=H,tt=this,Lt=[],St=I,zt=Lt,Pt=-1,L=Number.MAX_VALUE,E=0;E<tt.faces.length;E++){et.copy(tt.faceNormals[E]),A.vmult(et,et);var at=et.dot(T);at<L&&(L=at,Pt=E)}if(!(Pt<0)){var ht=tt.faces[Pt];ht.connectedFaces=[];for(var bt=0;bt<tt.faces.length;bt++)for(var Ct=0;Ct<tt.faces[bt].length;Ct++)ht.indexOf(tt.faces[bt][Ct])!==-1&&bt!==Pt&&ht.connectedFaces.indexOf(bt)===-1&&ht.connectedFaces.push(bt);St.length;for(var J=ht.length,yt=0;yt<J;yt++){var gt=tt.vertices[ht[yt]],Rt=tt.vertices[ht[(yt+1)%J]];gt.vsub(Rt,k),nt.copy(k),A.vmult(nt,nt),Z.vadd(nt,nt),lt.copy(this.faceNormals[Pt]),A.vmult(lt,lt),Z.vadd(lt,lt),nt.cross(lt,$),$.negate($),rt.copy(gt),A.vmult(rt,rt),Z.vadd(rt,rt),-rt.dot($);var Dt;{var At=ht.connectedFaces[yt];st.copy(this.faceNormals[At]);var Ft=this.getPlaneConstantOfFace(At);K.copy(st),A.vmult(K,K);var Dt=Ft-K.dot(Z)}for(this.clipFaceAgainstPlane(St,zt,K,Dt);St.length;)St.shift();for(;zt.length;)St.push(zt.shift())}st.copy(this.faceNormals[Pt]);var Ft=this.getPlaneConstantOfFace(Pt);K.copy(st),A.vmult(K,K);for(var Dt=Ft-K.dot(Z),bt=0;bt<St.length;bt++){var Ut=K.dot(St[bt])+Dt;if(Ut<=R&&(console.log("clamped: depth="+Ut+" to minDist="+(R+"")),Ut=R),Ut<=F){var Jt=St[bt];if(Ut<=0){var Yt={point:Jt,normal:K,depth:Ut};ot.push(Yt)}}}}},l.prototype.clipFaceAgainstPlane=function(T,Z,A,I){var R,F,ot=T.length;if(ot<2)return Z;var et=T[T.length-1],k=T[0];R=A.dot(et)+I;for(var nt=0;nt<ot;nt++){if(k=T[nt],F=A.dot(k)+I,R<0)if(F<0){var lt=new s;lt.copy(k),Z.push(lt)}else{var lt=new s;et.lerp(k,R/(R-F),lt),Z.push(lt)}else if(F<0){var lt=new s;et.lerp(k,R/(R-F),lt),Z.push(lt),Z.push(k)}et=k,R=F}return Z},l.prototype.computeWorldVertices=function(T,Z){for(var A=this.vertices.length;this.worldVertices.length<A;)this.worldVertices.push(new s);for(var I=this.vertices,R=this.worldVertices,F=0;F!==A;F++)Z.vmult(I[F],R[F]),T.vadd(R[F],R[F]);this.worldVerticesNeedsUpdate=!1},new s,l.prototype.computeLocalAABB=function(T,Z){var A=this.vertices.length,I=this.vertices;T.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),Z.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(var R=0;R<A;R++){var F=I[R];F.x<T.x?T.x=F.x:F.x>Z.x&&(Z.x=F.x),F.y<T.y?T.y=F.y:F.y>Z.y&&(Z.y=F.y),F.z<T.z?T.z=F.z:F.z>Z.z&&(Z.z=F.z)}},l.prototype.computeWorldFaceNormals=function(T){for(var Z=this.faceNormals.length;this.worldFaceNormals.length<Z;)this.worldFaceNormals.push(new s);for(var A=this.faceNormals,I=this.worldFaceNormals,R=0;R!==Z;R++)T.vmult(A[R],I[R]);this.worldFaceNormalsNeedsUpdate=!1},l.prototype.updateBoundingSphereRadius=function(){for(var T=0,Z=this.vertices,A=0,I=Z.length;A!==I;A++){var R=Z[A].norm2();R>T&&(T=R)}this.boundingSphereRadius=Math.sqrt(T)};var Y=new s;l.prototype.calculateWorldAABB=function(T,Z,A,I){for(var R=this.vertices.length,F=this.vertices,ot,et,k,nt,lt,$,rt=0;rt<R;rt++){Y.copy(F[rt]),Z.vmult(Y,Y),T.vadd(Y,Y);var st=Y;st.x<ot||ot===void 0?ot=st.x:(st.x>nt||nt===void 0)&&(nt=st.x),st.y<et||et===void 0?et=st.y:(st.y>lt||lt===void 0)&&(lt=st.y),st.z<k||k===void 0?k=st.z:(st.z>$||$===void 0)&&($=st.z)}A.set(ot,et,k),I.set(nt,lt,$)},l.prototype.volume=function(){return 4*Math.PI*this.boundingSphereRadius/3},l.prototype.getAveragePointLocal=function(T){T=T||new s;for(var Z=this.vertices.length,A=this.vertices,I=0;I<Z;I++)T.vadd(A[I],T);return T.mult(1/Z,T),T},l.prototype.transformAllPoints=function(T,Z){var A=this.vertices.length,I=this.vertices;if(Z){for(var R=0;R<A;R++){var F=I[R];Z.vmult(F,F)}for(var R=0;R<this.faceNormals.length;R++){var F=this.faceNormals[R];Z.vmult(F,F)}}if(T)for(var R=0;R<A;R++){var F=I[R];F.vadd(T,F)}};var Q=new s,P=new s,z=new s;l.prototype.pointIsInside=function(T){var Z=this.vertices.length,A=this.vertices,I=this.faces,R=this.faceNormals,F=null,ot=this.faces.length,et=Q;this.getAveragePointLocal(et);for(var k=0;k<ot;k++){this.faces[k].length;var Z=R[k],nt=A[I[k][0]],lt=P;T.vsub(nt,lt);var $=Z.dot(lt),rt=z;et.vsub(nt,rt);var st=Z.dot(rt);if($<0&&st>0||$>0&&st<0)return!1}return F?1:-1},new s;var it=new s,W=new s;l.project=function(T,Z,A,I,R){var F=T.vertices.length,ot=it,et=0,k=0,nt=W,lt=T.vertices;nt.setZero(),o.vectorToLocalFrame(A,I,Z,ot),o.pointToLocalFrame(A,I,nt,nt);var $=nt.dot(ot);k=et=lt[0].dot(ot);for(var rt=1;rt<F;rt++){var st=lt[rt].dot(ot);st>et&&(et=st),st<k&&(k=st)}if(k-=$,et-=$,k>et){var K=k;k=et,et=K}R[0]=et,R[1]=k}},{"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"./Shape":43}],39:[function(e,n,i){n.exports=l;var r=e("./Shape"),s=e("../math/Vec3");e("../math/Quaternion");var o=e("./ConvexPolyhedron");function l(h,u,c,d){var p=d,f=[],g=[],y=[],m=[],v=[],_=Math.cos,x=Math.sin;f.push(new s(u*_(0),u*x(0),-c*.5)),m.push(0),f.push(new s(h*_(0),h*x(0),c*.5)),v.push(1);for(var w=0;w<p;w++){var C=2*Math.PI/p*(w+1),M=2*Math.PI/p*(w+.5);w<p-1?(f.push(new s(u*_(C),u*x(C),-c*.5)),m.push(2*w+2),f.push(new s(h*_(C),h*x(C),c*.5)),v.push(2*w+3),y.push([2*w+2,2*w+3,2*w+1,2*w])):y.push([0,1,2*w+1,2*w]),(p%2==1||w<p/2)&&g.push(new s(_(M),x(M),0))}y.push(v),g.push(new s(0,0,1));for(var D=[],w=0;w<m.length;w++)D.push(m[m.length-w-1]);y.push(D),this.type=r.types.CONVEXPOLYHEDRON,o.call(this,f,y,g)}l.prototype=new o},{"../math/Quaternion":28,"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],40:[function(e,n,i){var r=e("./Shape"),s=e("./ConvexPolyhedron"),o=e("../math/Vec3"),l=e("../utils/Utils");n.exports=h;function h(u,c){c=l.defaults(c,{maxValue:null,minValue:null,elementSize:1}),this.data=u,this.maxValue=c.maxValue,this.minValue=c.minValue,this.elementSize=c.elementSize,c.minValue===null&&this.updateMinValue(),c.maxValue===null&&this.updateMaxValue(),this.cacheEnabled=!0,r.call(this),this.pillarConvex=new s,this.pillarOffset=new o,this.type=r.types.HEIGHTFIELD,this.updateBoundingSphereRadius(),this._cachedPillars={}}h.prototype=new r,h.prototype.update=function(){this._cachedPillars={}},h.prototype.updateMinValue=function(){for(var u=this.data,c=u[0][0],d=0;d!==u.length;d++)for(var p=0;p!==u[d].length;p++){var f=u[d][p];f<c&&(c=f)}this.minValue=c},h.prototype.updateMaxValue=function(){for(var u=this.data,c=u[0][0],d=0;d!==u.length;d++)for(var p=0;p!==u[d].length;p++){var f=u[d][p];f>c&&(c=f)}this.maxValue=c},h.prototype.setHeightValueAtIndex=function(u,c,d){var p=this.data;p[u][c]=d,this.clearCachedConvexTrianglePillar(u,c,!1),u>0&&(this.clearCachedConvexTrianglePillar(u-1,c,!0),this.clearCachedConvexTrianglePillar(u-1,c,!1)),c>0&&(this.clearCachedConvexTrianglePillar(u,c-1,!0),this.clearCachedConvexTrianglePillar(u,c-1,!1)),c>0&&u>0&&this.clearCachedConvexTrianglePillar(u-1,c-1,!0)},h.prototype.getRectMinMax=function(u,c,d,p,f){f=f||[];for(var g=this.data,y=this.minValue,m=u;m<=d;m++)for(var v=c;v<=p;v++){var _=g[m][v];_>y&&(y=_)}f[0]=this.minValue,f[1]=y},h.prototype.getIndexOfPosition=function(u,c,d,p){var f=this.elementSize,g=this.data,y=Math.floor(u/f),m=Math.floor(c/f);return d[0]=y,d[1]=m,p&&(y<0&&(y=0),m<0&&(m=0),y>=g.length-1&&(y=g.length-1),m>=g[0].length-1&&(m=g[0].length-1)),!(y<0||m<0||y>=g.length-1||m>=g[0].length-1)},h.prototype.getHeightAt=function(u,c,d){var p=[];this.getIndexOfPosition(u,c,p,d);var f=[];return this.getRectMinMax(p[0],p[1]+1,p[0],p[1]+1,f),(f[0]+f[1])/2},h.prototype.getCacheConvexTrianglePillarKey=function(u,c,d){return u+"_"+c+"_"+(d?1:0)},h.prototype.getCachedConvexTrianglePillar=function(u,c,d){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(u,c,d)]},h.prototype.setCachedConvexTrianglePillar=function(u,c,d,p,f){this._cachedPillars[this.getCacheConvexTrianglePillarKey(u,c,d)]={convex:p,offset:f}},h.prototype.clearCachedConvexTrianglePillar=function(u,c,d){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(u,c,d)]},h.prototype.getConvexTrianglePillar=function(u,c,d){var p=this.pillarConvex,f=this.pillarOffset;if(this.cacheEnabled){var g=this.getCachedConvexTrianglePillar(u,c,d);if(g){this.pillarConvex=g.convex,this.pillarOffset=g.offset;return}p=new s,f=new o,this.pillarConvex=p,this.pillarOffset=f}var g=this.data,y=this.elementSize,m=p.faces;p.vertices.length=6;for(var v=0;v<6;v++)p.vertices[v]||(p.vertices[v]=new o);m.length=5;for(var v=0;v<5;v++)m[v]||(m[v]=[]);var _=p.vertices,x=(Math.min(g[u][c],g[u+1][c],g[u][c+1],g[u+1][c+1])-this.minValue)/2+this.minValue;d?(f.set((u+.75)*y,(c+.75)*y,x),_[0].set(.25*y,.25*y,g[u+1][c+1]-x),_[1].set(-.75*y,.25*y,g[u][c+1]-x),_[2].set(.25*y,-.75*y,g[u+1][c]-x),_[3].set(.25*y,.25*y,-x-1),_[4].set(-.75*y,.25*y,-x-1),_[5].set(.25*y,-.75*y,-x-1),m[0][0]=0,m[0][1]=1,m[0][2]=2,m[1][0]=5,m[1][1]=4,m[1][2]=3,m[2][0]=2,m[2][1]=5,m[2][2]=3,m[2][3]=0,m[3][0]=3,m[3][1]=4,m[3][2]=1,m[3][3]=0,m[4][0]=1,m[4][1]=4,m[4][2]=5,m[4][3]=2):(f.set((u+.25)*y,(c+.25)*y,x),_[0].set(-.25*y,-.25*y,g[u][c]-x),_[1].set(.75*y,-.25*y,g[u+1][c]-x),_[2].set(-.25*y,.75*y,g[u][c+1]-x),_[3].set(-.25*y,-.25*y,-x-1),_[4].set(.75*y,-.25*y,-x-1),_[5].set(-.25*y,.75*y,-x-1),m[0][0]=0,m[0][1]=1,m[0][2]=2,m[1][0]=5,m[1][1]=4,m[1][2]=3,m[2][0]=0,m[2][1]=2,m[2][2]=5,m[2][3]=3,m[3][0]=1,m[3][1]=0,m[3][2]=3,m[3][3]=4,m[4][0]=4,m[4][1]=5,m[4][2]=2,m[4][3]=1),p.computeNormals(),p.computeEdges(),p.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(u,c,d,p,f)},h.prototype.calculateLocalInertia=function(u,c){return c=c||new o,c.set(0,0,0),c},h.prototype.volume=function(){return Number.MAX_VALUE},h.prototype.calculateWorldAABB=function(u,c,d,p){d.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),p.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)},h.prototype.updateBoundingSphereRadius=function(){var u=this.data,c=this.elementSize;this.boundingSphereRadius=new o(u.length*c,u[0].length*c,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).norm()}},{"../math/Vec3":30,"../utils/Utils":53,"./ConvexPolyhedron":38,"./Shape":43}],41:[function(e,n,i){n.exports=o;var r=e("./Shape"),s=e("../math/Vec3");function o(){r.call(this),this.type=r.types.PARTICLE}o.prototype=new r,o.prototype.constructor=o,o.prototype.calculateLocalInertia=function(l,h){return h=h||new s,h.set(0,0,0),h},o.prototype.volume=function(){return 0},o.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=0},o.prototype.calculateWorldAABB=function(l,h,u,c){u.copy(l),c.copy(l)}},{"../math/Vec3":30,"./Shape":43}],42:[function(e,n,i){n.exports=o;var r=e("./Shape"),s=e("../math/Vec3");function o(){r.call(this),this.type=r.types.PLANE,this.worldNormal=new s,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}o.prototype=new r,o.prototype.constructor=o,o.prototype.computeWorldNormal=function(h){var u=this.worldNormal;u.set(0,0,1),h.vmult(u,u),this.worldNormalNeedsUpdate=!1},o.prototype.calculateLocalInertia=function(h,u){return u=u||new s,u},o.prototype.volume=function(){return Number.MAX_VALUE};var l=new s;o.prototype.calculateWorldAABB=function(h,u,c,d){l.set(0,0,1),u.vmult(l,l);var p=Number.MAX_VALUE;c.set(-p,-p,-p),d.set(p,p,p),l.x===1&&(d.x=h.x),l.y===1&&(d.y=h.y),l.z===1&&(d.z=h.z),l.x===-1&&(c.x=h.x),l.y===-1&&(c.y=h.y),l.z===-1&&(c.z=h.z)},o.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=Number.MAX_VALUE}},{"../math/Vec3":30,"./Shape":43}],43:[function(e,n,i){n.exports=r;var r=e("./Shape");e("../math/Vec3"),e("../math/Quaternion"),e("../material/Material");function r(){this.id=r.idCounter++,this.type=0,this.boundingSphereRadius=0,this.collisionResponse=!0,this.material=null}r.prototype.constructor=r,r.prototype.updateBoundingSphereRadius=function(){throw"computeBoundingSphereRadius() not implemented for shape type "+this.type},r.prototype.volume=function(){throw"volume() not implemented for shape type "+this.type},r.prototype.calculateLocalInertia=function(s,o){throw"calculateLocalInertia() not implemented for shape type "+this.type},r.idCounter=0,r.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256}},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"./Shape":43}],44:[function(e,n,i){n.exports=o;var r=e("./Shape"),s=e("../math/Vec3");function o(l){if(r.call(this),this.radius=l!==void 0?Number(l):1,this.type=r.types.SPHERE,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}o.prototype=new r,o.prototype.constructor=o,o.prototype.calculateLocalInertia=function(l,h){h=h||new s;var u=2*l*this.radius*this.radius/5;return h.x=u,h.y=u,h.z=u,h},o.prototype.volume=function(){return 4*Math.PI*this.radius/3},o.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=this.radius},o.prototype.calculateWorldAABB=function(l,h,u,c){for(var d=this.radius,p=["x","y","z"],f=0;f<p.length;f++){var g=p[f];u[g]=l[g]-d,c[g]=l[g]+d}}},{"../math/Vec3":30,"./Shape":43}],45:[function(e,n,i){n.exports=u;var r=e("./Shape"),s=e("../math/Vec3");e("../math/Quaternion");var o=e("../math/Transform"),l=e("../collision/AABB"),h=e("../utils/Octree");function u(D,j){r.call(this),this.type=r.types.TRIMESH,this.vertices=new Float32Array(D),this.indices=new Int16Array(j),this.normals=new Float32Array(j.length),this.aabb=new l,this.edges=null,this.scale=new s(1,1,1),this.tree=new h,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}u.prototype=new r,u.prototype.constructor=u;var c=new s;u.prototype.updateTree=function(){var D=this.tree;D.reset(),D.aabb.copy(this.aabb);var j=this.scale;D.aabb.lowerBound.x*=1/j.x,D.aabb.lowerBound.y*=1/j.y,D.aabb.lowerBound.z*=1/j.z,D.aabb.upperBound.x*=1/j.x,D.aabb.upperBound.y*=1/j.y,D.aabb.upperBound.z*=1/j.z;for(var N=new l,b=new s,U=new s,V=new s,H=[b,U,V],Y=0;Y<this.indices.length/3;Y++){var Q=Y*3;this._getUnscaledVertex(this.indices[Q],b),this._getUnscaledVertex(this.indices[Q+1],U),this._getUnscaledVertex(this.indices[Q+2],V),N.setFromPoints(H),D.insert(N,Y)}D.removeEmptyNodes()};var d=new l;u.prototype.getTrianglesInAABB=function(D,j){d.copy(D);var N=this.scale,b=N.x,U=N.y,V=N.z,H=d.lowerBound,Y=d.upperBound;return H.x/=b,H.y/=U,H.z/=V,Y.x/=b,Y.y/=U,Y.z/=V,this.tree.aabbQuery(d,j)},u.prototype.setScale=function(D){var j=this.scale.x===this.scale.y===this.scale.z,N=D.x===D.y===D.z;j&&N||this.updateNormals(),this.scale.copy(D),this.updateAABB(),this.updateBoundingSphereRadius()},u.prototype.updateNormals=function(){for(var D=c,j=this.normals,N=0;N<this.indices.length/3;N++){var b=N*3,U=this.indices[b],V=this.indices[b+1],H=this.indices[b+2];this.getVertex(U,m),this.getVertex(V,v),this.getVertex(H,_),u.computeNormal(v,m,_,D),j[b]=D.x,j[b+1]=D.y,j[b+2]=D.z}},u.prototype.updateEdges=function(){for(var D={},j=function(Q,P){var z=U<V?U+"_"+V:V+"_"+U;D[z]=!0},N=0;N<this.indices.length/3;N++){var b=N*3,U=this.indices[b],V=this.indices[b+1];this.indices[b+2],j(),j(),j()}var H=Object.keys(D);this.edges=new Int16Array(H.length*2);for(var N=0;N<H.length;N++){var Y=H[N].split("_");this.edges[2*N]=parseInt(Y[0],10),this.edges[2*N+1]=parseInt(Y[1],10)}},u.prototype.getEdgeVertex=function(D,j,N){var b=this.edges[D*2+(j?1:0)];this.getVertex(b,N)};var p=new s,f=new s;u.prototype.getEdgeVector=function(D,j){var N=p,b=f;this.getEdgeVertex(D,0,N),this.getEdgeVertex(D,1,b),b.vsub(N,j)};var g=new s,y=new s;u.computeNormal=function(D,j,N,b){j.vsub(D,y),N.vsub(j,g),g.cross(y,b),b.isZero()||b.normalize()};var m=new s,v=new s,_=new s;u.prototype.getVertex=function(D,j){var N=this.scale;return this._getUnscaledVertex(D,j),j.x*=N.x,j.y*=N.y,j.z*=N.z,j},u.prototype._getUnscaledVertex=function(D,j){var N=D*3,b=this.vertices;return j.set(b[N],b[N+1],b[N+2])},u.prototype.getWorldVertex=function(D,j,N,b){return this.getVertex(D,b),o.pointToWorldFrame(j,N,b,b),b},u.prototype.getTriangleVertices=function(D,j,N,b){var U=D*3;this.getVertex(this.indices[U],j),this.getVertex(this.indices[U+1],N),this.getVertex(this.indices[U+2],b)},u.prototype.getNormal=function(D,j){var N=D*3;return j.set(this.normals[N],this.normals[N+1],this.normals[N+2])};var x=new l;u.prototype.calculateLocalInertia=function(D,j){this.computeLocalAABB(x);var N=x.upperBound.x-x.lowerBound.x,b=x.upperBound.y-x.lowerBound.y,U=x.upperBound.z-x.lowerBound.z;return j.set(1/12*D*(2*b*2*b+2*U*2*U),1/12*D*(2*N*2*N+2*U*2*U),1/12*D*(2*b*2*b+2*N*2*N))};var w=new s;u.prototype.computeLocalAABB=function(D){var j=D.lowerBound,N=D.upperBound,b=this.vertices.length;this.vertices;var U=w;this.getVertex(0,U),j.copy(U),N.copy(U);for(var V=0;V!==b;V++)this.getVertex(V,U),U.x<j.x?j.x=U.x:U.x>N.x&&(N.x=U.x),U.y<j.y?j.y=U.y:U.y>N.y&&(N.y=U.y),U.z<j.z?j.z=U.z:U.z>N.z&&(N.z=U.z)},u.prototype.updateAABB=function(){this.computeLocalAABB(this.aabb)},u.prototype.updateBoundingSphereRadius=function(){for(var D=0,j=this.vertices,N=new s,b=0,U=j.length/3;b!==U;b++){this.getVertex(b,N);var V=N.norm2();V>D&&(D=V)}this.boundingSphereRadius=Math.sqrt(D)},new s;var C=new o,M=new l;u.prototype.calculateWorldAABB=function(D,j,N,b){var U=C,V=M;U.position=D,U.quaternion=j,this.aabb.toWorldFrame(U,V),N.copy(V.lowerBound),b.copy(V.upperBound)},u.prototype.volume=function(){return 4*Math.PI*this.boundingSphereRadius/3},u.createTorus=function(D,j,N,b,U){D=D||1,j=j||.5,N=N||8,b=b||6,U=U||Math.PI*2;for(var V=[],H=[],Y=0;Y<=N;Y++)for(var Q=0;Q<=b;Q++){var P=Q/b*U,z=Y/N*Math.PI*2,it=(D+j*Math.cos(z))*Math.cos(P),W=(D+j*Math.cos(z))*Math.sin(P),T=j*Math.sin(z);V.push(it,W,T)}for(var Y=1;Y<=N;Y++)for(var Q=1;Q<=b;Q++){var Z=(b+1)*Y+Q-1,A=(b+1)*(Y-1)+Q-1,I=(b+1)*(Y-1)+Q,R=(b+1)*Y+Q;H.push(Z,A,R),H.push(A,I,R)}return new u(V,H)}},{"../collision/AABB":3,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../utils/Octree":50,"./Shape":43}],46:[function(e,n,i){n.exports=s,e("../math/Vec3"),e("../math/Quaternion");var r=e("./Solver");function s(){r.call(this),this.iterations=10,this.tolerance=1e-7}s.prototype=new r;var o=[],l=[],h=[];s.prototype.solve=function(u,c){var d=0,p=this.iterations,f=this.tolerance*this.tolerance,g=this.equations,y=g.length,m=c.bodies,v=m.length,_=u,x,w,C,M,D,j;if(y!==0)for(var N=0;N!==v;N++)m[N].updateSolveMassProperties();var b=l,U=h,V=o;b.length=y,U.length=y,V.length=y;for(var N=0;N!==y;N++){var H=g[N];V[N]=0,U[N]=H.computeB(_),b[N]=1/H.computeC()}if(y!==0){for(var N=0;N!==v;N++){var Y=m[N],Q=Y.vlambda,P=Y.wlambda;Q.set(0,0,0),P&&P.set(0,0,0)}for(d=0;d!==p;d++){M=0;for(var z=0;z!==y;z++){var H=g[z];x=U[z],w=b[z],j=V[z],D=H.computeGWlambda(),C=w*(x-D-H.eps*j),j+C<H.minForce?C=H.minForce-j:j+C>H.maxForce&&(C=H.maxForce-j),V[z]+=C,M+=C>0?C:-C,H.addToWlambda(C)}if(M*M<f)break}for(var N=0;N!==v;N++){var Y=m[N],it=Y.velocity,W=Y.angularVelocity;it.vadd(Y.vlambda,it),W&&W.vadd(Y.wlambda,W)}}return d}},{"../math/Quaternion":28,"../math/Vec3":30,"./Solver":47}],47:[function(e,n,i){n.exports=r;function r(){this.equations=[]}r.prototype.solve=function(s,o){return 0},r.prototype.addEquation=function(s){s.enabled&&this.equations.push(s)},r.prototype.removeEquation=function(s){var o=this.equations,l=o.indexOf(s);l!==-1&&o.splice(l,1)},r.prototype.removeAllEquations=function(){this.equations.length=0}},{}],48:[function(e,n,i){n.exports=o,e("../math/Vec3"),e("../math/Quaternion");var r=e("./Solver"),s=e("../objects/Body");function o(m){for(r.call(this),this.iterations=10,this.tolerance=1e-7,this.subsolver=m,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}o.prototype=new r;var l=[],h=[],u={bodies:[]},c=s.STATIC;function d(m){for(var v=m.length,_=0;_!==v;_++){var x=m[_];if(!x.visited&&!(x.body.type&c))return x}return!1}var p=[];function f(m,v,_,x){for(p.push(m),m.visited=!0,v(m,_,x);p.length;)for(var w=p.pop(),C;C=d(w.children);)C.visited=!0,v(C,_,x),p.push(C)}function g(m,v,_){v.push(m.body);for(var x=m.eqs.length,w=0;w!==x;w++){var C=m.eqs[w];_.indexOf(C)===-1&&_.push(C)}}o.prototype.createNode=function(){return{body:null,children:[],eqs:[],visited:!1}},o.prototype.solve=function(m,v){for(var _=l,x=this.nodePool,w=v.bodies,C=this.equations,M=C.length,D=w.length,j=this.subsolver;x.length<D;)x.push(this.createNode());_.length=D;for(var N=0;N<D;N++)_[N]=x[N];for(var N=0;N!==D;N++){var b=_[N];b.body=w[N],b.children.length=0,b.eqs.length=0,b.visited=!1}for(var U=0;U!==M;U++){var V=C[U],N=w.indexOf(V.bi),H=w.indexOf(V.bj),Y=_[N],Q=_[H];Y.children.push(Q),Y.eqs.push(V),Q.children.push(Y),Q.eqs.push(V)}var P,z=0,it=h;j.tolerance=this.tolerance,j.iterations=this.iterations;for(var W=u;P=d(_);){it.length=0,W.bodies.length=0,f(P,g,W.bodies,it);var T=it.length;it=it.sort(y);for(var N=0;N!==T;N++)j.addEquation(it[N]);j.solve(m,W),j.removeAllEquations(),z++}return z};function y(m,v){return v.id-m.id}},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"./Solver":47}],49:[function(e,n,i){var r=function(){};n.exports=r,r.prototype={constructor:r,addEventListener:function(s,o){this._listeners===void 0&&(this._listeners={});var l=this._listeners;return l[s]===void 0&&(l[s]=[]),l[s].indexOf(o)===-1&&l[s].push(o),this},hasEventListener:function(s,o){if(this._listeners===void 0)return!1;var l=this._listeners;return l[s]!==void 0&&l[s].indexOf(o)!==-1},removeEventListener:function(s,o){if(this._listeners===void 0)return this;var l=this._listeners;if(l[s]===void 0)return this;var h=l[s].indexOf(o);return h!==-1&&l[s].splice(h,1),this},dispatchEvent:function(s){if(this._listeners===void 0)return this;var o=this._listeners,l=o[s.type];if(l!==void 0){s.target=this;for(var h=0,u=l.length;h<u;h++)l[h].call(this,s)}return this}}},{}],50:[function(e,n,i){var r=e("../collision/AABB"),s=e("../math/Vec3");n.exports=l;function o(c){c=c||{},this.root=c.root||null,this.aabb=c.aabb?c.aabb.clone():new r,this.data=[],this.children=[]}function l(c,d){d=d||{},d.root=null,d.aabb=c,o.call(this,d),this.maxDepth=typeof d.maxDepth!="undefined"?d.maxDepth:8}l.prototype=new o,o.prototype.reset=function(c,d){this.children.length=this.data.length=0},o.prototype.insert=function(c,d,p){var f=this.data;if(p=p||0,!this.aabb.contains(c))return!1;var g=this.children;if(p<(this.maxDepth||this.root.maxDepth)){var y=!1;g.length||(this.subdivide(),y=!0);for(var m=0;m!==8;m++)if(g[m].insert(c,d,p+1))return!0;y&&(g.length=0)}return f.push(d),!0};var h=new s;o.prototype.subdivide=function(){var c=this.aabb,d=c.lowerBound,p=c.upperBound,f=this.children;f.push(new o({aabb:new r({lowerBound:new s(0,0,0)})}),new o({aabb:new r({lowerBound:new s(1,0,0)})}),new o({aabb:new r({lowerBound:new s(1,1,0)})}),new o({aabb:new r({lowerBound:new s(1,1,1)})}),new o({aabb:new r({lowerBound:new s(0,1,1)})}),new o({aabb:new r({lowerBound:new s(0,0,1)})}),new o({aabb:new r({lowerBound:new s(1,0,1)})}),new o({aabb:new r({lowerBound:new s(0,1,0)})})),p.vsub(d,h),h.scale(.5,h);for(var g=this.root||this,y=0;y!==8;y++){var m=f[y];m.root=g;var v=m.aabb.lowerBound;v.x*=h.x,v.y*=h.y,v.z*=h.z,v.vadd(d,v),v.vadd(h,m.aabb.upperBound)}},o.prototype.aabbQuery=function(c,d){this.data,this.children;for(var p=[this];p.length;){var f=p.pop();f.aabb.overlaps(c)&&Array.prototype.push.apply(d,f.data),Array.prototype.push.apply(p,f.children)}return d};var u=new r;o.prototype.rayQuery=function(c,d,p){return c.getAABB(u),u.toLocalFrame(d,u),this.aabbQuery(u,p),p},o.prototype.removeEmptyNodes=function(){for(var c=[this];c.length;){for(var d=c.pop(),p=d.children.length-1;p>=0;p--)d.children[p].data.length||d.children.splice(p,1);Array.prototype.push.apply(c,d.children)}}},{"../collision/AABB":3,"../math/Vec3":30}],51:[function(e,n,i){n.exports=r;function r(){this.objects=[],this.type=Object}r.prototype.release=function(){for(var s=arguments.length,o=0;o!==s;o++)this.objects.push(arguments[o])},r.prototype.get=function(){return this.objects.length===0?this.constructObject():this.objects.pop()},r.prototype.constructObject=function(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}},{}],52:[function(e,n,i){n.exports=r;function r(){this.data={keys:[]}}r.prototype.get=function(s,o){if(s>o){var l=o;o=s,s=l}return this.data[s+"-"+o]},r.prototype.set=function(s,o,l){if(s>o){var h=o;o=s,s=h}var u=s+"-"+o;this.get(s,o)||this.data.keys.push(u),this.data[u]=l},r.prototype.reset=function(){for(var s=this.data,o=s.keys;o.length>0;){var l=o.pop();delete s[l]}}},{}],53:[function(e,n,i){function r(){}n.exports=r,r.defaults=function(s,o){s=s||{};for(var l in o)l in s||(s[l]=o[l]);return s}},{}],54:[function(e,n,i){n.exports=o;var r=e("../math/Vec3"),s=e("./Pool");function o(){s.call(this),this.type=r}o.prototype=new s,o.prototype.constructObject=function(){return new r}},{"../math/Vec3":30,"./Pool":51}],55:[function(e,n,i){n.exports=f;var r=e("../collision/AABB"),s=e("../shapes/Shape"),o=e("../collision/Ray"),l=e("../math/Vec3"),h=e("../math/Transform");e("../shapes/ConvexPolyhedron");var u=e("../math/Quaternion");e("../solver/Solver");var c=e("../utils/Vec3Pool"),d=e("../equations/ContactEquation"),p=e("../equations/FrictionEquation");function f(ct){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new c,this.world=ct,this.currentContactMaterial=null,this.enableFrictionReduction=!1}f.prototype.createContactEquation=function(ct,mt,_t,Mt,S,O){var q;this.contactPointPool.length?(q=this.contactPointPool.pop(),q.bi=ct,q.bj=mt):q=new d(ct,mt),q.enabled=ct.collisionResponse&&mt.collisionResponse&&_t.collisionResponse&&Mt.collisionResponse;var X=this.currentContactMaterial;q.restitution=X.restitution,q.setSpookParams(X.contactEquationStiffness,X.contactEquationRelaxation,this.world.dt);var B=_t.material||ct.material,ut=Mt.material||mt.material;return B&&ut&&B.restitution>=0&&ut.restitution>=0&&(q.restitution=B.restitution*ut.restitution),q.si=S||_t,q.sj=O||Mt,q},f.prototype.createFrictionEquationsFromContact=function(ct,mt){var _t=ct.bi,Mt=ct.bj,S=ct.si,O=ct.sj,q=this.world,X=this.currentContactMaterial,B=X.friction,ut=S.material||_t.material,dt=O.material||Mt.material;if(ut&&dt&&ut.friction>=0&&dt.friction>=0&&(B=ut.friction*dt.friction),B>0){var xt=B*q.gravity.length(),pt=_t.invMass+Mt.invMass;pt>0&&(pt=1/pt);var ft=this.frictionEquationPool,vt=ft.length?ft.pop():new p(_t,Mt,xt*pt),Et=ft.length?ft.pop():new p(_t,Mt,xt*pt);return vt.bi=Et.bi=_t,vt.bj=Et.bj=Mt,vt.minForce=Et.minForce=-xt*pt,vt.maxForce=Et.maxForce=xt*pt,vt.ri.copy(ct.ri),vt.rj.copy(ct.rj),Et.ri.copy(ct.ri),Et.rj.copy(ct.rj),ct.ni.tangents(vt.t,Et.t),vt.setSpookParams(X.frictionEquationStiffness,X.frictionEquationRelaxation,q.dt),Et.setSpookParams(X.frictionEquationStiffness,X.frictionEquationRelaxation,q.dt),vt.enabled=Et.enabled=ct.enabled,mt.push(vt,Et),!0}return!1};var g=new l,y=new l,m=new l;f.prototype.createFrictionFromAverage=function(ct){var mt=this.result[this.result.length-1];if(!(!this.createFrictionEquationsFromContact(mt,this.frictionResult)||ct===1)){var _t=this.frictionResult[this.frictionResult.length-2],Mt=this.frictionResult[this.frictionResult.length-1];g.setZero(),y.setZero(),m.setZero();var S=mt.bi;mt.bj;for(var O=0;O!==ct;O++)mt=this.result[this.result.length-1-O],mt.bodyA!==S?(g.vadd(mt.ni,g),y.vadd(mt.ri,y),m.vadd(mt.rj,m)):(g.vsub(mt.ni,g),y.vadd(mt.rj,y),m.vadd(mt.ri,m));var q=1/ct;y.scale(q,_t.ri),m.scale(q,_t.rj),Mt.ri.copy(_t.ri),Mt.rj.copy(_t.rj),g.normalize(),g.tangents(_t.t,Mt.t)}};var v=new l,_=new l,x=new u,w=new u;f.prototype.getContacts=function(ct,mt,_t,Mt,S,O,q){this.contactPointPool=S,this.frictionEquationPool=q,this.result=Mt,this.frictionResult=O;for(var X=x,B=w,ut=v,dt=_,xt=0,pt=ct.length;xt!==pt;xt++){var ft=ct[xt],vt=mt[xt],Et=null;ft.material&&vt.material&&(Et=_t.getContactMaterial(ft.material,vt.material)||null);for(var Nt=0;Nt<ft.shapes.length;Nt++){ft.quaternion.mult(ft.shapeOrientations[Nt],X),ft.quaternion.vmult(ft.shapeOffsets[Nt],ut),ut.vadd(ft.position,ut);for(var wt=ft.shapes[Nt],Bt=0;Bt<vt.shapes.length;Bt++){vt.quaternion.mult(vt.shapeOrientations[Bt],B),vt.quaternion.vmult(vt.shapeOffsets[Bt],dt),dt.vadd(vt.position,dt);var kt=vt.shapes[Bt];if(!(ut.distanceTo(dt)>wt.boundingSphereRadius+kt.boundingSphereRadius)){var Gt=null;wt.material&&kt.material&&(Gt=_t.getContactMaterial(wt.material,kt.material)||null),this.currentContactMaterial=Gt||Et||_t.defaultContactMaterial;var Ht=this[wt.type|kt.type];Ht&&(wt.type<kt.type?Ht.call(this,wt,kt,ut,dt,X,B,ft,vt,wt,kt):Ht.call(this,kt,wt,dt,ut,B,X,vt,ft,wt,kt))}}}}},f.prototype[s.types.BOX|s.types.BOX]=f.prototype.boxBox=function(ct,mt,_t,Mt,S,O,q,X){ct.convexPolyhedronRepresentation.material=ct.material,mt.convexPolyhedronRepresentation.material=mt.material,ct.convexPolyhedronRepresentation.collisionResponse=ct.collisionResponse,mt.convexPolyhedronRepresentation.collisionResponse=mt.collisionResponse,this.convexConvex(ct.convexPolyhedronRepresentation,mt.convexPolyhedronRepresentation,_t,Mt,S,O,q,X,ct,mt)},f.prototype[s.types.BOX|s.types.CONVEXPOLYHEDRON]=f.prototype.boxConvex=function(ct,mt,_t,Mt,S,O,q,X){ct.convexPolyhedronRepresentation.material=ct.material,ct.convexPolyhedronRepresentation.collisionResponse=ct.collisionResponse,this.convexConvex(ct.convexPolyhedronRepresentation,mt,_t,Mt,S,O,q,X,ct,mt)},f.prototype[s.types.BOX|s.types.PARTICLE]=f.prototype.boxParticle=function(ct,mt,_t,Mt,S,O,q,X){ct.convexPolyhedronRepresentation.material=ct.material,ct.convexPolyhedronRepresentation.collisionResponse=ct.collisionResponse,this.convexParticle(ct.convexPolyhedronRepresentation,mt,_t,Mt,S,O,q,X,ct,mt)},f.prototype[s.types.SPHERE]=f.prototype.sphereSphere=function(ct,mt,_t,Mt,S,O,q,X){var B=this.createContactEquation(q,X,ct,mt);Mt.vsub(_t,B.ni),B.ni.normalize(),B.ri.copy(B.ni),B.rj.copy(B.ni),B.ri.mult(ct.radius,B.ri),B.rj.mult(-mt.radius,B.rj),B.ri.vadd(_t,B.ri),B.ri.vsub(q.position,B.ri),B.rj.vadd(Mt,B.rj),B.rj.vsub(X.position,B.rj),this.result.push(B),this.createFrictionEquationsFromContact(B,this.frictionResult)};var C=new l,M=new l,D=new l;f.prototype[s.types.PLANE|s.types.TRIMESH]=f.prototype.planeTrimesh=function(ct,mt,_t,Mt,S,O,q,X){var B=new l,ut=C;ut.set(0,0,1),S.vmult(ut,ut);for(var dt=0;dt<mt.vertices.length/3;dt++){mt.getVertex(dt,B);var xt=new l;xt.copy(B),h.pointToWorldFrame(Mt,O,xt,B);var pt=M;B.vsub(_t,pt);var ft=ut.dot(pt);if(ft<=0){var vt=this.createContactEquation(q,X,ct,mt);vt.ni.copy(ut);var Et=D;ut.scale(pt.dot(ut),Et),B.vsub(Et,Et),vt.ri.copy(Et),vt.ri.vsub(q.position,vt.ri),vt.rj.copy(B),vt.rj.vsub(X.position,vt.rj),this.result.push(vt),this.createFrictionEquationsFromContact(vt,this.frictionResult)}}};var j=new l,N=new l;new l;var b=new l,U=new l,V=new l,H=new l,Y=new l,Q=new l,P=new l,z=new l,it=new l,W=new l,T=new l,Z=new r,A=[];f.prototype[s.types.SPHERE|s.types.TRIMESH]=f.prototype.sphereTrimesh=function(ct,mt,_t,Mt,S,O,q,X){var B=V,ut=H,dt=Y,xt=Q,pt=P,ft=z,vt=Z,Et=U,Nt=N,wt=A;h.pointToLocalFrame(Mt,O,_t,pt);var Bt=ct.radius;vt.lowerBound.set(pt.x-Bt,pt.y-Bt,pt.z-Bt),vt.upperBound.set(pt.x+Bt,pt.y+Bt,pt.z+Bt),mt.getTrianglesInAABB(vt,wt);for(var kt=b,Gt=ct.radius*ct.radius,Ht=0;Ht<wt.length;Ht++)for(var Xt=0;Xt<3;Xt++)if(mt.getVertex(mt.indices[wt[Ht]*3+Xt],kt),kt.vsub(pt,Nt),Nt.norm2()<=Gt){Et.copy(kt),h.pointToWorldFrame(Mt,O,Et,kt),kt.vsub(_t,Nt);var Vt=this.createContactEquation(q,X,ct,mt);Vt.ni.copy(Nt),Vt.ni.normalize(),Vt.ri.copy(Vt.ni),Vt.ri.scale(ct.radius,Vt.ri),Vt.ri.vadd(_t,Vt.ri),Vt.ri.vsub(q.position,Vt.ri),Vt.rj.copy(kt),Vt.rj.vsub(X.position,Vt.rj),this.result.push(Vt),this.createFrictionEquationsFromContact(Vt,this.frictionResult)}for(var Ht=0;Ht<wt.length;Ht++)for(var Xt=0;Xt<3;Xt++){mt.getVertex(mt.indices[wt[Ht]*3+Xt],B),mt.getVertex(mt.indices[wt[Ht]*3+(Xt+1)%3],ut),ut.vsub(B,dt),pt.vsub(ut,ft);var de=ft.dot(dt);pt.vsub(B,ft);var jt=ft.dot(dt);if(jt>0&&de<0){pt.vsub(B,ft),xt.copy(dt),xt.normalize(),jt=ft.dot(xt),xt.scale(jt,ft),ft.vadd(B,ft);var me=ft.distanceTo(pt);if(me<ct.radius){var Vt=this.createContactEquation(q,X,ct,mt);ft.vsub(pt,Vt.ni),Vt.ni.normalize(),Vt.ni.scale(ct.radius,Vt.ri),h.pointToWorldFrame(Mt,O,ft,ft),ft.vsub(X.position,Vt.rj),h.vectorToWorldFrame(O,Vt.ni,Vt.ni),h.vectorToWorldFrame(O,Vt.ri,Vt.ri),this.result.push(Vt),this.createFrictionEquationsFromContact(Vt,this.frictionResult)}}}for(var pe=it,De=W,te=T,dn=j,Ht=0,ie=wt.length;Ht!==ie;Ht++){mt.getTriangleVertices(wt[Ht],pe,De,te),mt.getNormal(wt[Ht],dn),pt.vsub(pe,ft);var me=ft.dot(dn);if(dn.scale(me,ft),pt.vsub(ft,ft),me=ft.distanceTo(pt),o.pointInTriangle(ft,pe,De,te)&&me<ct.radius){var Vt=this.createContactEquation(q,X,ct,mt);ft.vsub(pt,Vt.ni),Vt.ni.normalize(),Vt.ni.scale(ct.radius,Vt.ri),h.pointToWorldFrame(Mt,O,ft,ft),ft.vsub(X.position,Vt.rj),h.vectorToWorldFrame(O,Vt.ni,Vt.ni),h.vectorToWorldFrame(O,Vt.ri,Vt.ri),this.result.push(Vt),this.createFrictionEquationsFromContact(Vt,this.frictionResult)}}wt.length=0};var I=new l,R=new l;f.prototype[s.types.SPHERE|s.types.PLANE]=f.prototype.spherePlane=function(ct,mt,_t,Mt,S,O,q,X){var B=this.createContactEquation(q,X,ct,mt);if(B.ni.set(0,0,1),O.vmult(B.ni,B.ni),B.ni.negate(B.ni),B.ni.normalize(),B.ni.mult(ct.radius,B.ri),_t.vsub(Mt,I),B.ni.mult(B.ni.dot(I),R),I.vsub(R,B.rj),-I.dot(B.ni)<=ct.radius){var ut=B.ri,dt=B.rj;ut.vadd(_t,ut),ut.vsub(q.position,ut),dt.vadd(Mt,dt),dt.vsub(X.position,dt),this.result.push(B),this.createFrictionEquationsFromContact(B,this.frictionResult)}};var F=new l,ot=new l,et=new l;function k(ct,mt,_t){for(var Mt=null,S=ct.length,O=0;O!==S;O++){var q=ct[O],X=F;ct[(O+1)%S].vsub(q,X);var B=ot;X.cross(mt,B);var ut=et;_t.vsub(q,ut);var dt=B.dot(ut);if(Mt===null||dt>0&&Mt===!0||dt<=0&&Mt===!1){Mt===null&&(Mt=dt>0);continue}else return!1}return!0}var nt=new l,lt=new l,$=new l,rt=new l,st=[new l,new l,new l,new l,new l,new l],K=new l,tt=new l,Lt=new l,St=new l;f.prototype[s.types.SPHERE|s.types.BOX]=f.prototype.sphereBox=function(ct,mt,_t,Mt,S,O,q,X){var B=this.v3pool,ut=st;_t.vsub(Mt,nt),mt.getSideNormals(ut,O);for(var dt=ct.radius,xt=!1,pt=tt,ft=Lt,vt=St,Et=null,Nt=0,wt=0,Bt=0,kt=null,Gt=0,Ht=ut.length;Gt!==Ht&&xt===!1;Gt++){var Xt=lt;Xt.copy(ut[Gt]);var Vt=Xt.norm();Xt.normalize();var de=nt.dot(Xt);if(de<Vt+dt&&de>0){var jt=$,me=rt;jt.copy(ut[(Gt+1)%3]),me.copy(ut[(Gt+2)%3]);var pe=jt.norm(),De=me.norm();jt.normalize(),me.normalize();var te=nt.dot(jt),dn=nt.dot(me);if(te<pe&&te>-pe&&dn<De&&dn>-De){var xe=Math.abs(de-Vt-dt);(kt===null||xe<kt)&&(kt=xe,wt=te,Bt=dn,Et=Vt,pt.copy(Xt),ft.copy(jt),vt.copy(me),Nt++)}}}if(Nt){xt=!0;var qt=this.createContactEquation(q,X,ct,mt);pt.mult(-dt,qt.ri),qt.ni.copy(pt),qt.ni.negate(qt.ni),pt.mult(Et,pt),ft.mult(wt,ft),pt.vadd(ft,pt),vt.mult(Bt,vt),pt.vadd(vt,qt.rj),qt.ri.vadd(_t,qt.ri),qt.ri.vsub(q.position,qt.ri),qt.rj.vadd(Mt,qt.rj),qt.rj.vsub(X.position,qt.rj),this.result.push(qt),this.createFrictionEquationsFromContact(qt,this.frictionResult)}for(var ie=B.get(),pn=K,Ne=0;Ne!==2&&!xt;Ne++)for(var Ae=0;Ae!==2&&!xt;Ae++)for(var be=0;be!==2&&!xt;be++)if(ie.set(0,0,0),Ne?ie.vadd(ut[0],ie):ie.vsub(ut[0],ie),Ae?ie.vadd(ut[1],ie):ie.vsub(ut[1],ie),be?ie.vadd(ut[2],ie):ie.vsub(ut[2],ie),Mt.vadd(ie,pn),pn.vsub(_t,pn),pn.norm2()<dt*dt){xt=!0;var qt=this.createContactEquation(q,X,ct,mt);qt.ri.copy(pn),qt.ri.normalize(),qt.ni.copy(qt.ri),qt.ri.mult(dt,qt.ri),qt.rj.copy(ie),qt.ri.vadd(_t,qt.ri),qt.ri.vsub(q.position,qt.ri),qt.rj.vadd(Mt,qt.rj),qt.rj.vsub(X.position,qt.rj),this.result.push(qt),this.createFrictionEquationsFromContact(qt,this.frictionResult)}B.release(ie),ie=null;for(var Ye=B.get(),fn=B.get(),qt=B.get(),Ge=B.get(),xe=B.get(),Un=ut.length,Ne=0;Ne!==Un&&!xt;Ne++)for(var Ae=0;Ae!==Un&&!xt;Ae++)if(Ne%3!=Ae%3){ut[Ae].cross(ut[Ne],Ye),Ye.normalize(),ut[Ne].vadd(ut[Ae],fn),qt.copy(_t),qt.vsub(fn,qt),qt.vsub(Mt,qt);var Wn=qt.dot(Ye);Ye.mult(Wn,Ge);for(var be=0;be===Ne%3||be===Ae%3;)be++;xe.copy(_t),xe.vsub(Ge,xe),xe.vsub(fn,xe),xe.vsub(Mt,xe);var rc=Math.abs(Wn),sc=xe.norm();if(rc<ut[be].norm()&&sc<dt){xt=!0;var re=this.createContactEquation(q,X,ct,mt);fn.vadd(Ge,re.rj),re.rj.copy(re.rj),xe.negate(re.ni),re.ni.normalize(),re.ri.copy(re.rj),re.ri.vadd(Mt,re.ri),re.ri.vsub(_t,re.ri),re.ri.normalize(),re.ri.mult(dt,re.ri),re.ri.vadd(_t,re.ri),re.ri.vsub(q.position,re.ri),re.rj.vadd(Mt,re.rj),re.rj.vsub(X.position,re.rj),this.result.push(re),this.createFrictionEquationsFromContact(re,this.frictionResult)}}B.release(Ye,fn,qt,Ge,xe)};var zt=new l,Pt=new l,L=new l,E=new l,at=new l,ht=new l,bt=new l,Ct=new l,J=new l,yt=new l;f.prototype[s.types.SPHERE|s.types.CONVEXPOLYHEDRON]=f.prototype.sphereConvex=function(ct,mt,_t,Mt,S,O,q,X){var B=this.v3pool;_t.vsub(Mt,zt);for(var ut=mt.faceNormals,dt=mt.faces,xt=mt.vertices,pt=ct.radius,ft=0;ft!==xt.length;ft++){var vt=xt[ft],Et=at;O.vmult(vt,Et),Mt.vadd(Et,Et);var Nt=E;if(Et.vsub(_t,Nt),Nt.norm2()<pt*pt){Bt=!0;var wt=this.createContactEquation(q,X,ct,mt);wt.ri.copy(Nt),wt.ri.normalize(),wt.ni.copy(wt.ri),wt.ri.mult(pt,wt.ri),Et.vsub(Mt,wt.rj),wt.ri.vadd(_t,wt.ri),wt.ri.vsub(q.position,wt.ri),wt.rj.vadd(Mt,wt.rj),wt.rj.vsub(X.position,wt.rj),this.result.push(wt),this.createFrictionEquationsFromContact(wt,this.frictionResult);return}}for(var Bt=!1,ft=0,kt=dt.length;ft!==kt&&Bt===!1;ft++){var Gt=ut[ft],Ht=dt[ft],Xt=ht;O.vmult(Gt,Xt);var Vt=bt;O.vmult(xt[Ht[0]],Vt),Vt.vadd(Mt,Vt);var de=Ct;Xt.mult(-pt,de),_t.vadd(de,de);var jt=J;de.vsub(Vt,jt);var me=jt.dot(Xt),pe=yt;if(_t.vsub(Vt,pe),me<0&&pe.dot(Xt)>0){for(var De=[],te=0,dn=Ht.length;te!==dn;te++){var ie=B.get();O.vmult(xt[Ht[te]],ie),Mt.vadd(ie,ie),De.push(ie)}if(k(De,Xt,_t)){Bt=!0;var wt=this.createContactEquation(q,X,ct,mt);Xt.mult(-pt,wt.ri),Xt.negate(wt.ni);var pn=B.get();Xt.mult(-me,pn);var Ne=B.get();Xt.mult(-pt,Ne),_t.vsub(Mt,wt.rj),wt.rj.vadd(Ne,wt.rj),wt.rj.vadd(pn,wt.rj),wt.rj.vadd(Mt,wt.rj),wt.rj.vsub(X.position,wt.rj),wt.ri.vadd(_t,wt.ri),wt.ri.vsub(q.position,wt.ri),B.release(pn),B.release(Ne),this.result.push(wt),this.createFrictionEquationsFromContact(wt,this.frictionResult);for(var te=0,Ae=De.length;te!==Ae;te++)B.release(De[te]);return}else for(var te=0;te!==Ht.length;te++){var be=B.get(),Ye=B.get();O.vmult(xt[Ht[(te+1)%Ht.length]],be),O.vmult(xt[Ht[(te+2)%Ht.length]],Ye),Mt.vadd(be,be),Mt.vadd(Ye,Ye);var fn=Pt;Ye.vsub(be,fn);var qt=L;fn.unit(qt);var Ge=B.get(),xe=B.get();_t.vsub(be,xe);var Un=xe.dot(qt);qt.mult(Un,Ge),Ge.vadd(be,Ge);var Wn=B.get();if(Ge.vsub(_t,Wn),Un>0&&Un*Un<fn.norm2()&&Wn.norm2()<pt*pt){var wt=this.createContactEquation(q,X,ct,mt);Ge.vsub(Mt,wt.rj),Ge.vsub(_t,wt.ni),wt.ni.normalize(),wt.ni.mult(pt,wt.ri),wt.rj.vadd(Mt,wt.rj),wt.rj.vsub(X.position,wt.rj),wt.ri.vadd(_t,wt.ri),wt.ri.vsub(q.position,wt.ri),this.result.push(wt),this.createFrictionEquationsFromContact(wt,this.frictionResult);for(var te=0,Ae=De.length;te!==Ae;te++)B.release(De[te]);B.release(be),B.release(Ye),B.release(Ge),B.release(Wn),B.release(xe);return}B.release(be),B.release(Ye),B.release(Ge),B.release(Wn),B.release(xe)}for(var te=0,Ae=De.length;te!==Ae;te++)B.release(De[te])}}},new l,new l,f.prototype[s.types.PLANE|s.types.BOX]=f.prototype.planeBox=function(ct,mt,_t,Mt,S,O,q,X){mt.convexPolyhedronRepresentation.material=mt.material,mt.convexPolyhedronRepresentation.collisionResponse=mt.collisionResponse,this.planeConvex(ct,mt.convexPolyhedronRepresentation,_t,Mt,S,O,q,X)};var gt=new l,Rt=new l,At=new l,Ft=new l;f.prototype[s.types.PLANE|s.types.CONVEXPOLYHEDRON]=f.prototype.planeConvex=function(ct,mt,_t,Mt,S,O,q,X){var B=gt,ut=Rt;ut.set(0,0,1),S.vmult(ut,ut);for(var dt=0,xt=At,pt=0;pt!==mt.vertices.length;pt++){B.copy(mt.vertices[pt]),O.vmult(B,B),Mt.vadd(B,B),B.vsub(_t,xt);var ft=ut.dot(xt);if(ft<=0){var vt=this.createContactEquation(q,X,ct,mt),Et=Ft;ut.mult(ut.dot(xt),Et),B.vsub(Et,Et),Et.vsub(_t,vt.ri),vt.ni.copy(ut),B.vsub(Mt,vt.rj),vt.ri.vadd(_t,vt.ri),vt.ri.vsub(q.position,vt.ri),vt.rj.vadd(Mt,vt.rj),vt.rj.vsub(X.position,vt.rj),this.result.push(vt),dt++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(vt,this.frictionResult)}}this.enableFrictionReduction&&dt&&this.createFrictionFromAverage(dt)};var Dt=new l,Ut=new l;f.prototype[s.types.CONVEXPOLYHEDRON]=f.prototype.convexConvex=function(ct,mt,_t,Mt,S,O,q,X,B,ut,dt,xt){var pt=Dt;if(!(_t.distanceTo(Mt)>ct.boundingSphereRadius+mt.boundingSphereRadius)&&ct.findSeparatingAxis(mt,_t,S,Mt,O,pt,dt,xt)){var ft=[],vt=Ut;ct.clipAgainstHull(_t,S,mt,Mt,O,pt,-100,100,ft);for(var Et=0,Nt=0;Nt!==ft.length;Nt++){var wt=this.createContactEquation(q,X,ct,mt,B,ut),Bt=wt.ri,kt=wt.rj;pt.negate(wt.ni),ft[Nt].normal.negate(vt),vt.mult(ft[Nt].depth,vt),ft[Nt].point.vadd(vt,Bt),kt.copy(ft[Nt].point),Bt.vsub(_t,Bt),kt.vsub(Mt,kt),Bt.vadd(_t,Bt),Bt.vsub(q.position,Bt),kt.vadd(Mt,kt),kt.vsub(X.position,kt),this.result.push(wt),Et++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(wt,this.frictionResult)}this.enableFrictionReduction&&Et&&this.createFrictionFromAverage(Et)}};var Jt=new l,Yt=new l,he=new l;f.prototype[s.types.PLANE|s.types.PARTICLE]=f.prototype.planeParticle=function(ct,mt,_t,Mt,S,O,q,X){var B=Jt;B.set(0,0,1),q.quaternion.vmult(B,B);var ut=Yt;Mt.vsub(q.position,ut);var dt=B.dot(ut);if(dt<=0){var xt=this.createContactEquation(X,q,mt,ct);xt.ni.copy(B),xt.ni.negate(xt.ni),xt.ri.set(0,0,0);var pt=he;B.mult(B.dot(Mt),pt),Mt.vsub(pt,pt),xt.rj.copy(pt),this.result.push(xt),this.createFrictionEquationsFromContact(xt,this.frictionResult)}};var ae=new l;f.prototype[s.types.PARTICLE|s.types.SPHERE]=f.prototype.sphereParticle=function(ct,mt,_t,Mt,S,O,q,X){var B=ae;B.set(0,0,1),Mt.vsub(_t,B);var ut=B.norm2();if(ut<=ct.radius*ct.radius){var dt=this.createContactEquation(X,q,mt,ct);B.normalize(),dt.rj.copy(B),dt.rj.mult(ct.radius,dt.rj),dt.ni.copy(B),dt.ni.negate(dt.ni),dt.ri.set(0,0,0),this.result.push(dt),this.createFrictionEquationsFromContact(dt,this.frictionResult)}};var Pe=new u,We=new l;new l;var Fe=new l,le=new l,rn=new l;f.prototype[s.types.PARTICLE|s.types.CONVEXPOLYHEDRON]=f.prototype.convexParticle=function(ct,mt,_t,Mt,S,O,q,X){var B=-1,ut=Fe,dt=rn,xt=null,pt=We;if(pt.copy(Mt),pt.vsub(_t,pt),S.conjugate(Pe),Pe.vmult(pt,pt),ct.pointIsInside(pt)){ct.worldVerticesNeedsUpdate&&ct.computeWorldVertices(_t,S),ct.worldFaceNormalsNeedsUpdate&&ct.computeWorldFaceNormals(S);for(var ft=0,vt=ct.faces.length;ft!==vt;ft++){var Et=[ct.worldVertices[ct.faces[ft][0]]],Nt=ct.worldFaceNormals[ft];Mt.vsub(Et[0],le);var wt=-Nt.dot(le);(xt===null||Math.abs(wt)<Math.abs(xt))&&(xt=wt,B=ft,ut.copy(Nt))}if(B!==-1){var Bt=this.createContactEquation(X,q,mt,ct);ut.mult(xt,dt),dt.vadd(Mt,dt),dt.vsub(_t,dt),Bt.rj.copy(dt),ut.negate(Bt.ni),Bt.ri.set(0,0,0);var kt=Bt.ri,Gt=Bt.rj;kt.vadd(Mt,kt),kt.vsub(X.position,kt),Gt.vadd(_t,Gt),Gt.vsub(q.position,Gt),this.result.push(Bt),this.createFrictionEquationsFromContact(Bt,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}},f.prototype[s.types.BOX|s.types.HEIGHTFIELD]=f.prototype.boxHeightfield=function(ct,mt,_t,Mt,S,O,q,X){ct.convexPolyhedronRepresentation.material=ct.material,ct.convexPolyhedronRepresentation.collisionResponse=ct.collisionResponse,this.convexHeightfield(ct.convexPolyhedronRepresentation,mt,_t,Mt,S,O,q,X)};var sn=new l,un=new l,$e=[0];f.prototype[s.types.CONVEXPOLYHEDRON|s.types.HEIGHTFIELD]=f.prototype.convexHeightfield=function(ct,mt,_t,Mt,S,O,q,X){var B=mt.data,ut=mt.elementSize,dt=ct.boundingSphereRadius,xt=un,pt=$e,ft=sn;h.pointToLocalFrame(Mt,O,_t,ft);var vt=Math.floor((ft.x-dt)/ut)-1,Et=Math.ceil((ft.x+dt)/ut)+1,Nt=Math.floor((ft.y-dt)/ut)-1,wt=Math.ceil((ft.y+dt)/ut)+1;if(!(Et<0||wt<0||vt>B.length||Nt>B[0].length)){vt<0&&(vt=0),Et<0&&(Et=0),Nt<0&&(Nt=0),wt<0&&(wt=0),vt>=B.length&&(vt=B.length-1),Et>=B.length&&(Et=B.length-1),wt>=B[0].length&&(wt=B[0].length-1),Nt>=B[0].length&&(Nt=B[0].length-1);var Bt=[];mt.getRectMinMax(vt,Nt,Et,wt,Bt);var kt=Bt[0],Gt=Bt[1];if(!(ft.z-dt>Gt||ft.z+dt<kt))for(var Ht=vt;Ht<Et;Ht++)for(var Xt=Nt;Xt<wt;Xt++)mt.getConvexTrianglePillar(Ht,Xt,!1),h.pointToWorldFrame(Mt,O,mt.pillarOffset,xt),_t.distanceTo(xt)<mt.pillarConvex.boundingSphereRadius+ct.boundingSphereRadius&&this.convexConvex(ct,mt.pillarConvex,_t,xt,S,O,q,X,null,null,pt,null),mt.getConvexTrianglePillar(Ht,Xt,!0),h.pointToWorldFrame(Mt,O,mt.pillarOffset,xt),_t.distanceTo(xt)<mt.pillarConvex.boundingSphereRadius+ct.boundingSphereRadius&&this.convexConvex(ct,mt.pillarConvex,_t,xt,S,O,q,X,null,null,pt,null)}};var Mn=new l,ue=new l;f.prototype[s.types.SPHERE|s.types.HEIGHTFIELD]=f.prototype.sphereHeightfield=function(ct,mt,_t,Mt,S,O,q,X){var B=mt.data,ut=ct.radius,dt=mt.elementSize,xt=ue,pt=Mn;h.pointToLocalFrame(Mt,O,_t,pt);var ft=Math.floor((pt.x-ut)/dt)-1,vt=Math.ceil((pt.x+ut)/dt)+1,Et=Math.floor((pt.y-ut)/dt)-1,Nt=Math.ceil((pt.y+ut)/dt)+1;if(!(vt<0||Nt<0||ft>B.length||Nt>B[0].length)){ft<0&&(ft=0),vt<0&&(vt=0),Et<0&&(Et=0),Nt<0&&(Nt=0),ft>=B.length&&(ft=B.length-1),vt>=B.length&&(vt=B.length-1),Nt>=B[0].length&&(Nt=B[0].length-1),Et>=B[0].length&&(Et=B[0].length-1);var wt=[];mt.getRectMinMax(ft,Et,vt,Nt,wt);var Bt=wt[0],kt=wt[1];if(!(pt.z-ut>kt||pt.z+ut<Bt))for(var Gt=this.result,Ht=ft;Ht<vt;Ht++)for(var Xt=Et;Xt<Nt;Xt++){var Vt=Gt.length;mt.getConvexTrianglePillar(Ht,Xt,!1),h.pointToWorldFrame(Mt,O,mt.pillarOffset,xt),_t.distanceTo(xt)<mt.pillarConvex.boundingSphereRadius+ct.boundingSphereRadius&&this.sphereConvex(ct,mt.pillarConvex,_t,xt,S,O,q,X),mt.getConvexTrianglePillar(Ht,Xt,!0),h.pointToWorldFrame(Mt,O,mt.pillarOffset,xt),_t.distanceTo(xt)<mt.pillarConvex.boundingSphereRadius+ct.boundingSphereRadius&&this.sphereConvex(ct,mt.pillarConvex,_t,xt,S,O,q,X);var de=Gt.length-Vt;if(de>2)return}}}},{"../collision/AABB":3,"../collision/Ray":9,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43,"../solver/Solver":47,"../utils/Vec3Pool":54}],56:[function(e,n,i){n.exports=x;var r=e("../shapes/Shape"),s=e("../math/Vec3"),o=e("../math/Quaternion"),l=e("../solver/GSSolver");e("../utils/Vec3Pool"),e("../equations/ContactEquation"),e("../equations/FrictionEquation");var h=e("./Narrowphase"),u=e("../utils/EventTarget"),c=e("../collision/ArrayCollisionMatrix"),d=e("../material/Material"),p=e("../material/ContactMaterial"),f=e("../objects/Body"),g=e("../utils/TupleDictionary"),y=e("../collision/RaycastResult"),m=e("../collision/AABB"),v=e("../collision/Ray"),_=e("../collision/NaiveBroadphase");function x(){u.apply(this),this.dt=-1,this.allowSleep=!1,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=0,this.quatNormalizeFast=!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new s,this.broadphase=new _,this.bodies=[],this.solver=new l,this.constraints=[],this.narrowphase=new h(this),this.collisionMatrix=new c,this.collisionMatrixPrevious=new c,this.materials=[],this.contactmaterials=[],this.contactMaterialTable=new g,this.defaultMaterial=new d("default"),this.defaultContactMaterial=new p(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null}}x.prototype=new u,new m;var w=new v;if(x.prototype.getContactMaterial=function(z,it){return this.contactMaterialTable.get(z.id,it.id)},x.prototype.numObjects=function(){return this.bodies.length},x.prototype.collisionMatrixTick=function(){var z=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=z,this.collisionMatrix.reset()},x.prototype.add=x.prototype.addBody=function(z){this.bodies.indexOf(z)===-1&&(z.index=this.bodies.length,this.bodies.push(z),z.world=this,z.initPosition.copy(z.position),z.initVelocity.copy(z.velocity),z.timeLastSleepy=this.time,z instanceof f&&(z.initAngularVelocity.copy(z.angularVelocity),z.initQuaternion.copy(z.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=z,this.dispatchEvent(this.addBodyEvent))},x.prototype.addConstraint=function(z){this.constraints.push(z)},x.prototype.removeConstraint=function(z){var it=this.constraints.indexOf(z);it!==-1&&this.constraints.splice(it,1)},x.prototype.rayTest=function(z,it,W){W instanceof y?this.raycastClosest(z,it,{skipBackfaces:!0},W):this.raycastAll(z,it,{skipBackfaces:!0},W)},x.prototype.raycastAll=function(z,it,W,T){return W.mode=v.ALL,W.from=z,W.to=it,W.callback=T,w.intersectWorld(this,W)},x.prototype.raycastAny=function(z,it,W,T){return W.mode=v.ANY,W.from=z,W.to=it,W.result=T,w.intersectWorld(this,W)},x.prototype.raycastClosest=function(z,it,W,T){return W.mode=v.CLOSEST,W.from=z,W.to=it,W.result=T,w.intersectWorld(this,W)},x.prototype.remove=function(z){z.world=null;var it=this.bodies.length-1,W=this.bodies,T=W.indexOf(z);if(T!==-1){W.splice(T,1);for(var Z=0;Z!==W.length;Z++)W[Z].index=Z;this.collisionMatrix.setNumObjects(it),this.removeBodyEvent.body=z,this.dispatchEvent(this.removeBodyEvent)}},x.prototype.removeBody=x.prototype.remove,x.prototype.addMaterial=function(z){this.materials.push(z)},x.prototype.addContactMaterial=function(z){this.contactmaterials.push(z),this.contactMaterialTable.set(z.materials[0].id,z.materials[1].id,z)},typeof performance=="undefined"&&(performance={}),!performance.now){var C=Date.now();performance.timing&&performance.timing.navigationStart&&(C=performance.timing.navigationStart),performance.now=function(){return Date.now()-C}}var M=new s;x.prototype.step=function(z,it,W){if(W=W||10,it=it||0,it===0)this.internalStep(z),this.time+=z;else{var T=Math.floor((this.time+it)/z)-Math.floor(this.time/z);T=Math.min(T,W);for(var Z=performance.now(),A=0;A!==T&&(this.internalStep(z),!(performance.now()-Z>z*1e3));A++);this.time+=it;for(var I=this.time%z,R=I/z,F=M,ot=this.bodies,et=0;et!==ot.length;et++){var k=ot[et];k.type!==f.STATIC&&k.sleepState!==f.SLEEPING?(k.position.vsub(k.previousPosition,F),F.scale(R,F),k.position.vadd(F,k.interpolatedPosition)):(k.interpolatedPosition.copy(k.position),k.interpolatedQuaternion.copy(k.quaternion))}}};var D={type:"postStep"},j={type:"preStep"},N={type:"collide",body:null,contact:null},b=[],U=[],V=[],H=[];new s,new s,new s,new s,new s,new s,new s,new s,new s,new o;var Y=new o,Q=new o,P=new s;x.prototype.internalStep=function(z){this.dt=z;var it=this.contacts,W=V,T=H,Z=this.numObjects(),A=this.bodies,I=this.solver,R=this.gravity,F=this.doProfiling,ot=this.profile,et=f.DYNAMIC,k,nt=this.constraints,lt=U;R.norm();var $=R.x,rt=R.y,st=R.z,K=0;for(F&&(k=performance.now()),K=0;K!==Z;K++){var tt=A[K];if(tt.type&et){var Lt=tt.force,St=tt.mass;Lt.x+=St*$,Lt.y+=St*rt,Lt.z+=St*st}}for(var K=0,zt=this.subsystems.length;K!==zt;K++)this.subsystems[K].update();F&&(k=performance.now()),W.length=0,T.length=0,this.broadphase.collisionPairs(this,W,T),F&&(ot.broadphase=performance.now()-k);var Pt=nt.length;for(K=0;K!==Pt;K++){var L=nt[K];if(!L.collideConnected)for(var E=W.length-1;E>=0;E-=1)(L.bodyA===W[E]&&L.bodyB===T[E]||L.bodyB===W[E]&&L.bodyA===T[E])&&(W.splice(E,1),T.splice(E,1))}this.collisionMatrixTick(),F&&(k=performance.now());var at=b,ht=it.length;for(K=0;K!==ht;K++)at.push(it[K]);it.length=0;var bt=this.frictionEquations.length;for(K=0;K!==bt;K++)lt.push(this.frictionEquations[K]);this.frictionEquations.length=0,this.narrowphase.getContacts(W,T,this,it,at,this.frictionEquations,lt),F&&(ot.narrowphase=performance.now()-k),F&&(k=performance.now());for(var K=0;K<this.frictionEquations.length;K++)I.addEquation(this.frictionEquations[K]);for(var Ct=it.length,J=0;J!==Ct;J++){var L=it[J],tt=L.bi,yt=L.bj;L.si,L.sj;var gt;if(tt.material&&yt.material?gt=this.getContactMaterial(tt.material,yt.material)||this.defaultContactMaterial:gt=this.defaultContactMaterial,gt.friction,tt.material&&yt.material&&(tt.material.friction>=0&&yt.material.friction>=0&&tt.material.friction*yt.material.friction,tt.material.restitution>=0&&yt.material.restitution>=0&&(L.restitution=tt.material.restitution*yt.material.restitution)),I.addEquation(L),tt.allowSleep&&tt.type===f.DYNAMIC&&tt.sleepState===f.SLEEPING&&yt.sleepState===f.AWAKE&&yt.type!==f.STATIC){var Rt=yt.velocity.norm2()+yt.angularVelocity.norm2(),At=Math.pow(yt.sleepSpeedLimit,2);Rt>=At*2&&(tt._wakeUpAfterNarrowphase=!0)}if(yt.allowSleep&&yt.type===f.DYNAMIC&&yt.sleepState===f.SLEEPING&&tt.sleepState===f.AWAKE&&tt.type!==f.STATIC){var Ft=tt.velocity.norm2()+tt.angularVelocity.norm2(),Dt=Math.pow(tt.sleepSpeedLimit,2);Ft>=Dt*2&&(yt._wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(tt,yt,!0),this.collisionMatrixPrevious.get(tt,yt)||(N.body=yt,N.contact=L,tt.dispatchEvent(N),N.body=tt,yt.dispatchEvent(N))}for(F&&(ot.makeContactConstraints=performance.now()-k,k=performance.now()),K=0;K!==Z;K++){var tt=A[K];tt._wakeUpAfterNarrowphase&&(tt.wakeUp(),tt._wakeUpAfterNarrowphase=!1)}var Pt=nt.length;for(K=0;K!==Pt;K++){var L=nt[K];L.update();for(var E=0,Ut=L.equations.length;E!==Ut;E++){var Jt=L.equations[E];I.addEquation(Jt)}}I.solve(z,this),F&&(ot.solve=performance.now()-k),I.removeAllEquations();var Yt=Math.pow;for(K=0;K!==Z;K++){var tt=A[K];if(tt.type&et){var he=Yt(1-tt.linearDamping,z),ae=tt.velocity;ae.mult(he,ae);var Pe=tt.angularVelocity;if(Pe){var We=Yt(1-tt.angularDamping,z);Pe.mult(We,Pe)}}}for(this.dispatchEvent(j),K=0;K!==Z;K++){var tt=A[K];tt.preStep&&tt.preStep.call(tt)}F&&(k=performance.now());var Fe=Y,le=Q,rn=this.stepnumber,sn=f.DYNAMIC|f.KINEMATIC,un=rn%(this.quatNormalizeSkip+1)==0,$e=this.quatNormalizeFast,Mn=z*.5;for(r.types.PLANE,r.types.CONVEXPOLYHEDRON,K=0;K!==Z;K++){var ue=A[K],ct=ue.force,mt=ue.torque;if(ue.type&sn&&ue.sleepState!==f.SLEEPING){var _t=ue.velocity,Mt=ue.angularVelocity,S=ue.position,O=ue.quaternion,q=ue.invMass,X=ue.invInertiaWorld;_t.x+=ct.x*q*z,_t.y+=ct.y*q*z,_t.z+=ct.z*q*z,ue.angularVelocity&&(X.vmult(mt,P),P.mult(z,P),P.vadd(Mt,Mt)),S.x+=_t.x*z,S.y+=_t.y*z,S.z+=_t.z*z,ue.angularVelocity&&(Fe.set(Mt.x,Mt.y,Mt.z,0),Fe.mult(O,le),O.x+=Mn*le.x,O.y+=Mn*le.y,O.z+=Mn*le.z,O.w+=Mn*le.w,un&&($e?O.normalizeFast():O.normalize())),ue.aabb&&(ue.aabbNeedsUpdate=!0),ue.updateInertiaWorld&&ue.updateInertiaWorld()}}for(this.clearForces(),this.broadphase.dirty=!0,F&&(ot.integrate=performance.now()-k),this.time+=z,this.stepnumber+=1,this.dispatchEvent(D),K=0;K!==Z;K++){var tt=A[K],B=tt.postStep;B&&B.call(tt)}if(this.allowSleep)for(K=0;K!==Z;K++)A[K].sleepTick(this.time)},x.prototype.clearForces=function(){for(var z=this.bodies,it=z.length,W=0;W!==it;W++){var T=z[W];T.force,T.torque,T.force.set(0,0,0),T.torque.set(0,0,0)}}},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/Ray":9,"../collision/RaycastResult":10,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../material/ContactMaterial":24,"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Shape":43,"../solver/GSSolver":46,"../utils/EventTarget":49,"../utils/TupleDictionary":52,"../utils/Vec3Pool":54,"./Narrowphase":55}]},{},[2])(2)})})(ig);export{Pv as A,Zi as B,Ot as C,Lv as D,fv as M,Ks as O,dl as S,Kt as W,Oe as a,ig as c};
