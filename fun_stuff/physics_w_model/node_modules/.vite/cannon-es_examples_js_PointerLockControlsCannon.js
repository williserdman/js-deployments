import {
  Vec3
} from "./chunk-JJDDTXFV.js";
import {
  __publicField
} from "./chunk-GBVKMVG3.js";

// node_modules/cannon-es/examples/js/PointerLockControlsCannon.js
import {
  Euler,
  EventDispatcher,
  Object3D,
  Quaternion,
  Vector3
} from "https://unpkg.com/three@0.122.0/build/three.module.js";
var PointerLockControlsCannon = class extends EventDispatcher {
  constructor(camera, cannonBody) {
    super();
    __publicField(this, "onPointerlockChange", () => {
      if (document.pointerLockElement) {
        this.dispatchEvent(this.lockEvent);
        this.isLocked = true;
      } else {
        this.dispatchEvent(this.unlockEvent);
        this.isLocked = false;
      }
    });
    __publicField(this, "onPointerlockError", () => {
      console.error("PointerLockControlsCannon: Unable to use Pointer Lock API");
    });
    __publicField(this, "onMouseMove", (event) => {
      if (!this.enabled) {
        return;
      }
      const { movementX, movementY } = event;
      this.yawObject.rotation.y -= movementX * 2e-3;
      this.pitchObject.rotation.x -= movementY * 2e-3;
      this.pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitchObject.rotation.x));
    });
    __publicField(this, "onKeyDown", (event) => {
      switch (event.code) {
        case "KeyW":
        case "ArrowUp":
          this.moveForward = true;
          break;
        case "KeyA":
        case "ArrowLeft":
          this.moveLeft = true;
          break;
        case "KeyS":
        case "ArrowDown":
          this.moveBackward = true;
          break;
        case "KeyD":
        case "ArrowRight":
          this.moveRight = true;
          break;
        case "Space":
          if (this.canJump) {
            this.velocity.y = this.jumpVelocity;
          }
          this.canJump = false;
          break;
      }
    });
    __publicField(this, "onKeyUp", (event) => {
      switch (event.code) {
        case "KeyW":
        case "ArrowUp":
          this.moveForward = false;
          break;
        case "KeyA":
        case "ArrowLeft":
          this.moveLeft = false;
          break;
        case "KeyS":
        case "ArrowDown":
          this.moveBackward = false;
          break;
        case "KeyD":
        case "ArrowRight":
          this.moveRight = false;
          break;
      }
    });
    this.enabled = false;
    this.cannonBody = cannonBody;
    this.velocityFactor = 0.2;
    this.jumpVelocity = 20;
    this.pitchObject = new Object3D();
    this.pitchObject.add(camera);
    this.yawObject = new Object3D();
    this.yawObject.position.y = 2;
    this.yawObject.add(this.pitchObject);
    this.quaternion = new Quaternion();
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.canJump = false;
    const contactNormal = new Vec3();
    const upAxis = new Vec3(0, 1, 0);
    this.cannonBody.addEventListener("collide", (event) => {
      const { contact } = event;
      if (contact.bi.id === this.cannonBody.id) {
        contact.ni.negate(contactNormal);
      } else {
        contactNormal.copy(contact.ni);
      }
      if (contactNormal.dot(upAxis) > 0.5) {
        this.canJump = true;
      }
    });
    this.velocity = this.cannonBody.velocity;
    this.inputVelocity = new Vector3();
    this.euler = new Euler();
    this.lockEvent = { type: "lock" };
    this.unlockEvent = { type: "unlock" };
    this.connect();
  }
  connect() {
    document.addEventListener("mousemove", this.onMouseMove);
    document.addEventListener("pointerlockchange", this.onPointerlockChange);
    document.addEventListener("pointerlockerror", this.onPointerlockError);
    document.addEventListener("keydown", this.onKeyDown);
    document.addEventListener("keyup", this.onKeyUp);
  }
  disconnect() {
    document.removeEventListener("mousemove", this.onMouseMove);
    document.removeEventListener("pointerlockchange", this.onPointerlockChange);
    document.removeEventListener("pointerlockerror", this.onPointerlockError);
    document.removeEventListener("keydown", this.onKeyDown);
    document.removeEventListener("keyup", this.onKeyUp);
  }
  dispose() {
    this.disconnect();
  }
  lock() {
    document.body.requestPointerLock();
  }
  unlock() {
    document.exitPointerLock();
  }
  getObject() {
    return this.yawObject;
  }
  getDirection() {
    const vector = new Vec3(0, 0, -1);
    vector.applyQuaternion(this.quaternion);
    return vector;
  }
  update(delta) {
    if (this.enabled === false) {
      return;
    }
    delta *= 1e3;
    delta *= 0.1;
    this.inputVelocity.set(0, 0, 0);
    if (this.moveForward) {
      this.inputVelocity.z = -this.velocityFactor * delta;
    }
    if (this.moveBackward) {
      this.inputVelocity.z = this.velocityFactor * delta;
    }
    if (this.moveLeft) {
      this.inputVelocity.x = -this.velocityFactor * delta;
    }
    if (this.moveRight) {
      this.inputVelocity.x = this.velocityFactor * delta;
    }
    this.euler.x = this.pitchObject.rotation.x;
    this.euler.y = this.yawObject.rotation.y;
    this.euler.order = "XYZ";
    this.quaternion.setFromEuler(this.euler);
    this.inputVelocity.applyQuaternion(this.quaternion);
    this.velocity.x += this.inputVelocity.x;
    this.velocity.z += this.inputVelocity.z;
    this.yawObject.position.copy(this.cannonBody.position);
  }
};
export {
  PointerLockControlsCannon
};
//# sourceMappingURL=cannon-es_examples_js_PointerLockControlsCannon.js.map
